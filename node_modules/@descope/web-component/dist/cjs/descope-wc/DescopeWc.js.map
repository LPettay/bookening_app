{"version":3,"file":"DescopeWc.js","sources":["../../../src/lib/descope-wc/DescopeWc.ts"],"sourcesContent":["import {\n  clearFingerprintData,\n  ensureFingerprintIds,\n} from '@descope/web-js-sdk';\nimport {\n  CUSTOM_INTERACTIONS,\n  DESCOPE_ATTRIBUTE_EXCLUDE_FIELD,\n  DESCOPE_ATTRIBUTE_EXCLUDE_NEXT_BUTTON,\n  ELEMENT_TYPE_ATTRIBUTE,\n  FETCH_ERROR_RESPONSE_ERROR_CODE,\n  FETCH_EXCEPTION_ERROR_CODE,\n  FLOW_REQUESTED_IS_IN_OLD_VERSION_ERROR_CODE,\n  FLOW_TIMED_OUT_ERROR_CODE,\n  POLLING_STATUS_NOT_FOUND_ERROR_CODE,\n  RESPONSE_ACTIONS,\n  SDK_SCRIPTS_LOAD_TIMEOUT,\n  URL_CODE_PARAM_NAME,\n  URL_RUN_IDS_PARAM_NAME,\n  URL_TOKEN_PARAM_NAME,\n} from '../constants';\nimport {\n  clearPreviousExternalInputs,\n  getAnimationDirection,\n  getElementDescopeAttributes,\n  getFirstNonEmptyValue,\n  getScriptResultPath,\n  getUserLocale,\n  handleAutoFocus,\n  handleReportValidityOnBlur,\n  injectSamlIdpForm,\n  isConditionalLoginSupported,\n  leadingDebounce,\n  openCenteredPopup,\n  setTOTPVariable,\n  showFirstScreenOnExecutionInit,\n  State,\n  submitForm,\n  timeoutPromise,\n  transformScreenInputs,\n  transformStepStateForCustomScreen,\n  updateScreenFromScreenState,\n  updateTemplateFromScreenState,\n  withMemCache,\n} from '../helpers';\nimport { getABTestingKey } from '../helpers/abTestingKey';\nimport { calculateCondition, calculateConditions } from '../helpers/conditions';\nimport { getLastAuth, setLastAuth } from '../helpers/lastAuth';\nimport { IsChanged } from '../helpers/state';\nimport {\n  disableWebauthnButtons,\n  replaceElementMessage,\n  setCssVars,\n  setNOTPVariable,\n  setPhoneAutoDetectDefaultCode,\n} from '../helpers/templates';\nimport {\n  ClientScript,\n  ComponentsConfig,\n  CustomScreenState,\n  FlowState,\n  NextFn,\n  NextFnReturnPromiseValue,\n  ScriptElement,\n  ScriptModule,\n  SdkConfig,\n  StepState,\n} from '../types';\nimport BaseDescopeWc from './BaseDescopeWc';\n\n// this class is responsible for WC flow execution\nclass DescopeWc extends BaseDescopeWc {\n  errorTransformer:\n    | ((error: { text: string; type: string }) => string)\n    | undefined;\n\n  static set sdkConfigOverrides(config: Partial<SdkConfig>) {\n    BaseDescopeWc.sdkConfigOverrides = config;\n  }\n\n  static get sdkConfigOverrides() {\n    return BaseDescopeWc.sdkConfigOverrides;\n  }\n\n  flowState: State<FlowState>;\n\n  stepState = new State<StepState>({} as StepState);\n\n  #pollingTimeout: NodeJS.Timeout;\n\n  #conditionalUiAbortController = null;\n\n  onScreenUpdate?: (\n    screenName: string,\n    context: CustomScreenState,\n    next: StepState['next'],\n    ref: typeof this,\n  ) => boolean | Promise<boolean>;\n\n  #sdkScriptsLoading = null;\n\n  constructor() {\n    const flowState = new State<FlowState>({\n      deferredRedirect: false,\n    } as FlowState);\n\n    super(flowState.update.bind(flowState));\n\n    this.flowState = flowState;\n  }\n\n  #eventsCbRefs = {\n    visibilitychange: this.#syncStateWithVisibility.bind(this),\n  };\n\n  #syncStateWithVisibility() {\n    if (!document.hidden) {\n      // Defer the update a bit, it won't work otherwise\n      setTimeout(() => {\n        // Trigger state update that will redirect and pending deferred redirection\n        this.flowState.update({ deferredRedirect: false });\n      }, 300);\n    }\n  }\n\n  // Native bridge version native / web syncing - change this when\n  // a major change happens that requires some form of compatibility\n  bridgeVersion = 2;\n\n  // A collection of callbacks that are maintained as part of the web-component state\n  // when it's connected to a native bridge.\n  nativeCallbacks: {\n    // This callback will be initialized once a 'nativeBridge' action is\n    // received from a start or next request. It will then be called by\n    // nativeResume if appropriate as part of handling some payload types.\n    complete?: (input: Record<string, any>) => Promise<void>;\n\n    // This callback is invoked when 'nativeResume' is called with a 'beforeScreen'\n    // type, so the native bridge can resolve the async call to 'nativeBeforeScreen'\n    // and tell the web-component whether it wants a custom screen or not.\n    screenResolve?: (value: boolean) => void;\n\n    // This callback it kept until 'nativeResume' is called with a 'resumeScreen'\n    // type, so the native bridge can submit the result of a custom screen.\n    screenNext?: StepState['next'];\n  } = {};\n\n  // Notifies the native bridge that we're about to show a new screen and lets it\n  // override it by showing a native screen instead.\n  async #nativeBeforeScreen(\n    screen: string,\n    context: CustomScreenState,\n    next: StepState['next'],\n  ): Promise<boolean> {\n    if (this.nativeOptions?.bridgeVersion >= 2) {\n      return new Promise<boolean>((resolve) => {\n        this.nativeCallbacks.screenNext = next;\n        this.nativeCallbacks.screenResolve = resolve;\n        this.#nativeNotifyBridge('beforeScreen', { screen, context });\n      });\n    }\n    return false;\n  }\n\n  // Notifies the native bridge that a screen has been shown.\n  #nativeAfterScreen(screen: string) {\n    if (this.nativeOptions?.bridgeVersion >= 2) {\n      this.#nativeNotifyBridge('afterScreen', { screen });\n    }\n  }\n\n  // This callback is called by the native layer to resume a flow\n  // that's waiting for some external trigger, such as a magic link\n  // redirect or native OAuth authentication.\n  nativeResume(type: string, payload: string) {\n    const response = JSON.parse(payload);\n    if (type === 'oauthWeb' || type === 'sso') {\n      let { exchangeCode } = response;\n      if (!exchangeCode) {\n        const url = new URL(response.url);\n        exchangeCode = url.searchParams?.get(URL_CODE_PARAM_NAME);\n      }\n      this.nativeCallbacks.complete?.({\n        exchangeCode,\n        idpInitiated: true,\n      });\n    } else if (type === 'magicLink') {\n      const url = new URL(response.url);\n      const token = url.searchParams.get(URL_TOKEN_PARAM_NAME);\n      const stepId = url.searchParams\n        .get(URL_RUN_IDS_PARAM_NAME)\n        .split('_')\n        .pop();\n      this.#resetPollingTimeout();\n      // update the state along with cancelling out the action to abort the polling mechanism\n      this.flowState.update({ token, stepId, action: undefined });\n    } else if (type === 'beforeScreen') {\n      const { screenResolve } = this.nativeCallbacks;\n      this.nativeCallbacks.screenResolve = null;\n      const { override } = response;\n      if (!override) {\n        this.nativeCallbacks.screenNext = null;\n      }\n      screenResolve?.(override);\n    } else if (type === 'resumeScreen') {\n      const { interactionId, form } = response;\n      const { screenNext } = this.nativeCallbacks;\n      this.nativeCallbacks.screenNext = null;\n      screenNext?.(interactionId, form);\n    } else {\n      // expected: 'oauthNative', 'webauthnCreate', 'webauthnGet', 'failure'\n      this.nativeCallbacks.complete?.(response);\n    }\n  }\n\n  // Utility function for sending a generic message to the native bridge.\n  #nativeNotifyBridge(type: string, payload: Record<string, any>) {\n    this.#dispatch('bridge', {\n      type,\n      payload,\n    });\n  }\n\n  // This object is set by the native layer to\n  // inject native specific data into the 'flowState'.\n  nativeOptions?: {\n    platform: 'ios' | 'android';\n    bridgeVersion: number;\n    oauthProvider?: string;\n    oauthRedirect?: string;\n    magicLinkRedirect?: string;\n    ssoRedirect?: string;\n    origin?: string;\n  };\n\n  /**\n   * Get all loaded SDK script modules from elements with data-script-id attribute\n   * @returns Array of script modules that can be refreshed before form submission\n   */\n  loadSdkScriptsModules() {\n    // Get all modules from the data-script-id elements\n    const scriptElements = this.shadowRoot.querySelectorAll(\n      'div[data-script-id]',\n    );\n\n    // Filter out elements without moduleRes property\n    return Array.from(scriptElements)\n      .map((el) => (el as ScriptElement).moduleRes)\n      .filter((module): module is ScriptModule => !!module);\n  }\n\n  loadSdkScripts(scripts: ClientScript[]) {\n    if (!scripts?.length) {\n      return null;\n    }\n\n    const createScriptCallback =\n      (\n        script: {\n          id: string;\n          resultKey?: string;\n        },\n        resolve: (value: any) => void,\n      ) =>\n      (result: string) => {\n        this.dispatchEvent(\n          // update the context with the result, under the `resultKey` key\n          new CustomEvent('components-context', {\n            detail: {\n              // we store the result with script.id prefix to avoid conflicts with other scripts results\n              // that may have the same key\n              [getScriptResultPath(script.id, script.resultKey)]: result,\n            },\n            bubbles: true,\n            composed: true,\n          }),\n        );\n        resolve(script.id);\n      };\n\n    this.loggerWrapper.debug(\n      `Preparing to load scripts: ${scripts.map((s) => s.id).join(', ')}`,\n    );\n    const promises = Promise.all(\n      scripts?.map(async (script) => {\n        const scriptElement = this.shadowRoot.querySelector(\n          `[data-script-id=\"${script.id}\"]`,\n        ) as ScriptElement;\n        if (scriptElement) {\n          this.loggerWrapper.debug('Script already loaded', script.id);\n          const { moduleRes } = scriptElement;\n          moduleRes?.start?.();\n          return moduleRes;\n        }\n        await this.injectNpmLib(\n          '@descope/flow-scripts',\n          '1.0.11', // currently using a fixed version when loading scripts\n          `dist/${script.id}.js`,\n        );\n        const module = globalThis.descope?.[script.id];\n        return new Promise((resolve, reject) => {\n          try {\n            const moduleRes = module(\n              script.initArgs as any,\n              { baseUrl: this.baseUrl, ref: this },\n              createScriptCallback(script, resolve),\n            );\n            if (moduleRes) {\n              const newScriptElement = document.createElement(\n                'div',\n              ) as ScriptElement;\n              newScriptElement.setAttribute('data-script-id', script.id);\n              newScriptElement.moduleRes = moduleRes;\n              this.shadowRoot.appendChild(newScriptElement);\n              this.nextRequestStatus.subscribe(() => {\n                this.loggerWrapper.debug('Unloading script', script.id);\n                moduleRes.stop?.();\n              });\n            }\n          } catch (e) {\n            reject(e);\n          }\n        });\n      }),\n    );\n\n    const toPromise = new Promise((resolve) => {\n      setTimeout(() => {\n        this.loggerWrapper.warn('SDK scripts loading timeout');\n        resolve(true);\n      }, SDK_SCRIPTS_LOAD_TIMEOUT);\n    });\n\n    return Promise.race([promises, toPromise]);\n  }\n\n  get isDismissScreenErrorOnInput() {\n    return this.getAttribute('dismiss-screen-error-on-input') === 'true';\n  }\n\n  #handleGlobalErrors({\n    errorText,\n    errorType,\n  }: {\n    errorText: string;\n    errorType: string;\n  }) {\n    const updateGlobalError = () => {\n      let transformedErrorText = errorText;\n      try {\n        transformedErrorText =\n          this.errorTransformer?.({\n            text: errorText,\n            type: errorType,\n          }) || errorText;\n      } catch (e) {\n        this.loggerWrapper.error('Error transforming error message', e.message);\n      }\n      replaceElementMessage(\n        this.contentRootElement,\n        'error-message',\n        transformedErrorText,\n      );\n    };\n\n    // we do not know if the page is going to be updated or not,\n    // so we are updating the error message component before and after the screen update\n    this.addEventListener('screen-updated', updateGlobalError, { once: true });\n    updateGlobalError();\n  }\n\n  init() {\n    // when running in a webview (mobile SDK) we want to lazy init the component\n    // so the mobile SDK will be able to register all the necessary callbacks\n    // before the component will start loading the flow\n    if (!(window as any).descopeBridge) {\n      // eslint-disable-next-line no-underscore-dangle\n      return this._init();\n    }\n    // eslint-disable-next-line no-underscore-dangle\n    (this as any).lazyInit = this._init;\n    return undefined;\n  }\n\n  #subscribeStepState() {\n    this.stepState?.subscribe(\n      this.onStepChange.bind(this),\n      ({\n        screenState: { errorText, errorType, ...screenState } = {},\n        ...state\n      }) => ({ ...state, screenState }),\n    );\n\n    this.stepState?.subscribe(\n      this.#handleGlobalErrors.bind(this),\n      (state) => ({\n        errorText: state?.screenState?.errorText,\n        errorType: state?.screenState?.errorType,\n      }),\n      { forceUpdate: true },\n    );\n\n    this.stepState?.subscribe(\n      this.#handlePasscodeCleanup.bind(this),\n      (state) => ({\n        errorText: state?.screenState?.errorText,\n        errorType: state?.screenState?.errorType,\n      }),\n      { forceUpdate: true },\n    );\n  }\n\n  // because the screen does not re-render,\n  // in case of an OTP code error, we want to clean the invalid code\n  #handlePasscodeCleanup({ errorText, errorType }) {\n    if (errorType || errorText) {\n      this.contentRootElement\n        .querySelectorAll('descope-passcode[data-auto-submit=\"true\"]')\n        .forEach((passcodeEle: HTMLInputElement) => {\n          // currently we do not have a way to reset the code value\n          // so we are clearing the inputs\n          passcodeEle.shadowRoot\n            .querySelectorAll('descope-text-field[data-id]')\n            .forEach((input: HTMLInputElement) => {\n              // eslint-disable-next-line no-param-reassign\n              input.value = '';\n            });\n        });\n\n      // this should not be handled here, it's a workaround for focusing the code component on error\n      // maybe it's about time to refactor this sdk\n      handleAutoFocus(this.contentRootElement, this.autoFocus, false);\n    }\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  async _init() {\n    if (this.shadowRoot.isConnected) {\n      this.flowState?.subscribe(this.onFlowChange.bind(this));\n      this.#subscribeStepState();\n\n      window.addEventListener(\n        'visibilitychange',\n        this.#eventsCbRefs.visibilitychange,\n      );\n    }\n    await super.init?.();\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    this.flowState.unsubscribeAll();\n    this.stepState.unsubscribeAll();\n\n    this.#conditionalUiAbortController?.abort();\n    this.#conditionalUiAbortController = null;\n\n    window.removeEventListener(\n      'visibilitychange',\n      this.#eventsCbRefs.visibilitychange,\n    );\n  }\n\n  async getHtmlFilenameWithLocale(locale: string, screenId: string) {\n    let filenameWithLocale: string;\n    const userLocale = getUserLocale(locale); // use provided locals, otherwise use browser locale\n    const targetLocales = await this.getTargetLocales();\n\n    if (targetLocales.includes(userLocale.locale)) {\n      filenameWithLocale = `${screenId}-${userLocale.locale}.html`;\n    } else if (targetLocales.includes(userLocale.fallback)) {\n      filenameWithLocale = `${screenId}-${userLocale.fallback}.html`;\n    }\n    return filenameWithLocale;\n  }\n\n  async getPageContent(htmlFilename: string, htmlLocaleFilename: string) {\n    if (htmlLocaleFilename) {\n      // try first locale url, if can't get for some reason, fallback to the original html url (the one without locale)\n      try {\n        const { body } = await this.fetchStaticResource(\n          htmlLocaleFilename,\n          'text',\n        );\n        return body;\n      } catch (ex) {\n        this.loggerWrapper.error(\n          `Failed to fetch flow page from ${htmlLocaleFilename}. Fallback to url ${htmlFilename}`,\n          ex,\n        );\n      }\n    }\n\n    try {\n      const { body } = await this.fetchStaticResource(htmlFilename, 'text');\n      return body;\n    } catch (ex) {\n      this.loggerWrapper.error(`Failed to fetch flow page`, ex.message);\n    }\n    return null;\n  }\n\n  async #handleFlowRestart() {\n    this.loggerWrapper.debug('Trying to restart the flow');\n    const prevCompVersion = await this.getComponentsVersion();\n    this.reset();\n    const compVersion = await this.getComponentsVersion();\n\n    if (prevCompVersion === compVersion) {\n      this.loggerWrapper.debug(\n        'Components version was not changed, restarting flow',\n      );\n      this.flowState.update({\n        stepId: null,\n        executionId: null,\n      });\n    } else {\n      this.loggerWrapper.error(\n        'Components version mismatch, please reload the page',\n      );\n    }\n  }\n\n  #isPrevCustomScreen = false;\n\n  async #handleCustomScreen(stepStateUpdate: Partial<StepState>) {\n    const { next, stepName, ...state } = {\n      ...this.stepState.current,\n      ...stepStateUpdate,\n    };\n\n    const context = transformStepStateForCustomScreen(state);\n\n    // first check if we're running in a native bridge and the app wants a custom screen\n    let isCustomScreen = await this.#nativeBeforeScreen(\n      stepName,\n      context,\n      next,\n    );\n    if (!isCustomScreen) {\n      // now check any custom callbacks that have been set on the component itself\n      isCustomScreen = Boolean(\n        await this.onScreenUpdate?.(stepName, context, next, this),\n      );\n    }\n\n    const isFirstScreen = !this.stepState.current.htmlFilename;\n    this.#toggleScreenVisibility(isCustomScreen);\n\n    // if we switched from a custom screen to a regular screen or the other way around\n    if (this.#isPrevCustomScreen !== isCustomScreen) {\n      const [currentMode, prevMode] = ['flow', 'custom'].sort(() =>\n        isCustomScreen ? -1 : 1,\n      );\n      this.loggerWrapper.debug(\n        `Switching from ${prevMode} screen to ${currentMode} screen`,\n      );\n\n      this.#isPrevCustomScreen = isCustomScreen;\n\n      if (isCustomScreen) {\n        // we are unsubscribing all the listeners because we are going to render a custom screen\n        // and we do not want that onStepChange will be called\n        this.stepState.unsubscribeAll();\n      } else {\n        // we are subscribing to the step state again because we are going to render a regular screen\n        this.#subscribeStepState();\n      }\n    }\n\n    if (isCustomScreen) {\n      this.loggerWrapper.debug('Showing a custom screen');\n      this.#dispatchPageEvents({\n        isFirstScreen,\n        isCustomScreen,\n        stepName: stepStateUpdate.stepName,\n      });\n    }\n\n    this.stepState.forceUpdate = isCustomScreen;\n  }\n\n  async onFlowChange(\n    currentState: FlowState,\n    prevState: FlowState,\n    isChanged: IsChanged<FlowState>,\n  ) {\n    const {\n      projectId,\n      flowId,\n      tenant,\n      stepId,\n      executionId,\n      action,\n      screenId,\n      screenState,\n      redirectTo,\n      redirectIsPopup,\n      redirectUrl,\n      token,\n      code,\n      isPopup,\n      exchangeError,\n      webauthnTransactionId,\n      webauthnOptions,\n      redirectAuthCodeChallenge,\n      redirectAuthCallbackUrl,\n      redirectAuthBackupCallbackUri,\n      redirectAuthInitiator,\n      locale,\n      samlIdpResponseUrl,\n      samlIdpResponseSamlResponse,\n      samlIdpResponseRelayState,\n      nativeResponseType,\n      nativePayload,\n      reqTimestamp,\n      ...ssoQueryParams\n    } = currentState;\n\n    let startScreenId: string;\n    let startScreenName: string;\n    let conditionInteractionId: string;\n    const abTestingKey = getABTestingKey();\n    const { outboundAppId } = this;\n    const { outboundAppScopes } = this;\n    const loginId = this.sdk.getLastUserLoginId();\n    const flowConfig = await this.getFlowConfig();\n    const projectConfig = await this.getProjectConfig();\n    const flowVersions = Object.entries(projectConfig.flows || {}).reduce(\n      // pass also current versions for all flows, it may be used as a part of the current flow\n      (acc, [key, value]) => {\n        acc[key] = value.version;\n        return acc;\n      },\n      {} as Record<string, number>,\n    );\n    const redirectAuth =\n      redirectAuthCallbackUrl && redirectAuthCodeChallenge\n        ? {\n            callbackUrl: redirectAuthCallbackUrl,\n            codeChallenge: redirectAuthCodeChallenge,\n            backupCallbackUri: redirectAuthBackupCallbackUri,\n          }\n        : undefined;\n    const nativeOptions = this.nativeOptions\n      ? {\n          platform: this.nativeOptions.platform,\n          bridgeVersion: this.nativeOptions.bridgeVersion,\n          oauthProvider: this.nativeOptions.oauthProvider,\n          oauthRedirect: this.nativeOptions.oauthRedirect,\n          magicLinkRedirect: this.nativeOptions.magicLinkRedirect,\n          ssoRedirect: this.nativeOptions.ssoRedirect,\n        }\n      : undefined;\n    let conditionComponentsConfig: ComponentsConfig = {};\n\n    // if there is no execution id we should start a new flow\n    if (!executionId) {\n      const clientScripts = [\n        ...(flowConfig.clientScripts || []),\n        ...(flowConfig.sdkScripts || []),\n      ];\n\n      if (flowConfig.conditions) {\n        let conditionScripts = [];\n        ({\n          startScreenId,\n          conditionInteractionId,\n          startScreenName,\n          clientScripts: conditionScripts,\n          componentsConfig: conditionComponentsConfig,\n        } = calculateConditions(\n          {\n            loginId,\n            code,\n            token,\n            abTestingKey,\n            lastAuth: getLastAuth(loginId),\n          },\n          flowConfig.conditions,\n        ));\n        clientScripts.push(...(conditionScripts || []));\n      } else if (flowConfig.condition) {\n        ({ startScreenId, conditionInteractionId } = calculateCondition(\n          flowConfig.condition,\n          {\n            loginId,\n            code,\n            token,\n            abTestingKey,\n            lastAuth: getLastAuth(loginId),\n          },\n        ));\n      } else {\n        startScreenName = flowConfig.startScreenName;\n        startScreenId = flowConfig.startScreenId;\n      }\n\n      this.#sdkScriptsLoading = this.loadSdkScripts(clientScripts);\n      if (flowConfig.fingerprintEnabled && flowConfig.fingerprintKey) {\n        await ensureFingerprintIds(flowConfig.fingerprintKey, this.baseUrl);\n      } else {\n        clearFingerprintData();\n      }\n\n      // As an optimization - we want to show the first screen if it is possible\n      if (!showFirstScreenOnExecutionInit(startScreenId, ssoQueryParams)) {\n        const sdkResp = await this.sdk.flow.start(\n          flowId,\n          {\n            tenant,\n            redirectAuth,\n            ...ssoQueryParams,\n            client: this.client,\n            ...(redirectUrl && { redirectUrl }),\n            lastAuth: getLastAuth(loginId),\n            abTestingKey,\n            locale: getUserLocale(locale).locale,\n            nativeOptions,\n            outboundAppId,\n            outboundAppScopes,\n          },\n          conditionInteractionId,\n          '',\n          projectConfig.componentsVersion,\n          flowVersions,\n          {\n            ...this.formConfigValues,\n            ...(code ? { exchangeCode: code, idpInitiated: true } : {}),\n            ...(ssoQueryParams.descopeIdpInitiated && { idpInitiated: true }),\n            ...(token ? { token } : {}),\n            ...(ssoQueryParams.oidcLoginHint\n              ? { externalId: ssoQueryParams.oidcLoginHint }\n              : {}),\n          },\n        );\n\n        this.#handleSdkResponse(sdkResp);\n        if (sdkResp?.data?.status !== 'completed') {\n          this.flowState.update({ code: undefined, token: undefined });\n        }\n        return;\n      }\n    }\n\n    this.loggerWrapper.debug(\n      'Before popup postmessage send',\n      JSON.stringify({\n        isPopup,\n        code,\n        exchangeError,\n        isCodeChanged: isChanged('code'),\n        isExchangeErrorChanged: isChanged('exchangeError'),\n      }),\n    );\n    if (\n      isPopup &&\n      ((isChanged('code') && code) ||\n        (isChanged('exchangeError') && exchangeError))\n    ) {\n      this.loggerWrapper.debug('Creating popup channel', executionId);\n      const channel = new BroadcastChannel(executionId);\n      this.loggerWrapper.debug(\n        'Posting message to popup channel',\n        JSON.stringify({ code, exchangeError }),\n      );\n      channel.postMessage({\n        data: { code, exchangeError },\n        action: 'code',\n      });\n      this.loggerWrapper.debug('Popup channel message posted, closing channel');\n      channel.close();\n      this.loggerWrapper.debug('Popup channel closed, closing window');\n      window.close();\n      return;\n    }\n\n    // if there is a descope url param on the url its because the user clicked on email link or redirected back to the app\n    // we should call next with the params\n    if (\n      executionId &&\n      ((isChanged('token') && token) ||\n        (isChanged('code') && code) ||\n        (isChanged('exchangeError') && exchangeError))\n    ) {\n      const sdkResp = await this.sdk.flow.next(\n        executionId,\n        stepId,\n        CUSTOM_INTERACTIONS.submit,\n        flowConfig.version,\n        projectConfig.componentsVersion,\n        {\n          token,\n          exchangeCode: code,\n          exchangeError,\n        },\n      );\n      this.#handleSdkResponse(sdkResp);\n      this.flowState.update({\n        token: undefined,\n        code: undefined,\n        exchangeError: undefined,\n      }); // should happen after handleSdkResponse, otherwise we will not have screen id on the next run\n      return;\n    }\n\n    const samlProps = [\n      'samlIdpResponseUrl',\n      'samlIdpResponseSamlResponse',\n      'samlIdpResponseRelayState',\n    ];\n    if (\n      action === RESPONSE_ACTIONS.loadForm &&\n      samlProps.some((samlProp) => isChanged(samlProp))\n    ) {\n      if (!samlIdpResponseUrl || !samlIdpResponseSamlResponse) {\n        this.loggerWrapper.error('Did not get saml idp params data to load');\n        return;\n      }\n\n      // Handle SAML IDP end of flow (\"redirect like\" by using html form with hidden params)\n      injectSamlIdpForm(\n        samlIdpResponseUrl,\n        samlIdpResponseSamlResponse,\n        samlIdpResponseRelayState || '',\n        submitForm,\n      ); // will redirect us to the saml acs url\n    }\n\n    if (\n      action === RESPONSE_ACTIONS.redirect &&\n      (isChanged('redirectTo') || isChanged('deferredRedirect'))\n    ) {\n      if (!redirectTo) {\n        this.loggerWrapper.error('Did not get redirect url');\n        return;\n      }\n      if (redirectAuthInitiator === 'android' && document.hidden) {\n        // on android native flows, defer redirects until in foreground\n        this.flowState.update({\n          deferredRedirect: true,\n        });\n        return;\n      }\n\n      this.loggerWrapper.debug(`Redirect is popup ${redirectIsPopup}`);\n      if (redirectIsPopup) {\n        // this width is below the breakpoint of most providers\n        this.loggerWrapper.debug('Opening redirect in popup');\n        const popup = openCenteredPopup(redirectTo, '?', 598, 700);\n\n        this.loggerWrapper.debug('Creating broadcast channel');\n        const channel = new BroadcastChannel(executionId);\n\n        this.loggerWrapper.debug('Starting popup closed detection');\n        // detect when the popup is closed\n        const intervalId = setInterval(() => {\n          if (popup.closed) {\n            this.loggerWrapper.debug(\n              'Popup closed, dispatching popupclosed event and clearing interval',\n            );\n            clearInterval(intervalId);\n\n            // we are dispatching a popupclosed event so we can handle it on other parts of the code (loading state management)\n            this.#dispatch('popupclosed', {});\n\n            this.loggerWrapper.debug('Closing channel');\n            channel.close();\n          }\n        }, 1000);\n\n        this.loggerWrapper.debug('Listening for postMessage on channel');\n        const onPostMessage = (event: MessageEvent) => {\n          this.loggerWrapper.debug(\n            'Received postMessage on channel',\n            JSON.stringify(event),\n          );\n          this.loggerWrapper.debug(\n            'Comparing origins',\n            JSON.stringify({\n              eventOrigin: event.origin,\n              windowLocationOrigin: window.location.origin,\n            }),\n          );\n          if (event.origin !== window.location.origin) return;\n\n          this.loggerWrapper.debug(\n            'PostMessage origin matches, processing message',\n          );\n          // eslint-disable-next-line @typescript-eslint/no-shadow\n          const { action, data } = event.data;\n          this.loggerWrapper.debug(\n            `PostMessage action: ${action}, data: ${JSON.stringify(data)}`,\n          );\n          if (action === 'code') {\n            this.loggerWrapper.debug(\n              'Updating flow state with code and exchangeError',\n            );\n            this.flowState.update({\n              code: data.code,\n              exchangeError: data.exchangeError,\n            });\n          }\n        };\n\n        channel.onmessage = onPostMessage;\n      } else {\n        this.handleRedirect(redirectTo);\n      }\n      return;\n    }\n\n    if (\n      action === RESPONSE_ACTIONS.webauthnCreate ||\n      action === RESPONSE_ACTIONS.webauthnGet\n    ) {\n      if (!webauthnTransactionId || !webauthnOptions) {\n        this.loggerWrapper.error(\n          'Did not get webauthn transaction id or options',\n        );\n        return;\n      }\n\n      this.#conditionalUiAbortController?.abort();\n      this.#conditionalUiAbortController = null;\n\n      let response: string;\n      let failure: string;\n\n      try {\n        response =\n          action === RESPONSE_ACTIONS.webauthnCreate\n            ? await this.sdk.webauthn.helpers.create(webauthnOptions)\n            : await this.sdk.webauthn.helpers.get(webauthnOptions);\n      } catch (e) {\n        if (e.name === 'InvalidStateError') {\n          // currently returned in Chrome when trying to register a WebAuthn device\n          // that's already registered for the user\n          this.loggerWrapper.warn('WebAuthn operation failed', e.message);\n        } else if (e.name !== 'NotAllowedError') {\n          // shouldn't happen in normal usage ('AbortError' is only when setting an AbortController)\n          this.loggerWrapper.error(e.message);\n        }\n        failure = e.name;\n      }\n      // Call next with the transactionId and the response or failure\n      const sdkResp = await this.sdk.flow.next(\n        executionId,\n        stepId,\n        CUSTOM_INTERACTIONS.submit,\n        flowConfig.version,\n        projectConfig.componentsVersion,\n        {\n          transactionId: webauthnTransactionId,\n          response,\n          failure,\n        },\n      );\n      this.#handleSdkResponse(sdkResp);\n    }\n\n    if (action === RESPONSE_ACTIONS.nativeBridge) {\n      // prepare a callback with the current flow state, and accept\n      // the input to be a JSON, passed down from the native layer.\n      // this function will be called as an async response to a 'bridge' event\n      this.nativeCallbacks.complete = async (input: Record<string, any>) => {\n        const sdkResp = await this.sdk.flow.next(\n          executionId,\n          stepId,\n          CUSTOM_INTERACTIONS.submit,\n          flowConfig.version,\n          projectConfig.componentsVersion,\n          input,\n        );\n        this.#handleSdkResponse(sdkResp);\n      };\n      // notify the bridging native layer that a native action is requested via 'bridge' event.\n      // the response will be in the form of calling the 'nativeCallbacks.complete' callback via\n      // the 'nativeResume' function.\n      this.#nativeNotifyBridge(nativeResponseType, nativePayload);\n      return;\n    }\n\n    if (isChanged('action')) {\n      this.#handlePollingResponse(\n        executionId,\n        stepId,\n        flowConfig.version,\n        projectConfig.componentsVersion,\n      );\n    }\n\n    // if there is no screen id (possibly due to page refresh or no screen flow) we should get it from the server\n    if (!screenId && !startScreenId) {\n      this.loggerWrapper.warn('No screen was found to show');\n      return;\n    }\n\n    const readyScreenId = startScreenId || screenId;\n\n    // get the right filename according to the user locale and flow target locales\n    const filenameWithLocale: string = await this.getHtmlFilenameWithLocale(\n      locale,\n      readyScreenId,\n    );\n\n    const {\n      oidcLoginHint,\n      oidcPrompt,\n      oidcErrorRedirectUri,\n      oidcResource,\n      samlIdpUsername,\n    } = ssoQueryParams;\n\n    // generate step state update data\n    const stepStateUpdate: Partial<StepState> = {\n      direction: getAnimationDirection(stepId, prevState.stepId),\n      screenState: {\n        ...screenState,\n        form: {\n          ...this.formConfigValues,\n          ...screenState?.form,\n        },\n        lastAuth: {\n          loginId,\n          name: this.sdk.getLastUserDisplayName() || loginId,\n        },\n        componentsConfig: {\n          ...flowConfig.componentsConfig,\n          ...conditionComponentsConfig,\n          ...screenState?.componentsConfig,\n        },\n      },\n      htmlFilename: `${readyScreenId}.html`,\n      htmlLocaleFilename: filenameWithLocale,\n      screenId: readyScreenId,\n      stepName: currentState.stepName || startScreenName,\n      samlIdpUsername,\n      oidcLoginHint,\n      oidcPrompt,\n      oidcErrorRedirectUri,\n      oidcResource,\n      action,\n    };\n\n    const lastAuth = getLastAuth(loginId);\n\n    // If there is a start screen id, next action should start the flow\n    // But if any of the sso params are not empty, this optimization doesn't happen\n    // because Descope may decide not to show the first screen (in cases like a user is already logged in) - this is more relevant for SSO scenarios\n    if (showFirstScreenOnExecutionInit(startScreenId, ssoQueryParams)) {\n      stepStateUpdate.next = async (interactionId, inputs) => {\n        const res = await this.sdk.flow.start(\n          flowId,\n          {\n            tenant,\n            redirectAuth,\n            ...ssoQueryParams,\n            lastAuth,\n            preview: this.preview,\n            abTestingKey,\n            client: this.client,\n            ...(redirectUrl && { redirectUrl }),\n            locale: getUserLocale(locale).locale,\n            nativeOptions,\n            outboundAppId,\n            outboundAppScopes,\n          },\n          conditionInteractionId,\n          interactionId,\n          projectConfig.componentsVersion,\n          flowVersions,\n          {\n            ...this.formConfigValues,\n            ...transformScreenInputs(inputs),\n            ...(code && { exchangeCode: code, idpInitiated: true }),\n            ...(ssoQueryParams.descopeIdpInitiated && { idpInitiated: true }),\n            ...(token && { token }),\n          },\n        );\n\n        this.#handleSdkResponse(res);\n\n        return res;\n      };\n    } else if (\n      isChanged('projectId') ||\n      isChanged('baseUrl') ||\n      isChanged('executionId') ||\n      isChanged('stepId')\n    ) {\n      stepStateUpdate.next = async (interactionId, input) => {\n        const res = await this.sdk.flow.next(\n          executionId,\n          stepId,\n          interactionId,\n          flowConfig.version,\n          projectConfig.componentsVersion,\n          transformScreenInputs(input),\n        );\n\n        this.#handleSdkResponse(res);\n\n        return res;\n      };\n    }\n\n    this.loggerWrapper.debug('Got a screen with id', stepStateUpdate.screenId);\n\n    await this.#handleCustomScreen(stepStateUpdate);\n\n    // update step state\n    this.stepState.update(stepStateUpdate);\n  }\n\n  // this function is used to handle redirects in the web component\n  // it can be overridden by the user to handle redirects in a custom way\n  // eslint-disable-next-line class-methods-use-this\n  handleRedirect = (redirectTo: string) => {\n    window.location.assign(redirectTo);\n  };\n\n  #toggleScreenVisibility = (isCustomScreen: boolean) => {\n    const toggleVisibility = () => {\n      this.contentRootElement.classList.toggle('hidden', isCustomScreen);\n      this.slotElement.classList.toggle('hidden', !isCustomScreen);\n      if (isCustomScreen) {\n        this.contentRootElement.innerHTML = '';\n      }\n    };\n\n    if (isCustomScreen && this.contentRootElement.hasChildNodes()) {\n      this.#handlePageSwitchTransition(toggleVisibility);\n    } else {\n      toggleVisibility();\n    }\n  };\n\n  #handlePageSwitchTransition(onTransitionEnd: () => void) {\n    const transitionEndHandler = () => {\n      this.loggerWrapper.debug('page switch transition end');\n      this.contentRootElement.classList.remove('fade-out');\n      onTransitionEnd();\n    };\n    this.contentRootElement.addEventListener(\n      'transitionend',\n      transitionEndHandler,\n      { once: true },\n    );\n    this.loggerWrapper.debug('page switch transition start');\n    this.contentRootElement.classList.add('fade-out');\n  }\n\n  #handlePollingResponse = (\n    executionId: string,\n    stepId: string,\n    flowVersion: number,\n    componentsVersion: string,\n    rescheduled: boolean = false,\n  ) => {\n    const pollingDefaultDelay = 2000;\n    const pollingDefaultTimeout = 6000;\n    const pollingThrottleDelay = 500;\n    const pollingThrottleThreshold = 500;\n    const pollingThrottleTimeout = 1000;\n    const stopOnErrors = [\n      FLOW_TIMED_OUT_ERROR_CODE,\n      POLLING_STATUS_NOT_FOUND_ERROR_CODE,\n    ];\n\n    if (this.flowState.current.action === RESPONSE_ACTIONS.poll) {\n      // schedule next polling request for 2 seconds from now\n      this.logger.debug('polling - Scheduling polling request');\n      const scheduledAt = Date.now();\n      const delay = rescheduled ? pollingThrottleDelay : pollingDefaultDelay;\n      this.#pollingTimeout = setTimeout(async () => {\n        this.logger.debug('polling - Calling next');\n\n        const nextCall = this.sdk.flow.next(\n          executionId,\n          stepId,\n          CUSTOM_INTERACTIONS.polling,\n          flowVersion,\n          componentsVersion,\n          {},\n        );\n\n        // Try to detect whether the tab is being throttled when running in a mobile browser, specifically on iOS.\n        // We check whether the tab seems to hidden and the polling callback was called much later than expected,\n        // in which case we allow a much shorter timeout for the polling request. The reschedule check ensures\n        // this cannot happen twice consecutively.\n        const throttled =\n          document.hidden &&\n          !rescheduled &&\n          Date.now() - scheduledAt > delay + pollingThrottleThreshold;\n        if (throttled) {\n          this.logger.debug('polling - The polling seems to be throttled');\n        }\n\n        let sdkResp: Awaited<typeof nextCall>;\n        try {\n          const timeout = throttled\n            ? pollingThrottleTimeout\n            : pollingDefaultTimeout;\n          sdkResp = await timeoutPromise(timeout, nextCall);\n        } catch (err) {\n          this.logger.warn(\n            `polling - The ${\n              throttled ? 'throttled fetch' : 'fetch'\n            } call timed out or was aborted`,\n          );\n          this.#handlePollingResponse(\n            executionId,\n            stepId,\n            flowVersion,\n            componentsVersion,\n            throttled,\n          );\n          return;\n        }\n\n        if (sdkResp?.error?.errorCode === FETCH_EXCEPTION_ERROR_CODE) {\n          this.logger.debug(\n            'polling - Got a generic error due to exception in fetch call',\n          );\n          this.#handlePollingResponse(\n            executionId,\n            stepId,\n            flowVersion,\n            componentsVersion,\n          );\n          return;\n        }\n\n        this.logger.debug('polling - Got a response');\n        if (sdkResp?.error) {\n          this.logger.debug(\n            'polling - Response has an error',\n            JSON.stringify(sdkResp.error, null, 4),\n          );\n        }\n\n        // we want to stop polling for some errors\n        if (\n          !sdkResp?.error?.errorCode ||\n          !stopOnErrors.includes(sdkResp.error.errorCode)\n        ) {\n          // will poll again if needed\n          // handleSdkResponse will clear the timeout if the response action is not polling response\n          this.#handlePollingResponse(\n            executionId,\n            stepId,\n            flowVersion,\n            componentsVersion,\n          );\n        } else {\n          this.logger.debug('polling - Stopping polling due to error');\n        }\n\n        this.#handleSdkResponse(sdkResp);\n      }, delay);\n    }\n  };\n\n  #resetPollingTimeout = () => {\n    clearTimeout(this.#pollingTimeout);\n    this.#pollingTimeout = null;\n  };\n\n  #handleSdkResponse = (sdkResp: NextFnReturnPromiseValue) => {\n    if (!sdkResp?.ok) {\n      const defaultMessage = sdkResp?.response?.url;\n      const defaultDescription = `${sdkResp?.response?.status} - ${sdkResp?.response?.statusText}`;\n\n      this.#dispatch(\n        'error',\n        sdkResp?.error || {\n          errorCode: FETCH_ERROR_RESPONSE_ERROR_CODE,\n          errorDescription: defaultDescription,\n          errorMessage: defaultMessage,\n        },\n      );\n\n      this.loggerWrapper.error(\n        sdkResp?.error?.errorDescription || defaultMessage,\n        sdkResp?.error?.errorMessage || defaultDescription,\n      );\n\n      const errorCode = sdkResp?.error?.errorCode;\n      if (\n        (errorCode === FLOW_REQUESTED_IS_IN_OLD_VERSION_ERROR_CODE ||\n          errorCode === FLOW_TIMED_OUT_ERROR_CODE) &&\n        this.isRestartOnError\n      ) {\n        this.#handleFlowRestart();\n      }\n      return;\n    }\n\n    sdkResp.data?.runnerLogs?.forEach((l) => {\n      const { level, title, log } = l;\n      if (level && this.loggerWrapper[level]) {\n        this.loggerWrapper[level](title, log);\n      } else {\n        this.loggerWrapper.info(title, log);\n      }\n    });\n    const errorText = sdkResp.data?.screen?.state?.errorText;\n    if (sdkResp.data?.error) {\n      this.loggerWrapper.error(\n        `[${sdkResp.data.error.code}]: ${sdkResp.data.error.description}`,\n        `${errorText ? `${errorText} - ` : ''}${sdkResp.data.error.message}`,\n      );\n    } else if (errorText) {\n      this.loggerWrapper.error(errorText);\n    }\n\n    const { status, authInfo, lastAuth, action, openInNewTabUrl } =\n      sdkResp.data;\n\n    if (action !== RESPONSE_ACTIONS.poll) {\n      this.#resetPollingTimeout();\n    }\n\n    if (status === 'completed') {\n      if (this.storeLastAuthenticatedUser) {\n        setLastAuth(lastAuth);\n      }\n      this.#dispatch('success', authInfo);\n      return;\n    } else {\n      if (this.storeLastAuthenticatedUser) {\n        setLastAuth(lastAuth, true);\n      }\n    }\n\n    if (openInNewTabUrl) {\n      window.open(openInNewTabUrl, '_blank');\n      // we should not return here so the screen will be rendered\n    }\n\n    const {\n      executionId,\n      stepId,\n      stepName,\n      screen,\n      redirect,\n      webauthn,\n      error,\n      samlIdpResponse,\n      nativeResponse,\n    } = sdkResp.data;\n\n    // this is used as a cache buster\n    // we want to make sure the onScreenUpdate will be called after every next call even if the state was not changed\n    const reqTimestamp = Date.now();\n\n    if (action === RESPONSE_ACTIONS.poll) {\n      // We only update action because the polling response action does not return extra information\n      this.flowState.update({\n        action,\n        reqTimestamp,\n      });\n      return;\n    }\n\n    this.loggerWrapper.info(\n      `Step \"${stepName || `#${stepId}`}\" is ${status}`,\n      '',\n      {\n        screen,\n        status,\n        stepId,\n        stepName,\n        action,\n        error,\n      },\n    );\n\n    if (screen.state?.clientScripts) {\n      this.#sdkScriptsLoading = this.loadSdkScripts(screen.state.clientScripts);\n    }\n\n    this.flowState.update({\n      stepId,\n      stepName,\n      executionId,\n      action,\n      redirectTo: redirect?.url,\n      redirectIsPopup: redirect?.isPopup,\n      screenId: screen?.id,\n      screenState: screen?.state,\n      webauthnTransactionId: webauthn?.transactionId,\n      webauthnOptions: webauthn?.options,\n      samlIdpResponseUrl: samlIdpResponse?.url,\n      samlIdpResponseSamlResponse: samlIdpResponse?.samlResponse,\n      samlIdpResponseRelayState: samlIdpResponse?.relayState,\n      nativeResponseType: nativeResponse?.type,\n      nativePayload: nativeResponse?.payload,\n      reqTimestamp,\n    });\n  };\n\n  // we want to get the start params only if we don't have it already\n  #getWebauthnConditionalUiStartParams = withMemCache(async () => {\n    try {\n      const startResp = await this.sdk.webauthn.signIn.start(\n        '',\n        window.location.origin,\n      ); // when using conditional UI we need to call start without identifier\n      if (!startResp.ok) {\n        this.loggerWrapper.warn(\n          'Webauthn start failed',\n          startResp?.error?.errorMessage,\n        );\n      }\n      return startResp.data;\n    } catch (err) {\n      this.loggerWrapper.warn('Webauthn start failed', err.message);\n    }\n\n    return undefined;\n  });\n\n  /**\n   * this is needed because Conditional UI does not work on all input names\n   * we need to add a prefix to the input name so it will trigger the autocomplete dialog\n   * but we want to remove it once the user starts typing because we want this field to be sent to the server with the correct name\n   */\n\n  // eslint-disable-next-line class-methods-use-this\n  #handleConditionalUiInput(inputEle: HTMLInputElement) {\n    const ignoreList = ['email'];\n    const origName = inputEle.getAttribute('name');\n\n    if (!ignoreList.includes(origName)) {\n      const conditionalUiSupportName = `user-${origName}`;\n\n      // eslint-disable-next-line no-param-reassign\n      inputEle.setAttribute('name', conditionalUiSupportName);\n\n      inputEle.addEventListener('input', () => {\n        // eslint-disable-next-line no-param-reassign\n        inputEle.setAttribute(\n          'name',\n          inputEle.value ? origName : conditionalUiSupportName,\n        );\n      });\n    }\n  }\n\n  async #handleWebauthnConditionalUi(fragment: DocumentFragment, next: NextFn) {\n    this.#conditionalUiAbortController?.abort();\n\n    const conditionalUiInput = fragment.querySelector(\n      '*[autocomplete=\"webauthn\"]',\n    ) as HTMLInputElement;\n\n    if (conditionalUiInput && (await isConditionalLoginSupported())) {\n      const { options, transactionId } =\n        (await this.#getWebauthnConditionalUiStartParams()) || {};\n\n      if (options && transactionId) {\n        this.#handleConditionalUiInput(conditionalUiInput);\n\n        // we need the abort controller so we can cancel the current webauthn session in case the user clicked on a webauthn button, and we need to start a new session\n        this.#conditionalUiAbortController = new AbortController();\n\n        // we should not wait for this fn, it will call next when the user uses his passkey on the input\n        this.sdk.webauthn.helpers\n          .conditional(options, this.#conditionalUiAbortController)\n          .then(async (response) => {\n            next(conditionalUiInput.id, {\n              transactionId,\n              response,\n            });\n          })\n          .catch((err) => {\n            if (err.name !== 'AbortError') {\n              this.loggerWrapper.error('Conditional login failed', err.message);\n            }\n          });\n      }\n    }\n  }\n\n  #dispatchPageEvents({\n    isFirstScreen,\n    isCustomScreen,\n    stepName,\n  }: {\n    isFirstScreen: boolean;\n    isCustomScreen: boolean;\n    stepName: string;\n  }) {\n    if (isFirstScreen) {\n      // Dispatch when the first page is ready\n      // So user can show a loader until his event is triggered\n      this.#dispatch('ready', {});\n    }\n\n    if (!isCustomScreen) {\n      this.#nativeAfterScreen(stepName);\n    }\n\n    this.#dispatch('page-updated', { screenName: stepName });\n    this.#dispatch('screen-updated', { screenName: stepName });\n  }\n\n  async onStepChange(currentState: StepState, prevState: StepState) {\n    const { htmlFilename, htmlLocaleFilename, direction, next, screenState } =\n      currentState;\n\n    this.loggerWrapper.debug('Rendering a flow screen');\n\n    const stepTemplate = document.createElement('template');\n    stepTemplate.innerHTML = await this.getPageContent(\n      htmlFilename,\n      htmlLocaleFilename,\n    );\n\n    const clone = stepTemplate.content.cloneNode(true) as DocumentFragment;\n\n    const loadDescopeUiComponents = this.loadDescopeUiComponents(stepTemplate);\n\n    // we want to disable the webauthn buttons if it's not supported on the browser\n    if (!this.sdk.webauthn.helpers.isSupported()) {\n      disableWebauthnButtons(clone);\n    } else {\n      await this.#handleWebauthnConditionalUi(clone, next);\n    }\n\n    if (\n      currentState.samlIdpUsername &&\n      !screenState.form?.loginId &&\n      !screenState.form?.email\n    ) {\n      if (!screenState.form) {\n        screenState.form = {};\n      }\n      screenState.form.loginId = currentState.samlIdpUsername;\n      screenState.form.email = currentState.samlIdpUsername;\n    }\n\n    updateTemplateFromScreenState(\n      clone,\n      screenState,\n      screenState.componentsConfig,\n      this.formConfig,\n      this.loggerWrapper,\n    );\n\n    // set the default country code based on the locale value we got\n    const { geo } = await this.getExecutionContext();\n    setPhoneAutoDetectDefaultCode(clone, geo);\n\n    const injectNextPage = async () => {\n      await loadDescopeUiComponents;\n\n      // put the totp and notp variable on the root element, which is the top level 'div' inside the shadowRoot\n      const rootElement = this.contentRootElement;\n      setTOTPVariable(rootElement, screenState?.totp?.image);\n\n      setNOTPVariable(rootElement, screenState?.notp?.image);\n\n      // set dynamic css variables that should be set at runtime\n      setCssVars(rootElement, clone, screenState.cssVars, this.loggerWrapper);\n\n      rootElement.replaceChildren(clone);\n\n      // If before html url was empty, we deduce its the first time a screen is shown\n      const isFirstScreen = !prevState.htmlFilename;\n\n      // we need to wait for all components to render before we can set its value\n      setTimeout(() => {\n        this.#updateExternalInputs();\n\n        if (this.validateOnBlur) {\n          handleReportValidityOnBlur(rootElement);\n        }\n\n        // we need to wait for all components to render before we can set its value\n        updateScreenFromScreenState(rootElement, screenState);\n\n        this.#dispatchPageEvents({\n          isFirstScreen,\n          isCustomScreen: false,\n          stepName: currentState.stepName,\n        });\n\n        handleAutoFocus(rootElement, this.autoFocus, isFirstScreen);\n      });\n\n      this.#hydrate(next);\n\n      const loader = rootElement.querySelector(\n        `[${ELEMENT_TYPE_ATTRIBUTE}=\"polling\"]`,\n      );\n      if (loader) {\n        // Loader component in the screen triggers polling interaction\n        next(CUSTOM_INTERACTIONS.polling, {});\n      }\n    };\n\n    // no animation\n    if (!direction) {\n      injectNextPage();\n      return;\n    }\n\n    this.#handlePageSwitchTransition(injectNextPage);\n  }\n\n  #validateInputs() {\n    let isValid = true;\n    Array.from(this.shadowRoot.querySelectorAll('*[name]'))\n      .reverse()\n      .forEach((input: HTMLInputElement) => {\n        if (input.localName === 'slot') {\n          return;\n        }\n        input.reportValidity?.();\n        if (isValid) {\n          isValid = input.checkValidity?.();\n        }\n      });\n\n    return isValid;\n  }\n\n  getInputs() {\n    return Array.from(\n      this.shadowRoot.querySelectorAll(\n        `*:not(slot)[name]:not([${DESCOPE_ATTRIBUTE_EXCLUDE_FIELD}])`,\n      ),\n    ) as HTMLInputElement[];\n  }\n\n  async #getFormData() {\n    const inputs = this.getInputs();\n\n    // wait for all inputs\n    const values = await Promise.all(\n      inputs.map(async (input) => ({\n        name: input.getAttribute('name'),\n        value: input.value,\n      })),\n    );\n\n    // reduce to object\n    return values.reduce(\n      (acc, val) => ({\n        ...acc,\n        [val.name]: val.value,\n      }),\n      {},\n    );\n  }\n\n  #prevPageShowListener: ((e: PageTransitionEvent) => void) | null = null;\n\n  #handleComponentsLoadingState(submitter: HTMLElement) {\n    const enabledElements = Array.from(\n      this.contentRootElement.querySelectorAll(\n        ':not([disabled]), [disabled=\"false\"]',\n      ),\n    ).filter((ele) => ele !== submitter);\n\n    const restoreComponentsState = async () => {\n      this.loggerWrapper.debug('Restoring components state');\n      this.removeEventListener('popupclosed', restoreComponentsState);\n      submitter.removeAttribute('loading');\n      enabledElements.forEach((ele) => {\n        ele.removeAttribute('disabled');\n      });\n      // if there are client scripts, we want to reload them\n      const flowConfig = await this.getFlowConfig();\n      const clientScripts = [\n        ...(flowConfig.clientScripts || []),\n        ...(flowConfig.sdkScripts || []),\n      ];\n      this.loadSdkScripts(clientScripts);\n    };\n\n    const handleScreenIdUpdates = () => {\n      // we want to remove the previous pageshow listener to avoid multiple listeners\n      window.removeEventListener('pageshow', this.#prevPageShowListener);\n\n      this.#prevPageShowListener = (e) => {\n        if (e.persisted) {\n          this.logger.debug(\n            'Page was loaded from cache, restoring components state',\n          );\n          restoreComponentsState();\n        }\n      };\n      // we want to restore the components state when the page is shown from cache\n      window.addEventListener('pageshow', this.#prevPageShowListener, {\n        once: true,\n      });\n\n      // we want to restore the components state when the screenId is updated\n      const unsubscribeScreenIdUpdates = this.stepState?.subscribe(\n        (screenId, prevScreenId) => {\n          // we want to restore components state only if we stay on the same screen\n          // if we are rendering a new screen, the components state (disabled/loading) will remain until the new screen is rendered\n          if (screenId === prevScreenId) {\n            restoreComponentsState();\n          }\n          this.removeEventListener('popupclosed', restoreComponentsState);\n          this.stepState.unsubscribe(unsubscribeScreenIdUpdates);\n        },\n        (state) => state.screenId,\n        { forceUpdate: true },\n      );\n    };\n\n    // we are listening to the next request status\n    const unsubscribeNextRequestStatus = this.nextRequestStatus.subscribe(\n      ({ isLoading }) => {\n        if (isLoading) {\n          this.addEventListener('popupclosed', restoreComponentsState, {\n            once: true,\n          });\n          // if the next request is loading, we want to set loading state on the submitter, and disable all other enabled elements\n          submitter.setAttribute('loading', 'true');\n          enabledElements.forEach((ele) =>\n            ele.setAttribute('disabled', 'true'),\n          );\n        } else {\n          this.nextRequestStatus.unsubscribe(unsubscribeNextRequestStatus);\n          // when next request is done, we want to listen to screenId updates\n          handleScreenIdUpdates();\n        }\n      },\n    );\n  }\n\n  // handle storing passwords in password managers\n  #handleStoreCredentials(formData = {}) {\n    const idFields = ['externalId', 'email', 'phone'];\n    const passwordFields = ['newPassword', 'password'];\n\n    const id = getFirstNonEmptyValue(formData, idFields);\n    const password = getFirstNonEmptyValue(formData, passwordFields);\n\n    // PasswordCredential not supported in Firefox\n    if (id && password) {\n      try {\n        if (!globalThis.PasswordCredential) {\n          return;\n        }\n        const cred = new globalThis.PasswordCredential({ id, password });\n\n        navigator?.credentials?.store?.(cred);\n      } catch (e) {\n        this.loggerWrapper.error('Could not store credentials', e.message);\n      }\n    }\n  }\n\n  #updateExternalInputs() {\n    // we need to clear external inputs that were created previously, so each screen has only\n    // the slotted inputs it needs\n    clearPreviousExternalInputs();\n\n    const eles = this.contentRootElement.querySelectorAll(\n      '[external-input=\"true\"]',\n    );\n    eles.forEach((ele) => this.#handleExternalInputs(ele));\n  }\n\n  #handleExternalInputs(ele: Element) {\n    if (!ele) {\n      return;\n    }\n\n    const origInputs = ele.querySelectorAll('input');\n\n    origInputs.forEach((inp) => {\n      const targetSlot = inp.getAttribute('slot');\n      const id = `input-${ele.id}-${targetSlot}`;\n\n      const slot = document.createElement('slot');\n      slot.setAttribute('name', id);\n      slot.setAttribute('slot', targetSlot);\n\n      ele.appendChild(slot);\n\n      inp.setAttribute('slot', id);\n      this.appendChild(inp);\n    });\n  }\n\n  // we are wrapping this function with a leading debounce,\n  // to prevent a scenario where we are calling it multiple times\n  // this can caused by focusing on a button and pressing enter\n  // in this case, the button will be clicked, but because we have the auto-submit mechanism\n  // it will submit the form once again and we will end up with 2 identical calls for next\n  #handleSubmit = leadingDebounce(\n    async (submitter: HTMLElement, next: NextFn) => {\n      if (\n        submitter.getAttribute('formnovalidate') === 'true' ||\n        this.#validateInputs()\n      ) {\n        const submitterId = submitter?.getAttribute('id');\n        this.#handleComponentsLoadingState(submitter);\n\n        const formData = await this.#getFormData();\n        const eleDescopeAttrs = getElementDescopeAttributes(submitter);\n\n        this.nextRequestStatus.update({ isLoading: true });\n\n        if (this.#sdkScriptsLoading) {\n          this.loggerWrapper.debug('Waiting for sdk scripts to load');\n          const now = Date.now();\n          await this.#sdkScriptsLoading;\n          this.loggerWrapper.debug(\n            'Sdk scripts loaded for',\n            (Date.now() - now).toString(),\n          );\n        }\n\n        // Get all script modules and refresh them before form submission\n        const sdkScriptsModules = this.loadSdkScriptsModules();\n\n        if (sdkScriptsModules.length > 0) {\n          // Only attempt to refresh modules that actually have a refresh function\n          const refreshPromises = sdkScriptsModules\n            .filter((module) => typeof module.refresh === 'function')\n            .map((module) => module.refresh!());\n\n          if (refreshPromises.length > 0) {\n            // Use timeout to prevent hanging if refresh takes too long\n            await timeoutPromise(\n              SDK_SCRIPTS_LOAD_TIMEOUT,\n              Promise.all(refreshPromises),\n              null,\n            );\n          }\n        }\n\n        const contextArgs = this.getComponentsContext();\n\n        const actionArgs = {\n          ...contextArgs,\n          ...eleDescopeAttrs,\n          ...formData,\n          // 'origin' is required to start webauthn. For now we'll add it to every request.\n          // When running in a native flow in a Android app the webauthn authentication\n          // is performed in the native app, so a custom origin needs to be injected\n          // into the webauthn request data.\n          origin: this.nativeOptions?.origin || window.location.origin,\n        };\n\n        await next(submitterId, actionArgs);\n\n        this.nextRequestStatus.update({ isLoading: false });\n\n        this.#handleStoreCredentials(formData);\n      }\n    },\n  );\n\n  #addPasscodeAutoSubmitListeners(next: NextFn) {\n    this.contentRootElement\n      .querySelectorAll(`descope-passcode[data-auto-submit=\"true\"]`)\n      .forEach((passcode: HTMLInputElement) => {\n        passcode.addEventListener('input', () => {\n          const isValid = passcode.checkValidity?.();\n          if (isValid) {\n            this.#handleSubmit(passcode, next);\n          }\n        });\n      });\n  }\n\n  #hydrate(next: NextFn) {\n    // hydrating the page\n    // Adding event listeners to all buttons without the exclude attribute\n    this.contentRootElement\n      .querySelectorAll(\n        `descope-button:not([${DESCOPE_ATTRIBUTE_EXCLUDE_NEXT_BUTTON}]), [data-type=\"button\"]:not([${DESCOPE_ATTRIBUTE_EXCLUDE_NEXT_BUTTON}]`,\n      )\n      .forEach((button: HTMLButtonElement) => {\n        // eslint-disable-next-line no-param-reassign\n        button.onclick = () => {\n          this.#handleSubmit(button, next);\n        };\n      });\n\n    this.#addPasscodeAutoSubmitListeners(next);\n\n    if (this.isDismissScreenErrorOnInput) {\n      // listen to all input events in order to clear the global error state\n      this.contentRootElement\n        .querySelectorAll(`*[name]:not([${DESCOPE_ATTRIBUTE_EXCLUDE_FIELD}])`)\n        .forEach((ele) => {\n          ele.addEventListener('input', () => {\n            this.stepState.update((state) => ({\n              ...state,\n              screenState: {\n                ...state.screenState,\n                errorText: '',\n                errorType: '',\n              },\n            }));\n          });\n        });\n    }\n  }\n\n  #dispatch(eventName: string, detail: any) {\n    this.dispatchEvent(new CustomEvent(eventName, { detail }));\n  }\n}\n\nexport default DescopeWc;\n"],"names":["document","hidden","setTimeout","this","flowState","update","deferredRedirect","_DescopeWc_nativeBeforeScreen","screen","context","next","_a","nativeOptions","bridgeVersion","Promise","resolve","nativeCallbacks","screenNext","screenResolve","__classPrivateFieldGet","_DescopeWc_instances","_DescopeWc_nativeNotifyBridge","call","type","payload","_DescopeWc_dispatch","_DescopeWc_handleGlobalErrors","errorText","errorType","updateGlobalError","transformedErrorText","errorTransformer","text","e","loggerWrapper","error","message","replaceElementMessage","contentRootElement","addEventListener","once","_DescopeWc_subscribeStepState","stepState","subscribe","onStepChange","bind","_b","screenState","_c","state","__rest","Object","assign","forceUpdate","_DescopeWc_handlePasscodeCleanup","querySelectorAll","forEach","passcodeEle","shadowRoot","input","value","handleAutoFocus","autoFocus","_DescopeWc_handleFlowRestart","debug","prevCompVersion","getComponentsVersion","reset","stepId","executionId","stepStateUpdate","current","stepName","transformStepStateForCustomScreen","isCustomScreen","Boolean","onScreenUpdate","isFirstScreen","htmlFilename","_DescopeWc_toggleScreenVisibility","_DescopeWc_isPrevCustomScreen","currentMode","prevMode","sort","__classPrivateFieldSet","unsubscribeAll","_DescopeWc_dispatchPageEvents","onTransitionEnd","classList","remove","add","inputEle","origName","getAttribute","includes","conditionalUiSupportName","setAttribute","_DescopeWc_handleWebauthnConditionalUi","fragment","_DescopeWc_conditionalUiAbortController","abort","conditionalUiInput","querySelector","isConditionalLoginSupported","options","transactionId","_DescopeWc_handleConditionalUiInput","AbortController","sdk","webauthn","helpers","conditional","then","response","__awaiter","id","catch","err","name","_DescopeWc_nativeAfterScreen","screenName","_DescopeWc_validateInputs","isValid","Array","from","reverse","localName","reportValidity","checkValidity","_DescopeWc_getFormData","inputs","getInputs","all","map","reduce","acc","val","submitter","enabledElements","filter","ele","restoreComponentsState","removeEventListener","removeAttribute","flowConfig","getFlowConfig","clientScripts","sdkScripts","loadSdkScripts","handleScreenIdUpdates","window","_DescopeWc_prevPageShowListener","persisted","logger","unsubscribeScreenIdUpdates","screenId","prevScreenId","unsubscribe","unsubscribeNextRequestStatus","nextRequestStatus","isLoading","_DescopeWc_handleStoreCredentials","formData","getFirstNonEmptyValue","password","globalThis","PasswordCredential","cred","navigator","credentials","store","_DescopeWc_updateExternalInputs","clearPreviousExternalInputs","inp","targetSlot","slot","createElement","appendChild","passcode","DESCOPE_ATTRIBUTE_EXCLUDE_NEXT_BUTTON","button","onclick","_DescopeWc_addPasscodeAutoSubmitListeners","isDismissScreenErrorOnInput","DESCOPE_ATTRIBUTE_EXCLUDE_FIELD","eventName","detail","dispatchEvent","CustomEvent","BaseDescopeWc","sdkConfigOverrides","config","constructor","State","super","_DescopeWc_pollingTimeout","set","_DescopeWc_sdkScriptsLoading","_DescopeWc_eventsCbRefs","visibilitychange","_DescopeWc_syncStateWithVisibility","handleRedirect","redirectTo","location","toggleVisibility","toggle","slotElement","innerHTML","hasChildNodes","_DescopeWc_handlePageSwitchTransition","_DescopeWc_handlePollingResponse","flowVersion","componentsVersion","rescheduled","stopOnErrors","FLOW_TIMED_OUT_ERROR_CODE","POLLING_STATUS_NOT_FOUND_ERROR_CODE","action","RESPONSE_ACTIONS","poll","scheduledAt","Date","now","delay","nextCall","flow","CUSTOM_INTERACTIONS","polling","throttled","sdkResp","timeout","timeoutPromise","warn","errorCode","FETCH_EXCEPTION_ERROR_CODE","JSON","stringify","_DescopeWc_handleSdkResponse","_DescopeWc_resetPollingTimeout","clearTimeout","ok","defaultMessage","url","defaultDescription","status","statusText","FETCH_ERROR_RESPONSE_ERROR_CODE","errorDescription","errorMessage","_d","_e","_f","FLOW_REQUESTED_IS_IN_OLD_VERSION_ERROR_CODE","isRestartOnError","_h","_g","data","runnerLogs","l","level","title","log","info","_l","_k","_j","_m","code","description","authInfo","lastAuth","openInNewTabUrl","storeLastAuthenticatedUser","setLastAuth","open","redirect","samlIdpResponse","nativeResponse","reqTimestamp","_o","redirectIsPopup","isPopup","webauthnTransactionId","webauthnOptions","samlIdpResponseUrl","samlIdpResponseSamlResponse","samlResponse","samlIdpResponseRelayState","relayState","nativeResponseType","nativePayload","_DescopeWc_getWebauthnConditionalUiStartParams","withMemCache","startResp","signIn","start","origin","_DescopeWc_handleSubmit","leadingDebounce","submitterId","_DescopeWc_handleComponentsLoadingState","eleDescopeAttrs","getElementDescopeAttributes","toString","sdkScriptsModules","loadSdkScriptsModules","length","refreshPromises","module","refresh","SDK_SCRIPTS_LOAD_TIMEOUT","contextArgs","getComponentsContext","actionArgs","nativeResume","parse","exchangeCode","URL","searchParams","get","URL_CODE_PARAM_NAME","complete","idpInitiated","token","URL_TOKEN_PARAM_NAME","URL_RUN_IDS_PARAM_NAME","split","pop","undefined","override","interactionId","form","scriptElements","el","moduleRes","scripts","createScriptCallback","script","result","getScriptResultPath","resultKey","bubbles","composed","s","join","promises","scriptElement","injectNpmLib","descope","reject","initArgs","baseUrl","ref","newScriptElement","stop","toPromise","race","init","descopeBridge","_init","lazyInit","isConnected","onFlowChange","_super","disconnectedCallback","getHtmlFilenameWithLocale","locale","filenameWithLocale","userLocale","getUserLocale","targetLocales","getTargetLocales","fallback","getPageContent","htmlLocaleFilename","body","fetchStaticResource","ex","currentState","prevState","isChanged","projectId","flowId","tenant","redirectUrl","exchangeError","redirectAuthCodeChallenge","redirectAuthCallbackUrl","redirectAuthBackupCallbackUri","redirectAuthInitiator","ssoQueryParams","startScreenId","startScreenName","conditionInteractionId","abTestingKey","getABTestingKey","outboundAppId","outboundAppScopes","loginId","getLastUserLoginId","projectConfig","getProjectConfig","flowVersions","entries","flows","key","version","redirectAuth","callbackUrl","codeChallenge","backupCallbackUri","platform","oauthProvider","oauthRedirect","magicLinkRedirect","ssoRedirect","conditionComponentsConfig","conditions","conditionScripts","componentsConfig","calculateConditions","getLastAuth","push","condition","calculateCondition","fingerprintEnabled","fingerprintKey","ensureFingerprintIds","clearFingerprintData","showFirstScreenOnExecutionInit","client","formConfigValues","descopeIdpInitiated","oidcLoginHint","externalId","isCodeChanged","isExchangeErrorChanged","channel","BroadcastChannel","postMessage","close","submit","loadForm","some","samlProp","injectSamlIdpForm","submitForm","popup","openCenteredPopup","intervalId","setInterval","closed","clearInterval","onPostMessage","event","eventOrigin","windowLocationOrigin","onmessage","webauthnCreate","webauthnGet","failure","create","nativeBridge","readyScreenId","oidcPrompt","oidcErrorRedirectUri","oidcResource","samlIdpUsername","direction","getAnimationDirection","getLastUserDisplayName","res","preview","transformScreenInputs","_DescopeWc_handleCustomScreen","stepTemplate","clone","content","cloneNode","loadDescopeUiComponents","isSupported","disableWebauthnButtons","email","updateTemplateFromScreenState","formConfig","geo","getExecutionContext","setPhoneAutoDetectDefaultCode","injectNextPage","rootElement","setTOTPVariable","totp","image","setNOTPVariable","notp","setCssVars","cssVars","replaceChildren","validateOnBlur","handleReportValidityOnBlur","updateScreenFromScreenState","_DescopeWc_hydrate","ELEMENT_TYPE_ATTRIBUTE"],"mappings":"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"}