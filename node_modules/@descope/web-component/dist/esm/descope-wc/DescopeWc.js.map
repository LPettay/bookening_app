{"version":3,"file":"DescopeWc.js","sources":["../../../src/lib/descope-wc/DescopeWc.ts"],"sourcesContent":["import {\n  clearFingerprintData,\n  ensureFingerprintIds,\n} from '@descope/web-js-sdk';\nimport {\n  CUSTOM_INTERACTIONS,\n  DESCOPE_ATTRIBUTE_EXCLUDE_FIELD,\n  DESCOPE_ATTRIBUTE_EXCLUDE_NEXT_BUTTON,\n  ELEMENT_TYPE_ATTRIBUTE,\n  FETCH_ERROR_RESPONSE_ERROR_CODE,\n  FETCH_EXCEPTION_ERROR_CODE,\n  FLOW_REQUESTED_IS_IN_OLD_VERSION_ERROR_CODE,\n  FLOW_TIMED_OUT_ERROR_CODE,\n  POLLING_STATUS_NOT_FOUND_ERROR_CODE,\n  RESPONSE_ACTIONS,\n  SDK_SCRIPTS_LOAD_TIMEOUT,\n  URL_CODE_PARAM_NAME,\n  URL_RUN_IDS_PARAM_NAME,\n  URL_TOKEN_PARAM_NAME,\n} from '../constants';\nimport {\n  clearPreviousExternalInputs,\n  getAnimationDirection,\n  getElementDescopeAttributes,\n  getFirstNonEmptyValue,\n  getScriptResultPath,\n  getUserLocale,\n  handleAutoFocus,\n  handleReportValidityOnBlur,\n  injectSamlIdpForm,\n  isConditionalLoginSupported,\n  leadingDebounce,\n  openCenteredPopup,\n  setTOTPVariable,\n  showFirstScreenOnExecutionInit,\n  State,\n  submitForm,\n  timeoutPromise,\n  transformScreenInputs,\n  transformStepStateForCustomScreen,\n  updateScreenFromScreenState,\n  updateTemplateFromScreenState,\n  withMemCache,\n} from '../helpers';\nimport { getABTestingKey } from '../helpers/abTestingKey';\nimport { calculateCondition, calculateConditions } from '../helpers/conditions';\nimport { getLastAuth, setLastAuth } from '../helpers/lastAuth';\nimport { IsChanged } from '../helpers/state';\nimport {\n  disableWebauthnButtons,\n  replaceElementMessage,\n  setCssVars,\n  setNOTPVariable,\n  setPhoneAutoDetectDefaultCode,\n} from '../helpers/templates';\nimport {\n  ClientScript,\n  ComponentsConfig,\n  CustomScreenState,\n  FlowState,\n  NextFn,\n  NextFnReturnPromiseValue,\n  ScriptElement,\n  ScriptModule,\n  SdkConfig,\n  StepState,\n} from '../types';\nimport BaseDescopeWc from './BaseDescopeWc';\n\n// this class is responsible for WC flow execution\nclass DescopeWc extends BaseDescopeWc {\n  errorTransformer:\n    | ((error: { text: string; type: string }) => string)\n    | undefined;\n\n  static set sdkConfigOverrides(config: Partial<SdkConfig>) {\n    BaseDescopeWc.sdkConfigOverrides = config;\n  }\n\n  static get sdkConfigOverrides() {\n    return BaseDescopeWc.sdkConfigOverrides;\n  }\n\n  flowState: State<FlowState>;\n\n  stepState = new State<StepState>({} as StepState);\n\n  #pollingTimeout: NodeJS.Timeout;\n\n  #conditionalUiAbortController = null;\n\n  onScreenUpdate?: (\n    screenName: string,\n    context: CustomScreenState,\n    next: StepState['next'],\n    ref: typeof this,\n  ) => boolean | Promise<boolean>;\n\n  #sdkScriptsLoading = null;\n\n  constructor() {\n    const flowState = new State<FlowState>({\n      deferredRedirect: false,\n    } as FlowState);\n\n    super(flowState.update.bind(flowState));\n\n    this.flowState = flowState;\n  }\n\n  #eventsCbRefs = {\n    visibilitychange: this.#syncStateWithVisibility.bind(this),\n  };\n\n  #syncStateWithVisibility() {\n    if (!document.hidden) {\n      // Defer the update a bit, it won't work otherwise\n      setTimeout(() => {\n        // Trigger state update that will redirect and pending deferred redirection\n        this.flowState.update({ deferredRedirect: false });\n      }, 300);\n    }\n  }\n\n  // Native bridge version native / web syncing - change this when\n  // a major change happens that requires some form of compatibility\n  bridgeVersion = 2;\n\n  // A collection of callbacks that are maintained as part of the web-component state\n  // when it's connected to a native bridge.\n  nativeCallbacks: {\n    // This callback will be initialized once a 'nativeBridge' action is\n    // received from a start or next request. It will then be called by\n    // nativeResume if appropriate as part of handling some payload types.\n    complete?: (input: Record<string, any>) => Promise<void>;\n\n    // This callback is invoked when 'nativeResume' is called with a 'beforeScreen'\n    // type, so the native bridge can resolve the async call to 'nativeBeforeScreen'\n    // and tell the web-component whether it wants a custom screen or not.\n    screenResolve?: (value: boolean) => void;\n\n    // This callback it kept until 'nativeResume' is called with a 'resumeScreen'\n    // type, so the native bridge can submit the result of a custom screen.\n    screenNext?: StepState['next'];\n  } = {};\n\n  // Notifies the native bridge that we're about to show a new screen and lets it\n  // override it by showing a native screen instead.\n  async #nativeBeforeScreen(\n    screen: string,\n    context: CustomScreenState,\n    next: StepState['next'],\n  ): Promise<boolean> {\n    if (this.nativeOptions?.bridgeVersion >= 2) {\n      return new Promise<boolean>((resolve) => {\n        this.nativeCallbacks.screenNext = next;\n        this.nativeCallbacks.screenResolve = resolve;\n        this.#nativeNotifyBridge('beforeScreen', { screen, context });\n      });\n    }\n    return false;\n  }\n\n  // Notifies the native bridge that a screen has been shown.\n  #nativeAfterScreen(screen: string) {\n    if (this.nativeOptions?.bridgeVersion >= 2) {\n      this.#nativeNotifyBridge('afterScreen', { screen });\n    }\n  }\n\n  // This callback is called by the native layer to resume a flow\n  // that's waiting for some external trigger, such as a magic link\n  // redirect or native OAuth authentication.\n  nativeResume(type: string, payload: string) {\n    const response = JSON.parse(payload);\n    if (type === 'oauthWeb' || type === 'sso') {\n      let { exchangeCode } = response;\n      if (!exchangeCode) {\n        const url = new URL(response.url);\n        exchangeCode = url.searchParams?.get(URL_CODE_PARAM_NAME);\n      }\n      this.nativeCallbacks.complete?.({\n        exchangeCode,\n        idpInitiated: true,\n      });\n    } else if (type === 'magicLink') {\n      const url = new URL(response.url);\n      const token = url.searchParams.get(URL_TOKEN_PARAM_NAME);\n      const stepId = url.searchParams\n        .get(URL_RUN_IDS_PARAM_NAME)\n        .split('_')\n        .pop();\n      this.#resetPollingTimeout();\n      // update the state along with cancelling out the action to abort the polling mechanism\n      this.flowState.update({ token, stepId, action: undefined });\n    } else if (type === 'beforeScreen') {\n      const { screenResolve } = this.nativeCallbacks;\n      this.nativeCallbacks.screenResolve = null;\n      const { override } = response;\n      if (!override) {\n        this.nativeCallbacks.screenNext = null;\n      }\n      screenResolve?.(override);\n    } else if (type === 'resumeScreen') {\n      const { interactionId, form } = response;\n      const { screenNext } = this.nativeCallbacks;\n      this.nativeCallbacks.screenNext = null;\n      screenNext?.(interactionId, form);\n    } else {\n      // expected: 'oauthNative', 'webauthnCreate', 'webauthnGet', 'failure'\n      this.nativeCallbacks.complete?.(response);\n    }\n  }\n\n  // Utility function for sending a generic message to the native bridge.\n  #nativeNotifyBridge(type: string, payload: Record<string, any>) {\n    this.#dispatch('bridge', {\n      type,\n      payload,\n    });\n  }\n\n  // This object is set by the native layer to\n  // inject native specific data into the 'flowState'.\n  nativeOptions?: {\n    platform: 'ios' | 'android';\n    bridgeVersion: number;\n    oauthProvider?: string;\n    oauthRedirect?: string;\n    magicLinkRedirect?: string;\n    ssoRedirect?: string;\n    origin?: string;\n  };\n\n  /**\n   * Get all loaded SDK script modules from elements with data-script-id attribute\n   * @returns Array of script modules that can be refreshed before form submission\n   */\n  loadSdkScriptsModules() {\n    // Get all modules from the data-script-id elements\n    const scriptElements = this.shadowRoot.querySelectorAll(\n      'div[data-script-id]',\n    );\n\n    // Filter out elements without moduleRes property\n    return Array.from(scriptElements)\n      .map((el) => (el as ScriptElement).moduleRes)\n      .filter((module): module is ScriptModule => !!module);\n  }\n\n  loadSdkScripts(scripts: ClientScript[]) {\n    if (!scripts?.length) {\n      return null;\n    }\n\n    const createScriptCallback =\n      (\n        script: {\n          id: string;\n          resultKey?: string;\n        },\n        resolve: (value: any) => void,\n      ) =>\n      (result: string) => {\n        this.dispatchEvent(\n          // update the context with the result, under the `resultKey` key\n          new CustomEvent('components-context', {\n            detail: {\n              // we store the result with script.id prefix to avoid conflicts with other scripts results\n              // that may have the same key\n              [getScriptResultPath(script.id, script.resultKey)]: result,\n            },\n            bubbles: true,\n            composed: true,\n          }),\n        );\n        resolve(script.id);\n      };\n\n    this.loggerWrapper.debug(\n      `Preparing to load scripts: ${scripts.map((s) => s.id).join(', ')}`,\n    );\n    const promises = Promise.all(\n      scripts?.map(async (script) => {\n        const scriptElement = this.shadowRoot.querySelector(\n          `[data-script-id=\"${script.id}\"]`,\n        ) as ScriptElement;\n        if (scriptElement) {\n          this.loggerWrapper.debug('Script already loaded', script.id);\n          const { moduleRes } = scriptElement;\n          moduleRes?.start?.();\n          return moduleRes;\n        }\n        await this.injectNpmLib(\n          '@descope/flow-scripts',\n          '1.0.11', // currently using a fixed version when loading scripts\n          `dist/${script.id}.js`,\n        );\n        const module = globalThis.descope?.[script.id];\n        return new Promise((resolve, reject) => {\n          try {\n            const moduleRes = module(\n              script.initArgs as any,\n              { baseUrl: this.baseUrl, ref: this },\n              createScriptCallback(script, resolve),\n            );\n            if (moduleRes) {\n              const newScriptElement = document.createElement(\n                'div',\n              ) as ScriptElement;\n              newScriptElement.setAttribute('data-script-id', script.id);\n              newScriptElement.moduleRes = moduleRes;\n              this.shadowRoot.appendChild(newScriptElement);\n              this.nextRequestStatus.subscribe(() => {\n                this.loggerWrapper.debug('Unloading script', script.id);\n                moduleRes.stop?.();\n              });\n            }\n          } catch (e) {\n            reject(e);\n          }\n        });\n      }),\n    );\n\n    const toPromise = new Promise((resolve) => {\n      setTimeout(() => {\n        this.loggerWrapper.warn('SDK scripts loading timeout');\n        resolve(true);\n      }, SDK_SCRIPTS_LOAD_TIMEOUT);\n    });\n\n    return Promise.race([promises, toPromise]);\n  }\n\n  get isDismissScreenErrorOnInput() {\n    return this.getAttribute('dismiss-screen-error-on-input') === 'true';\n  }\n\n  #handleGlobalErrors({\n    errorText,\n    errorType,\n  }: {\n    errorText: string;\n    errorType: string;\n  }) {\n    const updateGlobalError = () => {\n      let transformedErrorText = errorText;\n      try {\n        transformedErrorText =\n          this.errorTransformer?.({\n            text: errorText,\n            type: errorType,\n          }) || errorText;\n      } catch (e) {\n        this.loggerWrapper.error('Error transforming error message', e.message);\n      }\n      replaceElementMessage(\n        this.contentRootElement,\n        'error-message',\n        transformedErrorText,\n      );\n    };\n\n    // we do not know if the page is going to be updated or not,\n    // so we are updating the error message component before and after the screen update\n    this.addEventListener('screen-updated', updateGlobalError, { once: true });\n    updateGlobalError();\n  }\n\n  init() {\n    // when running in a webview (mobile SDK) we want to lazy init the component\n    // so the mobile SDK will be able to register all the necessary callbacks\n    // before the component will start loading the flow\n    if (!(window as any).descopeBridge) {\n      // eslint-disable-next-line no-underscore-dangle\n      return this._init();\n    }\n    // eslint-disable-next-line no-underscore-dangle\n    (this as any).lazyInit = this._init;\n    return undefined;\n  }\n\n  #subscribeStepState() {\n    this.stepState?.subscribe(\n      this.onStepChange.bind(this),\n      ({\n        screenState: { errorText, errorType, ...screenState } = {},\n        ...state\n      }) => ({ ...state, screenState }),\n    );\n\n    this.stepState?.subscribe(\n      this.#handleGlobalErrors.bind(this),\n      (state) => ({\n        errorText: state?.screenState?.errorText,\n        errorType: state?.screenState?.errorType,\n      }),\n      { forceUpdate: true },\n    );\n\n    this.stepState?.subscribe(\n      this.#handlePasscodeCleanup.bind(this),\n      (state) => ({\n        errorText: state?.screenState?.errorText,\n        errorType: state?.screenState?.errorType,\n      }),\n      { forceUpdate: true },\n    );\n  }\n\n  // because the screen does not re-render,\n  // in case of an OTP code error, we want to clean the invalid code\n  #handlePasscodeCleanup({ errorText, errorType }) {\n    if (errorType || errorText) {\n      this.contentRootElement\n        .querySelectorAll('descope-passcode[data-auto-submit=\"true\"]')\n        .forEach((passcodeEle: HTMLInputElement) => {\n          // currently we do not have a way to reset the code value\n          // so we are clearing the inputs\n          passcodeEle.shadowRoot\n            .querySelectorAll('descope-text-field[data-id]')\n            .forEach((input: HTMLInputElement) => {\n              // eslint-disable-next-line no-param-reassign\n              input.value = '';\n            });\n        });\n\n      // this should not be handled here, it's a workaround for focusing the code component on error\n      // maybe it's about time to refactor this sdk\n      handleAutoFocus(this.contentRootElement, this.autoFocus, false);\n    }\n  }\n\n  // eslint-disable-next-line no-underscore-dangle\n  async _init() {\n    if (this.shadowRoot.isConnected) {\n      this.flowState?.subscribe(this.onFlowChange.bind(this));\n      this.#subscribeStepState();\n\n      window.addEventListener(\n        'visibilitychange',\n        this.#eventsCbRefs.visibilitychange,\n      );\n    }\n    await super.init?.();\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback();\n\n    this.flowState.unsubscribeAll();\n    this.stepState.unsubscribeAll();\n\n    this.#conditionalUiAbortController?.abort();\n    this.#conditionalUiAbortController = null;\n\n    window.removeEventListener(\n      'visibilitychange',\n      this.#eventsCbRefs.visibilitychange,\n    );\n  }\n\n  async getHtmlFilenameWithLocale(locale: string, screenId: string) {\n    let filenameWithLocale: string;\n    const userLocale = getUserLocale(locale); // use provided locals, otherwise use browser locale\n    const targetLocales = await this.getTargetLocales();\n\n    if (targetLocales.includes(userLocale.locale)) {\n      filenameWithLocale = `${screenId}-${userLocale.locale}.html`;\n    } else if (targetLocales.includes(userLocale.fallback)) {\n      filenameWithLocale = `${screenId}-${userLocale.fallback}.html`;\n    }\n    return filenameWithLocale;\n  }\n\n  async getPageContent(htmlFilename: string, htmlLocaleFilename: string) {\n    if (htmlLocaleFilename) {\n      // try first locale url, if can't get for some reason, fallback to the original html url (the one without locale)\n      try {\n        const { body } = await this.fetchStaticResource(\n          htmlLocaleFilename,\n          'text',\n        );\n        return body;\n      } catch (ex) {\n        this.loggerWrapper.error(\n          `Failed to fetch flow page from ${htmlLocaleFilename}. Fallback to url ${htmlFilename}`,\n          ex,\n        );\n      }\n    }\n\n    try {\n      const { body } = await this.fetchStaticResource(htmlFilename, 'text');\n      return body;\n    } catch (ex) {\n      this.loggerWrapper.error(`Failed to fetch flow page`, ex.message);\n    }\n    return null;\n  }\n\n  async #handleFlowRestart() {\n    this.loggerWrapper.debug('Trying to restart the flow');\n    const prevCompVersion = await this.getComponentsVersion();\n    this.reset();\n    const compVersion = await this.getComponentsVersion();\n\n    if (prevCompVersion === compVersion) {\n      this.loggerWrapper.debug(\n        'Components version was not changed, restarting flow',\n      );\n      this.flowState.update({\n        stepId: null,\n        executionId: null,\n      });\n    } else {\n      this.loggerWrapper.error(\n        'Components version mismatch, please reload the page',\n      );\n    }\n  }\n\n  #isPrevCustomScreen = false;\n\n  async #handleCustomScreen(stepStateUpdate: Partial<StepState>) {\n    const { next, stepName, ...state } = {\n      ...this.stepState.current,\n      ...stepStateUpdate,\n    };\n\n    const context = transformStepStateForCustomScreen(state);\n\n    // first check if we're running in a native bridge and the app wants a custom screen\n    let isCustomScreen = await this.#nativeBeforeScreen(\n      stepName,\n      context,\n      next,\n    );\n    if (!isCustomScreen) {\n      // now check any custom callbacks that have been set on the component itself\n      isCustomScreen = Boolean(\n        await this.onScreenUpdate?.(stepName, context, next, this),\n      );\n    }\n\n    const isFirstScreen = !this.stepState.current.htmlFilename;\n    this.#toggleScreenVisibility(isCustomScreen);\n\n    // if we switched from a custom screen to a regular screen or the other way around\n    if (this.#isPrevCustomScreen !== isCustomScreen) {\n      const [currentMode, prevMode] = ['flow', 'custom'].sort(() =>\n        isCustomScreen ? -1 : 1,\n      );\n      this.loggerWrapper.debug(\n        `Switching from ${prevMode} screen to ${currentMode} screen`,\n      );\n\n      this.#isPrevCustomScreen = isCustomScreen;\n\n      if (isCustomScreen) {\n        // we are unsubscribing all the listeners because we are going to render a custom screen\n        // and we do not want that onStepChange will be called\n        this.stepState.unsubscribeAll();\n      } else {\n        // we are subscribing to the step state again because we are going to render a regular screen\n        this.#subscribeStepState();\n      }\n    }\n\n    if (isCustomScreen) {\n      this.loggerWrapper.debug('Showing a custom screen');\n      this.#dispatchPageEvents({\n        isFirstScreen,\n        isCustomScreen,\n        stepName: stepStateUpdate.stepName,\n      });\n    }\n\n    this.stepState.forceUpdate = isCustomScreen;\n  }\n\n  async onFlowChange(\n    currentState: FlowState,\n    prevState: FlowState,\n    isChanged: IsChanged<FlowState>,\n  ) {\n    const {\n      projectId,\n      flowId,\n      tenant,\n      stepId,\n      executionId,\n      action,\n      screenId,\n      screenState,\n      redirectTo,\n      redirectIsPopup,\n      redirectUrl,\n      token,\n      code,\n      isPopup,\n      exchangeError,\n      webauthnTransactionId,\n      webauthnOptions,\n      redirectAuthCodeChallenge,\n      redirectAuthCallbackUrl,\n      redirectAuthBackupCallbackUri,\n      redirectAuthInitiator,\n      locale,\n      samlIdpResponseUrl,\n      samlIdpResponseSamlResponse,\n      samlIdpResponseRelayState,\n      nativeResponseType,\n      nativePayload,\n      reqTimestamp,\n      ...ssoQueryParams\n    } = currentState;\n\n    let startScreenId: string;\n    let startScreenName: string;\n    let conditionInteractionId: string;\n    const abTestingKey = getABTestingKey();\n    const { outboundAppId } = this;\n    const { outboundAppScopes } = this;\n    const loginId = this.sdk.getLastUserLoginId();\n    const flowConfig = await this.getFlowConfig();\n    const projectConfig = await this.getProjectConfig();\n    const flowVersions = Object.entries(projectConfig.flows || {}).reduce(\n      // pass also current versions for all flows, it may be used as a part of the current flow\n      (acc, [key, value]) => {\n        acc[key] = value.version;\n        return acc;\n      },\n      {} as Record<string, number>,\n    );\n    const redirectAuth =\n      redirectAuthCallbackUrl && redirectAuthCodeChallenge\n        ? {\n            callbackUrl: redirectAuthCallbackUrl,\n            codeChallenge: redirectAuthCodeChallenge,\n            backupCallbackUri: redirectAuthBackupCallbackUri,\n          }\n        : undefined;\n    const nativeOptions = this.nativeOptions\n      ? {\n          platform: this.nativeOptions.platform,\n          bridgeVersion: this.nativeOptions.bridgeVersion,\n          oauthProvider: this.nativeOptions.oauthProvider,\n          oauthRedirect: this.nativeOptions.oauthRedirect,\n          magicLinkRedirect: this.nativeOptions.magicLinkRedirect,\n          ssoRedirect: this.nativeOptions.ssoRedirect,\n        }\n      : undefined;\n    let conditionComponentsConfig: ComponentsConfig = {};\n\n    // if there is no execution id we should start a new flow\n    if (!executionId) {\n      const clientScripts = [\n        ...(flowConfig.clientScripts || []),\n        ...(flowConfig.sdkScripts || []),\n      ];\n\n      if (flowConfig.conditions) {\n        let conditionScripts = [];\n        ({\n          startScreenId,\n          conditionInteractionId,\n          startScreenName,\n          clientScripts: conditionScripts,\n          componentsConfig: conditionComponentsConfig,\n        } = calculateConditions(\n          {\n            loginId,\n            code,\n            token,\n            abTestingKey,\n            lastAuth: getLastAuth(loginId),\n          },\n          flowConfig.conditions,\n        ));\n        clientScripts.push(...(conditionScripts || []));\n      } else if (flowConfig.condition) {\n        ({ startScreenId, conditionInteractionId } = calculateCondition(\n          flowConfig.condition,\n          {\n            loginId,\n            code,\n            token,\n            abTestingKey,\n            lastAuth: getLastAuth(loginId),\n          },\n        ));\n      } else {\n        startScreenName = flowConfig.startScreenName;\n        startScreenId = flowConfig.startScreenId;\n      }\n\n      this.#sdkScriptsLoading = this.loadSdkScripts(clientScripts);\n      if (flowConfig.fingerprintEnabled && flowConfig.fingerprintKey) {\n        await ensureFingerprintIds(flowConfig.fingerprintKey, this.baseUrl);\n      } else {\n        clearFingerprintData();\n      }\n\n      // As an optimization - we want to show the first screen if it is possible\n      if (!showFirstScreenOnExecutionInit(startScreenId, ssoQueryParams)) {\n        const sdkResp = await this.sdk.flow.start(\n          flowId,\n          {\n            tenant,\n            redirectAuth,\n            ...ssoQueryParams,\n            client: this.client,\n            ...(redirectUrl && { redirectUrl }),\n            lastAuth: getLastAuth(loginId),\n            abTestingKey,\n            locale: getUserLocale(locale).locale,\n            nativeOptions,\n            outboundAppId,\n            outboundAppScopes,\n          },\n          conditionInteractionId,\n          '',\n          projectConfig.componentsVersion,\n          flowVersions,\n          {\n            ...this.formConfigValues,\n            ...(code ? { exchangeCode: code, idpInitiated: true } : {}),\n            ...(ssoQueryParams.descopeIdpInitiated && { idpInitiated: true }),\n            ...(token ? { token } : {}),\n            ...(ssoQueryParams.oidcLoginHint\n              ? { externalId: ssoQueryParams.oidcLoginHint }\n              : {}),\n          },\n        );\n\n        this.#handleSdkResponse(sdkResp);\n        if (sdkResp?.data?.status !== 'completed') {\n          this.flowState.update({ code: undefined, token: undefined });\n        }\n        return;\n      }\n    }\n\n    this.loggerWrapper.debug(\n      'Before popup postmessage send',\n      JSON.stringify({\n        isPopup,\n        code,\n        exchangeError,\n        isCodeChanged: isChanged('code'),\n        isExchangeErrorChanged: isChanged('exchangeError'),\n      }),\n    );\n    if (\n      isPopup &&\n      ((isChanged('code') && code) ||\n        (isChanged('exchangeError') && exchangeError))\n    ) {\n      this.loggerWrapper.debug('Creating popup channel', executionId);\n      const channel = new BroadcastChannel(executionId);\n      this.loggerWrapper.debug(\n        'Posting message to popup channel',\n        JSON.stringify({ code, exchangeError }),\n      );\n      channel.postMessage({\n        data: { code, exchangeError },\n        action: 'code',\n      });\n      this.loggerWrapper.debug('Popup channel message posted, closing channel');\n      channel.close();\n      this.loggerWrapper.debug('Popup channel closed, closing window');\n      window.close();\n      return;\n    }\n\n    // if there is a descope url param on the url its because the user clicked on email link or redirected back to the app\n    // we should call next with the params\n    if (\n      executionId &&\n      ((isChanged('token') && token) ||\n        (isChanged('code') && code) ||\n        (isChanged('exchangeError') && exchangeError))\n    ) {\n      const sdkResp = await this.sdk.flow.next(\n        executionId,\n        stepId,\n        CUSTOM_INTERACTIONS.submit,\n        flowConfig.version,\n        projectConfig.componentsVersion,\n        {\n          token,\n          exchangeCode: code,\n          exchangeError,\n        },\n      );\n      this.#handleSdkResponse(sdkResp);\n      this.flowState.update({\n        token: undefined,\n        code: undefined,\n        exchangeError: undefined,\n      }); // should happen after handleSdkResponse, otherwise we will not have screen id on the next run\n      return;\n    }\n\n    const samlProps = [\n      'samlIdpResponseUrl',\n      'samlIdpResponseSamlResponse',\n      'samlIdpResponseRelayState',\n    ];\n    if (\n      action === RESPONSE_ACTIONS.loadForm &&\n      samlProps.some((samlProp) => isChanged(samlProp))\n    ) {\n      if (!samlIdpResponseUrl || !samlIdpResponseSamlResponse) {\n        this.loggerWrapper.error('Did not get saml idp params data to load');\n        return;\n      }\n\n      // Handle SAML IDP end of flow (\"redirect like\" by using html form with hidden params)\n      injectSamlIdpForm(\n        samlIdpResponseUrl,\n        samlIdpResponseSamlResponse,\n        samlIdpResponseRelayState || '',\n        submitForm,\n      ); // will redirect us to the saml acs url\n    }\n\n    if (\n      action === RESPONSE_ACTIONS.redirect &&\n      (isChanged('redirectTo') || isChanged('deferredRedirect'))\n    ) {\n      if (!redirectTo) {\n        this.loggerWrapper.error('Did not get redirect url');\n        return;\n      }\n      if (redirectAuthInitiator === 'android' && document.hidden) {\n        // on android native flows, defer redirects until in foreground\n        this.flowState.update({\n          deferredRedirect: true,\n        });\n        return;\n      }\n\n      this.loggerWrapper.debug(`Redirect is popup ${redirectIsPopup}`);\n      if (redirectIsPopup) {\n        // this width is below the breakpoint of most providers\n        this.loggerWrapper.debug('Opening redirect in popup');\n        const popup = openCenteredPopup(redirectTo, '?', 598, 700);\n\n        this.loggerWrapper.debug('Creating broadcast channel');\n        const channel = new BroadcastChannel(executionId);\n\n        this.loggerWrapper.debug('Starting popup closed detection');\n        // detect when the popup is closed\n        const intervalId = setInterval(() => {\n          if (popup.closed) {\n            this.loggerWrapper.debug(\n              'Popup closed, dispatching popupclosed event and clearing interval',\n            );\n            clearInterval(intervalId);\n\n            // we are dispatching a popupclosed event so we can handle it on other parts of the code (loading state management)\n            this.#dispatch('popupclosed', {});\n\n            this.loggerWrapper.debug('Closing channel');\n            channel.close();\n          }\n        }, 1000);\n\n        this.loggerWrapper.debug('Listening for postMessage on channel');\n        const onPostMessage = (event: MessageEvent) => {\n          this.loggerWrapper.debug(\n            'Received postMessage on channel',\n            JSON.stringify(event),\n          );\n          this.loggerWrapper.debug(\n            'Comparing origins',\n            JSON.stringify({\n              eventOrigin: event.origin,\n              windowLocationOrigin: window.location.origin,\n            }),\n          );\n          if (event.origin !== window.location.origin) return;\n\n          this.loggerWrapper.debug(\n            'PostMessage origin matches, processing message',\n          );\n          // eslint-disable-next-line @typescript-eslint/no-shadow\n          const { action, data } = event.data;\n          this.loggerWrapper.debug(\n            `PostMessage action: ${action}, data: ${JSON.stringify(data)}`,\n          );\n          if (action === 'code') {\n            this.loggerWrapper.debug(\n              'Updating flow state with code and exchangeError',\n            );\n            this.flowState.update({\n              code: data.code,\n              exchangeError: data.exchangeError,\n            });\n          }\n        };\n\n        channel.onmessage = onPostMessage;\n      } else {\n        this.handleRedirect(redirectTo);\n      }\n      return;\n    }\n\n    if (\n      action === RESPONSE_ACTIONS.webauthnCreate ||\n      action === RESPONSE_ACTIONS.webauthnGet\n    ) {\n      if (!webauthnTransactionId || !webauthnOptions) {\n        this.loggerWrapper.error(\n          'Did not get webauthn transaction id or options',\n        );\n        return;\n      }\n\n      this.#conditionalUiAbortController?.abort();\n      this.#conditionalUiAbortController = null;\n\n      let response: string;\n      let failure: string;\n\n      try {\n        response =\n          action === RESPONSE_ACTIONS.webauthnCreate\n            ? await this.sdk.webauthn.helpers.create(webauthnOptions)\n            : await this.sdk.webauthn.helpers.get(webauthnOptions);\n      } catch (e) {\n        if (e.name === 'InvalidStateError') {\n          // currently returned in Chrome when trying to register a WebAuthn device\n          // that's already registered for the user\n          this.loggerWrapper.warn('WebAuthn operation failed', e.message);\n        } else if (e.name !== 'NotAllowedError') {\n          // shouldn't happen in normal usage ('AbortError' is only when setting an AbortController)\n          this.loggerWrapper.error(e.message);\n        }\n        failure = e.name;\n      }\n      // Call next with the transactionId and the response or failure\n      const sdkResp = await this.sdk.flow.next(\n        executionId,\n        stepId,\n        CUSTOM_INTERACTIONS.submit,\n        flowConfig.version,\n        projectConfig.componentsVersion,\n        {\n          transactionId: webauthnTransactionId,\n          response,\n          failure,\n        },\n      );\n      this.#handleSdkResponse(sdkResp);\n    }\n\n    if (action === RESPONSE_ACTIONS.nativeBridge) {\n      // prepare a callback with the current flow state, and accept\n      // the input to be a JSON, passed down from the native layer.\n      // this function will be called as an async response to a 'bridge' event\n      this.nativeCallbacks.complete = async (input: Record<string, any>) => {\n        const sdkResp = await this.sdk.flow.next(\n          executionId,\n          stepId,\n          CUSTOM_INTERACTIONS.submit,\n          flowConfig.version,\n          projectConfig.componentsVersion,\n          input,\n        );\n        this.#handleSdkResponse(sdkResp);\n      };\n      // notify the bridging native layer that a native action is requested via 'bridge' event.\n      // the response will be in the form of calling the 'nativeCallbacks.complete' callback via\n      // the 'nativeResume' function.\n      this.#nativeNotifyBridge(nativeResponseType, nativePayload);\n      return;\n    }\n\n    if (isChanged('action')) {\n      this.#handlePollingResponse(\n        executionId,\n        stepId,\n        flowConfig.version,\n        projectConfig.componentsVersion,\n      );\n    }\n\n    // if there is no screen id (possibly due to page refresh or no screen flow) we should get it from the server\n    if (!screenId && !startScreenId) {\n      this.loggerWrapper.warn('No screen was found to show');\n      return;\n    }\n\n    const readyScreenId = startScreenId || screenId;\n\n    // get the right filename according to the user locale and flow target locales\n    const filenameWithLocale: string = await this.getHtmlFilenameWithLocale(\n      locale,\n      readyScreenId,\n    );\n\n    const {\n      oidcLoginHint,\n      oidcPrompt,\n      oidcErrorRedirectUri,\n      oidcResource,\n      samlIdpUsername,\n    } = ssoQueryParams;\n\n    // generate step state update data\n    const stepStateUpdate: Partial<StepState> = {\n      direction: getAnimationDirection(stepId, prevState.stepId),\n      screenState: {\n        ...screenState,\n        form: {\n          ...this.formConfigValues,\n          ...screenState?.form,\n        },\n        lastAuth: {\n          loginId,\n          name: this.sdk.getLastUserDisplayName() || loginId,\n        },\n        componentsConfig: {\n          ...flowConfig.componentsConfig,\n          ...conditionComponentsConfig,\n          ...screenState?.componentsConfig,\n        },\n      },\n      htmlFilename: `${readyScreenId}.html`,\n      htmlLocaleFilename: filenameWithLocale,\n      screenId: readyScreenId,\n      stepName: currentState.stepName || startScreenName,\n      samlIdpUsername,\n      oidcLoginHint,\n      oidcPrompt,\n      oidcErrorRedirectUri,\n      oidcResource,\n      action,\n    };\n\n    const lastAuth = getLastAuth(loginId);\n\n    // If there is a start screen id, next action should start the flow\n    // But if any of the sso params are not empty, this optimization doesn't happen\n    // because Descope may decide not to show the first screen (in cases like a user is already logged in) - this is more relevant for SSO scenarios\n    if (showFirstScreenOnExecutionInit(startScreenId, ssoQueryParams)) {\n      stepStateUpdate.next = async (interactionId, inputs) => {\n        const res = await this.sdk.flow.start(\n          flowId,\n          {\n            tenant,\n            redirectAuth,\n            ...ssoQueryParams,\n            lastAuth,\n            preview: this.preview,\n            abTestingKey,\n            client: this.client,\n            ...(redirectUrl && { redirectUrl }),\n            locale: getUserLocale(locale).locale,\n            nativeOptions,\n            outboundAppId,\n            outboundAppScopes,\n          },\n          conditionInteractionId,\n          interactionId,\n          projectConfig.componentsVersion,\n          flowVersions,\n          {\n            ...this.formConfigValues,\n            ...transformScreenInputs(inputs),\n            ...(code && { exchangeCode: code, idpInitiated: true }),\n            ...(ssoQueryParams.descopeIdpInitiated && { idpInitiated: true }),\n            ...(token && { token }),\n          },\n        );\n\n        this.#handleSdkResponse(res);\n\n        return res;\n      };\n    } else if (\n      isChanged('projectId') ||\n      isChanged('baseUrl') ||\n      isChanged('executionId') ||\n      isChanged('stepId')\n    ) {\n      stepStateUpdate.next = async (interactionId, input) => {\n        const res = await this.sdk.flow.next(\n          executionId,\n          stepId,\n          interactionId,\n          flowConfig.version,\n          projectConfig.componentsVersion,\n          transformScreenInputs(input),\n        );\n\n        this.#handleSdkResponse(res);\n\n        return res;\n      };\n    }\n\n    this.loggerWrapper.debug('Got a screen with id', stepStateUpdate.screenId);\n\n    await this.#handleCustomScreen(stepStateUpdate);\n\n    // update step state\n    this.stepState.update(stepStateUpdate);\n  }\n\n  // this function is used to handle redirects in the web component\n  // it can be overridden by the user to handle redirects in a custom way\n  // eslint-disable-next-line class-methods-use-this\n  handleRedirect = (redirectTo: string) => {\n    window.location.assign(redirectTo);\n  };\n\n  #toggleScreenVisibility = (isCustomScreen: boolean) => {\n    const toggleVisibility = () => {\n      this.contentRootElement.classList.toggle('hidden', isCustomScreen);\n      this.slotElement.classList.toggle('hidden', !isCustomScreen);\n      if (isCustomScreen) {\n        this.contentRootElement.innerHTML = '';\n      }\n    };\n\n    if (isCustomScreen && this.contentRootElement.hasChildNodes()) {\n      this.#handlePageSwitchTransition(toggleVisibility);\n    } else {\n      toggleVisibility();\n    }\n  };\n\n  #handlePageSwitchTransition(onTransitionEnd: () => void) {\n    const transitionEndHandler = () => {\n      this.loggerWrapper.debug('page switch transition end');\n      this.contentRootElement.classList.remove('fade-out');\n      onTransitionEnd();\n    };\n    this.contentRootElement.addEventListener(\n      'transitionend',\n      transitionEndHandler,\n      { once: true },\n    );\n    this.loggerWrapper.debug('page switch transition start');\n    this.contentRootElement.classList.add('fade-out');\n  }\n\n  #handlePollingResponse = (\n    executionId: string,\n    stepId: string,\n    flowVersion: number,\n    componentsVersion: string,\n    rescheduled: boolean = false,\n  ) => {\n    const pollingDefaultDelay = 2000;\n    const pollingDefaultTimeout = 6000;\n    const pollingThrottleDelay = 500;\n    const pollingThrottleThreshold = 500;\n    const pollingThrottleTimeout = 1000;\n    const stopOnErrors = [\n      FLOW_TIMED_OUT_ERROR_CODE,\n      POLLING_STATUS_NOT_FOUND_ERROR_CODE,\n    ];\n\n    if (this.flowState.current.action === RESPONSE_ACTIONS.poll) {\n      // schedule next polling request for 2 seconds from now\n      this.logger.debug('polling - Scheduling polling request');\n      const scheduledAt = Date.now();\n      const delay = rescheduled ? pollingThrottleDelay : pollingDefaultDelay;\n      this.#pollingTimeout = setTimeout(async () => {\n        this.logger.debug('polling - Calling next');\n\n        const nextCall = this.sdk.flow.next(\n          executionId,\n          stepId,\n          CUSTOM_INTERACTIONS.polling,\n          flowVersion,\n          componentsVersion,\n          {},\n        );\n\n        // Try to detect whether the tab is being throttled when running in a mobile browser, specifically on iOS.\n        // We check whether the tab seems to hidden and the polling callback was called much later than expected,\n        // in which case we allow a much shorter timeout for the polling request. The reschedule check ensures\n        // this cannot happen twice consecutively.\n        const throttled =\n          document.hidden &&\n          !rescheduled &&\n          Date.now() - scheduledAt > delay + pollingThrottleThreshold;\n        if (throttled) {\n          this.logger.debug('polling - The polling seems to be throttled');\n        }\n\n        let sdkResp: Awaited<typeof nextCall>;\n        try {\n          const timeout = throttled\n            ? pollingThrottleTimeout\n            : pollingDefaultTimeout;\n          sdkResp = await timeoutPromise(timeout, nextCall);\n        } catch (err) {\n          this.logger.warn(\n            `polling - The ${\n              throttled ? 'throttled fetch' : 'fetch'\n            } call timed out or was aborted`,\n          );\n          this.#handlePollingResponse(\n            executionId,\n            stepId,\n            flowVersion,\n            componentsVersion,\n            throttled,\n          );\n          return;\n        }\n\n        if (sdkResp?.error?.errorCode === FETCH_EXCEPTION_ERROR_CODE) {\n          this.logger.debug(\n            'polling - Got a generic error due to exception in fetch call',\n          );\n          this.#handlePollingResponse(\n            executionId,\n            stepId,\n            flowVersion,\n            componentsVersion,\n          );\n          return;\n        }\n\n        this.logger.debug('polling - Got a response');\n        if (sdkResp?.error) {\n          this.logger.debug(\n            'polling - Response has an error',\n            JSON.stringify(sdkResp.error, null, 4),\n          );\n        }\n\n        // we want to stop polling for some errors\n        if (\n          !sdkResp?.error?.errorCode ||\n          !stopOnErrors.includes(sdkResp.error.errorCode)\n        ) {\n          // will poll again if needed\n          // handleSdkResponse will clear the timeout if the response action is not polling response\n          this.#handlePollingResponse(\n            executionId,\n            stepId,\n            flowVersion,\n            componentsVersion,\n          );\n        } else {\n          this.logger.debug('polling - Stopping polling due to error');\n        }\n\n        this.#handleSdkResponse(sdkResp);\n      }, delay);\n    }\n  };\n\n  #resetPollingTimeout = () => {\n    clearTimeout(this.#pollingTimeout);\n    this.#pollingTimeout = null;\n  };\n\n  #handleSdkResponse = (sdkResp: NextFnReturnPromiseValue) => {\n    if (!sdkResp?.ok) {\n      const defaultMessage = sdkResp?.response?.url;\n      const defaultDescription = `${sdkResp?.response?.status} - ${sdkResp?.response?.statusText}`;\n\n      this.#dispatch(\n        'error',\n        sdkResp?.error || {\n          errorCode: FETCH_ERROR_RESPONSE_ERROR_CODE,\n          errorDescription: defaultDescription,\n          errorMessage: defaultMessage,\n        },\n      );\n\n      this.loggerWrapper.error(\n        sdkResp?.error?.errorDescription || defaultMessage,\n        sdkResp?.error?.errorMessage || defaultDescription,\n      );\n\n      const errorCode = sdkResp?.error?.errorCode;\n      if (\n        (errorCode === FLOW_REQUESTED_IS_IN_OLD_VERSION_ERROR_CODE ||\n          errorCode === FLOW_TIMED_OUT_ERROR_CODE) &&\n        this.isRestartOnError\n      ) {\n        this.#handleFlowRestart();\n      }\n      return;\n    }\n\n    sdkResp.data?.runnerLogs?.forEach((l) => {\n      const { level, title, log } = l;\n      if (level && this.loggerWrapper[level]) {\n        this.loggerWrapper[level](title, log);\n      } else {\n        this.loggerWrapper.info(title, log);\n      }\n    });\n    const errorText = sdkResp.data?.screen?.state?.errorText;\n    if (sdkResp.data?.error) {\n      this.loggerWrapper.error(\n        `[${sdkResp.data.error.code}]: ${sdkResp.data.error.description}`,\n        `${errorText ? `${errorText} - ` : ''}${sdkResp.data.error.message}`,\n      );\n    } else if (errorText) {\n      this.loggerWrapper.error(errorText);\n    }\n\n    const { status, authInfo, lastAuth, action, openInNewTabUrl } =\n      sdkResp.data;\n\n    if (action !== RESPONSE_ACTIONS.poll) {\n      this.#resetPollingTimeout();\n    }\n\n    if (status === 'completed') {\n      if (this.storeLastAuthenticatedUser) {\n        setLastAuth(lastAuth);\n      }\n      this.#dispatch('success', authInfo);\n      return;\n    } else {\n      if (this.storeLastAuthenticatedUser) {\n        setLastAuth(lastAuth, true);\n      }\n    }\n\n    if (openInNewTabUrl) {\n      window.open(openInNewTabUrl, '_blank');\n      // we should not return here so the screen will be rendered\n    }\n\n    const {\n      executionId,\n      stepId,\n      stepName,\n      screen,\n      redirect,\n      webauthn,\n      error,\n      samlIdpResponse,\n      nativeResponse,\n    } = sdkResp.data;\n\n    // this is used as a cache buster\n    // we want to make sure the onScreenUpdate will be called after every next call even if the state was not changed\n    const reqTimestamp = Date.now();\n\n    if (action === RESPONSE_ACTIONS.poll) {\n      // We only update action because the polling response action does not return extra information\n      this.flowState.update({\n        action,\n        reqTimestamp,\n      });\n      return;\n    }\n\n    this.loggerWrapper.info(\n      `Step \"${stepName || `#${stepId}`}\" is ${status}`,\n      '',\n      {\n        screen,\n        status,\n        stepId,\n        stepName,\n        action,\n        error,\n      },\n    );\n\n    if (screen.state?.clientScripts) {\n      this.#sdkScriptsLoading = this.loadSdkScripts(screen.state.clientScripts);\n    }\n\n    this.flowState.update({\n      stepId,\n      stepName,\n      executionId,\n      action,\n      redirectTo: redirect?.url,\n      redirectIsPopup: redirect?.isPopup,\n      screenId: screen?.id,\n      screenState: screen?.state,\n      webauthnTransactionId: webauthn?.transactionId,\n      webauthnOptions: webauthn?.options,\n      samlIdpResponseUrl: samlIdpResponse?.url,\n      samlIdpResponseSamlResponse: samlIdpResponse?.samlResponse,\n      samlIdpResponseRelayState: samlIdpResponse?.relayState,\n      nativeResponseType: nativeResponse?.type,\n      nativePayload: nativeResponse?.payload,\n      reqTimestamp,\n    });\n  };\n\n  // we want to get the start params only if we don't have it already\n  #getWebauthnConditionalUiStartParams = withMemCache(async () => {\n    try {\n      const startResp = await this.sdk.webauthn.signIn.start(\n        '',\n        window.location.origin,\n      ); // when using conditional UI we need to call start without identifier\n      if (!startResp.ok) {\n        this.loggerWrapper.warn(\n          'Webauthn start failed',\n          startResp?.error?.errorMessage,\n        );\n      }\n      return startResp.data;\n    } catch (err) {\n      this.loggerWrapper.warn('Webauthn start failed', err.message);\n    }\n\n    return undefined;\n  });\n\n  /**\n   * this is needed because Conditional UI does not work on all input names\n   * we need to add a prefix to the input name so it will trigger the autocomplete dialog\n   * but we want to remove it once the user starts typing because we want this field to be sent to the server with the correct name\n   */\n\n  // eslint-disable-next-line class-methods-use-this\n  #handleConditionalUiInput(inputEle: HTMLInputElement) {\n    const ignoreList = ['email'];\n    const origName = inputEle.getAttribute('name');\n\n    if (!ignoreList.includes(origName)) {\n      const conditionalUiSupportName = `user-${origName}`;\n\n      // eslint-disable-next-line no-param-reassign\n      inputEle.setAttribute('name', conditionalUiSupportName);\n\n      inputEle.addEventListener('input', () => {\n        // eslint-disable-next-line no-param-reassign\n        inputEle.setAttribute(\n          'name',\n          inputEle.value ? origName : conditionalUiSupportName,\n        );\n      });\n    }\n  }\n\n  async #handleWebauthnConditionalUi(fragment: DocumentFragment, next: NextFn) {\n    this.#conditionalUiAbortController?.abort();\n\n    const conditionalUiInput = fragment.querySelector(\n      '*[autocomplete=\"webauthn\"]',\n    ) as HTMLInputElement;\n\n    if (conditionalUiInput && (await isConditionalLoginSupported())) {\n      const { options, transactionId } =\n        (await this.#getWebauthnConditionalUiStartParams()) || {};\n\n      if (options && transactionId) {\n        this.#handleConditionalUiInput(conditionalUiInput);\n\n        // we need the abort controller so we can cancel the current webauthn session in case the user clicked on a webauthn button, and we need to start a new session\n        this.#conditionalUiAbortController = new AbortController();\n\n        // we should not wait for this fn, it will call next when the user uses his passkey on the input\n        this.sdk.webauthn.helpers\n          .conditional(options, this.#conditionalUiAbortController)\n          .then(async (response) => {\n            next(conditionalUiInput.id, {\n              transactionId,\n              response,\n            });\n          })\n          .catch((err) => {\n            if (err.name !== 'AbortError') {\n              this.loggerWrapper.error('Conditional login failed', err.message);\n            }\n          });\n      }\n    }\n  }\n\n  #dispatchPageEvents({\n    isFirstScreen,\n    isCustomScreen,\n    stepName,\n  }: {\n    isFirstScreen: boolean;\n    isCustomScreen: boolean;\n    stepName: string;\n  }) {\n    if (isFirstScreen) {\n      // Dispatch when the first page is ready\n      // So user can show a loader until his event is triggered\n      this.#dispatch('ready', {});\n    }\n\n    if (!isCustomScreen) {\n      this.#nativeAfterScreen(stepName);\n    }\n\n    this.#dispatch('page-updated', { screenName: stepName });\n    this.#dispatch('screen-updated', { screenName: stepName });\n  }\n\n  async onStepChange(currentState: StepState, prevState: StepState) {\n    const { htmlFilename, htmlLocaleFilename, direction, next, screenState } =\n      currentState;\n\n    this.loggerWrapper.debug('Rendering a flow screen');\n\n    const stepTemplate = document.createElement('template');\n    stepTemplate.innerHTML = await this.getPageContent(\n      htmlFilename,\n      htmlLocaleFilename,\n    );\n\n    const clone = stepTemplate.content.cloneNode(true) as DocumentFragment;\n\n    const loadDescopeUiComponents = this.loadDescopeUiComponents(stepTemplate);\n\n    // we want to disable the webauthn buttons if it's not supported on the browser\n    if (!this.sdk.webauthn.helpers.isSupported()) {\n      disableWebauthnButtons(clone);\n    } else {\n      await this.#handleWebauthnConditionalUi(clone, next);\n    }\n\n    if (\n      currentState.samlIdpUsername &&\n      !screenState.form?.loginId &&\n      !screenState.form?.email\n    ) {\n      if (!screenState.form) {\n        screenState.form = {};\n      }\n      screenState.form.loginId = currentState.samlIdpUsername;\n      screenState.form.email = currentState.samlIdpUsername;\n    }\n\n    updateTemplateFromScreenState(\n      clone,\n      screenState,\n      screenState.componentsConfig,\n      this.formConfig,\n      this.loggerWrapper,\n    );\n\n    // set the default country code based on the locale value we got\n    const { geo } = await this.getExecutionContext();\n    setPhoneAutoDetectDefaultCode(clone, geo);\n\n    const injectNextPage = async () => {\n      await loadDescopeUiComponents;\n\n      // put the totp and notp variable on the root element, which is the top level 'div' inside the shadowRoot\n      const rootElement = this.contentRootElement;\n      setTOTPVariable(rootElement, screenState?.totp?.image);\n\n      setNOTPVariable(rootElement, screenState?.notp?.image);\n\n      // set dynamic css variables that should be set at runtime\n      setCssVars(rootElement, clone, screenState.cssVars, this.loggerWrapper);\n\n      rootElement.replaceChildren(clone);\n\n      // If before html url was empty, we deduce its the first time a screen is shown\n      const isFirstScreen = !prevState.htmlFilename;\n\n      // we need to wait for all components to render before we can set its value\n      setTimeout(() => {\n        this.#updateExternalInputs();\n\n        if (this.validateOnBlur) {\n          handleReportValidityOnBlur(rootElement);\n        }\n\n        // we need to wait for all components to render before we can set its value\n        updateScreenFromScreenState(rootElement, screenState);\n\n        this.#dispatchPageEvents({\n          isFirstScreen,\n          isCustomScreen: false,\n          stepName: currentState.stepName,\n        });\n\n        handleAutoFocus(rootElement, this.autoFocus, isFirstScreen);\n      });\n\n      this.#hydrate(next);\n\n      const loader = rootElement.querySelector(\n        `[${ELEMENT_TYPE_ATTRIBUTE}=\"polling\"]`,\n      );\n      if (loader) {\n        // Loader component in the screen triggers polling interaction\n        next(CUSTOM_INTERACTIONS.polling, {});\n      }\n    };\n\n    // no animation\n    if (!direction) {\n      injectNextPage();\n      return;\n    }\n\n    this.#handlePageSwitchTransition(injectNextPage);\n  }\n\n  #validateInputs() {\n    let isValid = true;\n    Array.from(this.shadowRoot.querySelectorAll('*[name]'))\n      .reverse()\n      .forEach((input: HTMLInputElement) => {\n        if (input.localName === 'slot') {\n          return;\n        }\n        input.reportValidity?.();\n        if (isValid) {\n          isValid = input.checkValidity?.();\n        }\n      });\n\n    return isValid;\n  }\n\n  getInputs() {\n    return Array.from(\n      this.shadowRoot.querySelectorAll(\n        `*:not(slot)[name]:not([${DESCOPE_ATTRIBUTE_EXCLUDE_FIELD}])`,\n      ),\n    ) as HTMLInputElement[];\n  }\n\n  async #getFormData() {\n    const inputs = this.getInputs();\n\n    // wait for all inputs\n    const values = await Promise.all(\n      inputs.map(async (input) => ({\n        name: input.getAttribute('name'),\n        value: input.value,\n      })),\n    );\n\n    // reduce to object\n    return values.reduce(\n      (acc, val) => ({\n        ...acc,\n        [val.name]: val.value,\n      }),\n      {},\n    );\n  }\n\n  #prevPageShowListener: ((e: PageTransitionEvent) => void) | null = null;\n\n  #handleComponentsLoadingState(submitter: HTMLElement) {\n    const enabledElements = Array.from(\n      this.contentRootElement.querySelectorAll(\n        ':not([disabled]), [disabled=\"false\"]',\n      ),\n    ).filter((ele) => ele !== submitter);\n\n    const restoreComponentsState = async () => {\n      this.loggerWrapper.debug('Restoring components state');\n      this.removeEventListener('popupclosed', restoreComponentsState);\n      submitter.removeAttribute('loading');\n      enabledElements.forEach((ele) => {\n        ele.removeAttribute('disabled');\n      });\n      // if there are client scripts, we want to reload them\n      const flowConfig = await this.getFlowConfig();\n      const clientScripts = [\n        ...(flowConfig.clientScripts || []),\n        ...(flowConfig.sdkScripts || []),\n      ];\n      this.loadSdkScripts(clientScripts);\n    };\n\n    const handleScreenIdUpdates = () => {\n      // we want to remove the previous pageshow listener to avoid multiple listeners\n      window.removeEventListener('pageshow', this.#prevPageShowListener);\n\n      this.#prevPageShowListener = (e) => {\n        if (e.persisted) {\n          this.logger.debug(\n            'Page was loaded from cache, restoring components state',\n          );\n          restoreComponentsState();\n        }\n      };\n      // we want to restore the components state when the page is shown from cache\n      window.addEventListener('pageshow', this.#prevPageShowListener, {\n        once: true,\n      });\n\n      // we want to restore the components state when the screenId is updated\n      const unsubscribeScreenIdUpdates = this.stepState?.subscribe(\n        (screenId, prevScreenId) => {\n          // we want to restore components state only if we stay on the same screen\n          // if we are rendering a new screen, the components state (disabled/loading) will remain until the new screen is rendered\n          if (screenId === prevScreenId) {\n            restoreComponentsState();\n          }\n          this.removeEventListener('popupclosed', restoreComponentsState);\n          this.stepState.unsubscribe(unsubscribeScreenIdUpdates);\n        },\n        (state) => state.screenId,\n        { forceUpdate: true },\n      );\n    };\n\n    // we are listening to the next request status\n    const unsubscribeNextRequestStatus = this.nextRequestStatus.subscribe(\n      ({ isLoading }) => {\n        if (isLoading) {\n          this.addEventListener('popupclosed', restoreComponentsState, {\n            once: true,\n          });\n          // if the next request is loading, we want to set loading state on the submitter, and disable all other enabled elements\n          submitter.setAttribute('loading', 'true');\n          enabledElements.forEach((ele) =>\n            ele.setAttribute('disabled', 'true'),\n          );\n        } else {\n          this.nextRequestStatus.unsubscribe(unsubscribeNextRequestStatus);\n          // when next request is done, we want to listen to screenId updates\n          handleScreenIdUpdates();\n        }\n      },\n    );\n  }\n\n  // handle storing passwords in password managers\n  #handleStoreCredentials(formData = {}) {\n    const idFields = ['externalId', 'email', 'phone'];\n    const passwordFields = ['newPassword', 'password'];\n\n    const id = getFirstNonEmptyValue(formData, idFields);\n    const password = getFirstNonEmptyValue(formData, passwordFields);\n\n    // PasswordCredential not supported in Firefox\n    if (id && password) {\n      try {\n        if (!globalThis.PasswordCredential) {\n          return;\n        }\n        const cred = new globalThis.PasswordCredential({ id, password });\n\n        navigator?.credentials?.store?.(cred);\n      } catch (e) {\n        this.loggerWrapper.error('Could not store credentials', e.message);\n      }\n    }\n  }\n\n  #updateExternalInputs() {\n    // we need to clear external inputs that were created previously, so each screen has only\n    // the slotted inputs it needs\n    clearPreviousExternalInputs();\n\n    const eles = this.contentRootElement.querySelectorAll(\n      '[external-input=\"true\"]',\n    );\n    eles.forEach((ele) => this.#handleExternalInputs(ele));\n  }\n\n  #handleExternalInputs(ele: Element) {\n    if (!ele) {\n      return;\n    }\n\n    const origInputs = ele.querySelectorAll('input');\n\n    origInputs.forEach((inp) => {\n      const targetSlot = inp.getAttribute('slot');\n      const id = `input-${ele.id}-${targetSlot}`;\n\n      const slot = document.createElement('slot');\n      slot.setAttribute('name', id);\n      slot.setAttribute('slot', targetSlot);\n\n      ele.appendChild(slot);\n\n      inp.setAttribute('slot', id);\n      this.appendChild(inp);\n    });\n  }\n\n  // we are wrapping this function with a leading debounce,\n  // to prevent a scenario where we are calling it multiple times\n  // this can caused by focusing on a button and pressing enter\n  // in this case, the button will be clicked, but because we have the auto-submit mechanism\n  // it will submit the form once again and we will end up with 2 identical calls for next\n  #handleSubmit = leadingDebounce(\n    async (submitter: HTMLElement, next: NextFn) => {\n      if (\n        submitter.getAttribute('formnovalidate') === 'true' ||\n        this.#validateInputs()\n      ) {\n        const submitterId = submitter?.getAttribute('id');\n        this.#handleComponentsLoadingState(submitter);\n\n        const formData = await this.#getFormData();\n        const eleDescopeAttrs = getElementDescopeAttributes(submitter);\n\n        this.nextRequestStatus.update({ isLoading: true });\n\n        if (this.#sdkScriptsLoading) {\n          this.loggerWrapper.debug('Waiting for sdk scripts to load');\n          const now = Date.now();\n          await this.#sdkScriptsLoading;\n          this.loggerWrapper.debug(\n            'Sdk scripts loaded for',\n            (Date.now() - now).toString(),\n          );\n        }\n\n        // Get all script modules and refresh them before form submission\n        const sdkScriptsModules = this.loadSdkScriptsModules();\n\n        if (sdkScriptsModules.length > 0) {\n          // Only attempt to refresh modules that actually have a refresh function\n          const refreshPromises = sdkScriptsModules\n            .filter((module) => typeof module.refresh === 'function')\n            .map((module) => module.refresh!());\n\n          if (refreshPromises.length > 0) {\n            // Use timeout to prevent hanging if refresh takes too long\n            await timeoutPromise(\n              SDK_SCRIPTS_LOAD_TIMEOUT,\n              Promise.all(refreshPromises),\n              null,\n            );\n          }\n        }\n\n        const contextArgs = this.getComponentsContext();\n\n        const actionArgs = {\n          ...contextArgs,\n          ...eleDescopeAttrs,\n          ...formData,\n          // 'origin' is required to start webauthn. For now we'll add it to every request.\n          // When running in a native flow in a Android app the webauthn authentication\n          // is performed in the native app, so a custom origin needs to be injected\n          // into the webauthn request data.\n          origin: this.nativeOptions?.origin || window.location.origin,\n        };\n\n        await next(submitterId, actionArgs);\n\n        this.nextRequestStatus.update({ isLoading: false });\n\n        this.#handleStoreCredentials(formData);\n      }\n    },\n  );\n\n  #addPasscodeAutoSubmitListeners(next: NextFn) {\n    this.contentRootElement\n      .querySelectorAll(`descope-passcode[data-auto-submit=\"true\"]`)\n      .forEach((passcode: HTMLInputElement) => {\n        passcode.addEventListener('input', () => {\n          const isValid = passcode.checkValidity?.();\n          if (isValid) {\n            this.#handleSubmit(passcode, next);\n          }\n        });\n      });\n  }\n\n  #hydrate(next: NextFn) {\n    // hydrating the page\n    // Adding event listeners to all buttons without the exclude attribute\n    this.contentRootElement\n      .querySelectorAll(\n        `descope-button:not([${DESCOPE_ATTRIBUTE_EXCLUDE_NEXT_BUTTON}]), [data-type=\"button\"]:not([${DESCOPE_ATTRIBUTE_EXCLUDE_NEXT_BUTTON}]`,\n      )\n      .forEach((button: HTMLButtonElement) => {\n        // eslint-disable-next-line no-param-reassign\n        button.onclick = () => {\n          this.#handleSubmit(button, next);\n        };\n      });\n\n    this.#addPasscodeAutoSubmitListeners(next);\n\n    if (this.isDismissScreenErrorOnInput) {\n      // listen to all input events in order to clear the global error state\n      this.contentRootElement\n        .querySelectorAll(`*[name]:not([${DESCOPE_ATTRIBUTE_EXCLUDE_FIELD}])`)\n        .forEach((ele) => {\n          ele.addEventListener('input', () => {\n            this.stepState.update((state) => ({\n              ...state,\n              screenState: {\n                ...state.screenState,\n                errorText: '',\n                errorType: '',\n              },\n            }));\n          });\n        });\n    }\n  }\n\n  #dispatch(eventName: string, detail: any) {\n    this.dispatchEvent(new CustomEvent(eventName, { detail }));\n  }\n}\n\nexport default DescopeWc;\n"],"names":["DescopeWc","BaseDescopeWc","sdkConfigOverrides","config","constructor","flowState","State","deferredRedirect","super","update","bind","this","stepState","_DescopeWc_pollingTimeout","set","_DescopeWc_conditionalUiAbortController","_DescopeWc_sdkScriptsLoading","_DescopeWc_eventsCbRefs","visibilitychange","__classPrivateFieldGet","_DescopeWc_instances","_DescopeWc_syncStateWithVisibility","bridgeVersion","nativeCallbacks","_DescopeWc_isPrevCustomScreen","handleRedirect","redirectTo","window","location","assign","_DescopeWc_toggleScreenVisibility","isCustomScreen","toggleVisibility","contentRootElement","classList","toggle","slotElement","innerHTML","hasChildNodes","_DescopeWc_handlePageSwitchTransition","call","_DescopeWc_handlePollingResponse","executionId","stepId","flowVersion","componentsVersion","rescheduled","stopOnErrors","FLOW_TIMED_OUT_ERROR_CODE","POLLING_STATUS_NOT_FOUND_ERROR_CODE","current","action","RESPONSE_ACTIONS","poll","logger","debug","scheduledAt","Date","now","delay","__classPrivateFieldSet","setTimeout","__awaiter","nextCall","sdk","flow","next","CUSTOM_INTERACTIONS","polling","throttled","document","hidden","sdkResp","timeout","timeoutPromise","err","warn","_a","error","errorCode","FETCH_EXCEPTION_ERROR_CODE","JSON","stringify","_b","includes","_DescopeWc_handleSdkResponse","_DescopeWc_resetPollingTimeout","clearTimeout","ok","defaultMessage","response","url","defaultDescription","status","_c","statusText","_DescopeWc_dispatch","FETCH_ERROR_RESPONSE_ERROR_CODE","errorDescription","errorMessage","loggerWrapper","_d","_e","_f","FLOW_REQUESTED_IS_IN_OLD_VERSION_ERROR_CODE","isRestartOnError","_DescopeWc_handleFlowRestart","_h","_g","data","runnerLogs","forEach","l","level","title","log","info","errorText","_l","_k","_j","screen","state","_m","code","description","message","authInfo","lastAuth","openInNewTabUrl","storeLastAuthenticatedUser","setLastAuth","open","stepName","redirect","webauthn","samlIdpResponse","nativeResponse","reqTimestamp","_o","clientScripts","loadSdkScripts","redirectIsPopup","isPopup","screenId","id","screenState","webauthnTransactionId","transactionId","webauthnOptions","options","samlIdpResponseUrl","samlIdpResponseSamlResponse","samlResponse","samlIdpResponseRelayState","relayState","nativeResponseType","type","nativePayload","payload","_DescopeWc_getWebauthnConditionalUiStartParams","withMemCache","startResp","signIn","start","origin","_DescopeWc_prevPageShowListener","_DescopeWc_handleSubmit","leadingDebounce","submitter","getAttribute","_DescopeWc_validateInputs","submitterId","_DescopeWc_handleComponentsLoadingState","formData","_DescopeWc_getFormData","eleDescopeAttrs","getElementDescopeAttributes","nextRequestStatus","isLoading","toString","sdkScriptsModules","loadSdkScriptsModules","length","refreshPromises","filter","module","refresh","map","SDK_SCRIPTS_LOAD_TIMEOUT","Promise","all","contextArgs","getComponentsContext","actionArgs","Object","nativeOptions","_DescopeWc_handleStoreCredentials","nativeResume","parse","exchangeCode","URL","searchParams","get","URL_CODE_PARAM_NAME","complete","idpInitiated","token","URL_TOKEN_PARAM_NAME","URL_RUN_IDS_PARAM_NAME","split","pop","undefined","screenResolve","override","screenNext","interactionId","form","scriptElements","shadowRoot","querySelectorAll","Array","from","el","moduleRes","scripts","createScriptCallback","script","resolve","result","dispatchEvent","CustomEvent","detail","getScriptResultPath","resultKey","bubbles","composed","s","join","promises","scriptElement","querySelector","injectNpmLib","globalThis","descope","reject","initArgs","baseUrl","ref","newScriptElement","createElement","setAttribute","appendChild","subscribe","stop","e","toPromise","race","isDismissScreenErrorOnInput","init","descopeBridge","_init","lazyInit","isConnected","onFlowChange","_DescopeWc_subscribeStepState","addEventListener","_super","disconnectedCallback","unsubscribeAll","abort","removeEventListener","getHtmlFilenameWithLocale","locale","filenameWithLocale","userLocale","getUserLocale","targetLocales","getTargetLocales","fallback","getPageContent","htmlFilename","htmlLocaleFilename","body","fetchStaticResource","ex","currentState","prevState","isChanged","projectId","flowId","tenant","redirectUrl","exchangeError","redirectAuthCodeChallenge","redirectAuthCallbackUrl","redirectAuthBackupCallbackUri","redirectAuthInitiator","ssoQueryParams","__rest","startScreenId","startScreenName","conditionInteractionId","abTestingKey","getABTestingKey","outboundAppId","outboundAppScopes","loginId","getLastUserLoginId","flowConfig","getFlowConfig","projectConfig","getProjectConfig","flowVersions","entries","flows","reduce","acc","key","value","version","redirectAuth","callbackUrl","codeChallenge","backupCallbackUri","platform","oauthProvider","oauthRedirect","magicLinkRedirect","ssoRedirect","conditionComponentsConfig","sdkScripts","conditions","conditionScripts","componentsConfig","calculateConditions","getLastAuth","push","condition","calculateCondition","fingerprintEnabled","fingerprintKey","ensureFingerprintIds","clearFingerprintData","showFirstScreenOnExecutionInit","client","formConfigValues","descopeIdpInitiated","oidcLoginHint","externalId","isCodeChanged","isExchangeErrorChanged","channel","BroadcastChannel","postMessage","close","submit","loadForm","some","samlProp","injectSamlIdpForm","submitForm","popup","openCenteredPopup","intervalId","setInterval","closed","clearInterval","onPostMessage","event","eventOrigin","windowLocationOrigin","onmessage","webauthnCreate","webauthnGet","failure","helpers","create","name","nativeBridge","input","readyScreenId","oidcPrompt","oidcErrorRedirectUri","oidcResource","samlIdpUsername","stepStateUpdate","direction","getAnimationDirection","getLastUserDisplayName","inputs","res","preview","transformScreenInputs","_DescopeWc_handleCustomScreen","onStepChange","stepTemplate","clone","content","cloneNode","loadDescopeUiComponents","isSupported","_DescopeWc_handleWebauthnConditionalUi","disableWebauthnButtons","email","updateTemplateFromScreenState","formConfig","geo","getExecutionContext","setPhoneAutoDetectDefaultCode","injectNextPage","rootElement","setTOTPVariable","totp","image","setNOTPVariable","notp","setCssVars","cssVars","replaceChildren","isFirstScreen","_DescopeWc_updateExternalInputs","validateOnBlur","handleReportValidityOnBlur","updateScreenFromScreenState","_DescopeWc_dispatchPageEvents","handleAutoFocus","autoFocus","_DescopeWc_hydrate","ELEMENT_TYPE_ATTRIBUTE","getInputs","DESCOPE_ATTRIBUTE_EXCLUDE_FIELD","_DescopeWc_nativeBeforeScreen","context","_DescopeWc_nativeNotifyBridge","_DescopeWc_handleGlobalErrors","errorType","updateGlobalError","transformedErrorText","errorTransformer","text","replaceElementMessage","once","forceUpdate","_DescopeWc_handlePasscodeCleanup","passcodeEle","prevCompVersion","getComponentsVersion","reset","transformStepStateForCustomScreen","Boolean","onScreenUpdate","currentMode","prevMode","sort","onTransitionEnd","remove","add","inputEle","origName","conditionalUiSupportName","fragment","conditionalUiInput","isConditionalLoginSupported","_DescopeWc_handleConditionalUiInput","AbortController","conditional","then","catch","_DescopeWc_nativeAfterScreen","screenName","isValid","reverse","localName","reportValidity","checkValidity","val","enabledElements","ele","restoreComponentsState","removeAttribute","handleScreenIdUpdates","persisted","unsubscribeScreenIdUpdates","prevScreenId","unsubscribe","unsubscribeNextRequestStatus","getFirstNonEmptyValue","password","PasswordCredential","cred","navigator","credentials","store","clearPreviousExternalInputs","inp","targetSlot","slot","passcode","DESCOPE_ATTRIBUTE_EXCLUDE_NEXT_BUTTON","button","onclick","_DescopeWc_addPasscodeAutoSubmitListeners","eventName"],"mappings":"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"}