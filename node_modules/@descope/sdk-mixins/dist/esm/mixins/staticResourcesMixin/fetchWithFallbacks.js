const notLastMsgSuffix = 'Trying the next fallback URL...';
// reties in case on network error
const fetchWithRetry = async (url, init, { logger } = {}) => {
    try {
        return await fetch(url, init);
    }
    catch (e) {
        // if there is an exception, we want to retry
        // so we can overcome network errors
        logger === null || logger === void 0 ? void 0 : logger.debug(`Network error fetching URL ${url} [${e.message}], retrying...`);
        return fetch(url, init);
    }
};
const fetchWithFallbacks = async (fallbacks, init, { logger, onSuccess, } = {}) => {
    const fallbacksArr = Array.isArray(fallbacks) ? fallbacks : [fallbacks];
    for (let index = 0; index < fallbacksArr.length; index++) {
        const url = fallbacksArr[index];
        const isLast = index === fallbacksArr.length - 1;
        try {
            const res = await fetchWithRetry(url.toString(), init, { logger });
            if (res.ok) {
                onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(index);
                logger === null || logger === void 0 ? void 0 : logger.debug(`Successfully fetched URL ${url}`);
                return res;
            }
            const errMsg = `Error fetching URL ${url} [${res.status}]`;
            if (isLast)
                throw new Error(errMsg);
            logger === null || logger === void 0 ? void 0 : logger.debug(`${errMsg}. ${notLastMsgSuffix}`);
        }
        catch (e) {
            const errMsg = `Error fetching URL ${url} [${e.message}]`;
            if (isLast)
                throw new Error(errMsg);
            logger === null || logger === void 0 ? void 0 : logger.debug(`${errMsg}. ${notLastMsgSuffix}`);
        }
    }
};

export { fetchWithFallbacks };
//# sourceMappingURL=fetchWithFallbacks.js.map
