'use strict';

var tslib = require('tslib');
var sdkHelpers = require('@descope/sdk-helpers');
var loggerMixin = require('../loggerMixin/loggerMixin.js');
var constants = require('./constants.js');
var projectIdMixin = require('../projectIdMixin.js');
var baseUrlMixin = require('../baseUrlMixin.js');
var fetchWithFallbacks = require('./fetchWithFallbacks.js');

function getResourceUrl({ projectId, filename, assetsFolder = constants.ASSETS_FOLDER, baseUrl = constants.BASE_CONTENT_URL, }) {
    const url = new URL(baseUrl);
    url.pathname = sdkHelpers.pathJoin(url.pathname, projectId, assetsFolder, filename);
    // we want to keep the baseUrl so we can use it later
    url.baseUrl = baseUrl;
    return url;
}
const staticResourcesMixin = sdkHelpers.createSingletonMixin((superclass) => {
    var _StaticResourcesMixinClass_instances, _StaticResourcesMixinClass_lastBaseUrl, _StaticResourcesMixinClass_workingBaseUrl, _StaticResourcesMixinClass_getResourceUrls, _a;
    const BaseClass = sdkHelpers.compose(loggerMixin.loggerMixin, projectIdMixin.projectIdMixin, baseUrlMixin.baseUrlMixin)(superclass);
    // the logic should be as following:
    // if there is a local storage override, use it
    // otherwise, if there is a base-static-url attribute, use it
    // otherwise, try to use base-url, and check if it's working
    // if it's working, use it
    // if not, use the default content url
    return _a = class StaticResourcesMixinClass extends BaseClass {
            constructor() {
                super(...arguments);
                _StaticResourcesMixinClass_instances.add(this);
                _StaticResourcesMixinClass_lastBaseUrl.set(this, void 0);
                _StaticResourcesMixinClass_workingBaseUrl.set(this, void 0);
            }
            async fetchStaticResource(filename, format) {
                const resourceUrls = tslib.__classPrivateFieldGet(this, _StaticResourcesMixinClass_instances, "m", _StaticResourcesMixinClass_getResourceUrls).call(this, filename);
                // if there are multiple resource urls, it means that there are fallbacks,
                // if one of the options (which is not the last) is working, we want to keep using it by updating the workingBaseUrl
                const onSuccess = !Array.isArray(resourceUrls)
                    ? null
                    : (index) => {
                        if (index !== resourceUrls.length - 1) {
                            const { baseUrl } = resourceUrls[index];
                            tslib.__classPrivateFieldSet(this, _StaticResourcesMixinClass_workingBaseUrl, baseUrl, "f");
                        }
                    };
                try {
                    const res = await fetchWithFallbacks.fetchWithFallbacks(resourceUrls, { cache: 'default' }, { logger: this.logger, onSuccess });
                    return {
                        body: await res[format](),
                        headers: Object.fromEntries(res.headers.entries()),
                    };
                }
                catch (e) {
                    this.logger.error(e.message);
                }
            }
            get baseStaticUrl() {
                return this.getAttribute('base-static-url') || '';
            }
        },
        _StaticResourcesMixinClass_lastBaseUrl = new WeakMap(),
        _StaticResourcesMixinClass_workingBaseUrl = new WeakMap(),
        _StaticResourcesMixinClass_instances = new WeakSet(),
        _StaticResourcesMixinClass_getResourceUrls = function _StaticResourcesMixinClass_getResourceUrls(filename) {
            const overrideUrl = constants.OVERRIDE_CONTENT_URL || this.baseStaticUrl;
            if (overrideUrl) {
                return getResourceUrl({
                    projectId: this.projectId,
                    filename,
                    baseUrl: overrideUrl,
                });
            }
            const isBaseUrlUpdated = tslib.__classPrivateFieldGet(this, _StaticResourcesMixinClass_lastBaseUrl, "f") !== this.baseUrl;
            const shouldFallbackFetch = isBaseUrlUpdated && !!this.baseUrl;
            // if the base url has changed, reset the working base url
            if (isBaseUrlUpdated) {
                tslib.__classPrivateFieldSet(this, _StaticResourcesMixinClass_lastBaseUrl, this.baseUrl, "f");
                tslib.__classPrivateFieldSet(this, _StaticResourcesMixinClass_workingBaseUrl, undefined, "f");
            }
            const resourceUrl = getResourceUrl({
                projectId: this.projectId,
                filename,
                baseUrl: tslib.__classPrivateFieldGet(this, _StaticResourcesMixinClass_workingBaseUrl, "f"),
            });
            // if there is no reason to check the baseUrl, generate the resource url according to the priority
            if (!shouldFallbackFetch) {
                return resourceUrl;
            }
            const resourceUrlFromBaseUrl = getResourceUrl({
                projectId: this.projectId,
                filename,
                baseUrl: this.baseUrl + '/pages',
            });
            return [resourceUrlFromBaseUrl, resourceUrl];
        },
        _a;
});

exports.getResourceUrl = getResourceUrl;
exports.staticResourcesMixin = staticResourcesMixin;
//# sourceMappingURL=staticResourcesMixin.js.map
