import * as _descope_sdk_component_drivers from '@descope/sdk-component-drivers';
import * as redux from 'redux';
import * as _reduxjs_toolkit from '@reduxjs/toolkit';
import * as _descope_sdk_mixins from '@descope/sdk-mixins';

type AccessKey = {
    id: string;
    name: string;
    roleNames: string[];
    permittedIps: string[];
    status: string;
    createdTime: number;
    expireTime: number;
    expireTimeFormatted?: string;
    createdTimeFormatted?: string;
    createdBy: string;
    clientId: string;
    editable: boolean;
    boundUserId: string;
};
type SortParams = {
    field: string;
    desc: boolean;
};
type SearchAccessKeyConfig = {
    page?: number;
    limit?: number;
    text?: string;
    sort?: SortParams[];
};
type CreateAccessKeyConfig = {
    name: string;
    expiration: string;
    roleNames: string[];
    userId: string;
    permittedIps: string[];
};
type Role = {
    name: string;
    description: string;
    permissionNames: string[];
    createdTime: Date;
    tenantId: string;
};

type State = {
    accessKeysList: {
        data: AccessKey[];
        loading: boolean;
        error: unknown;
    };
    createAccessKey: {
        loading: boolean;
        error: unknown;
    };
    activateAccessKey: {
        loading: boolean;
        error: unknown;
    };
    deactivateAccessKey: {
        loading: boolean;
        error: unknown;
    };
    deleteAccessKey: {
        loading: boolean;
        error: unknown;
    };
    tenantRoles: {
        loading: boolean;
        error: unknown;
        data: Role[];
    };
    searchParams: {
        text: string;
        sort: SortParams[];
    };
    selectedAccessKeysIds: string[];
    notifications: Notification[];
};
type Notification = {
    type: 'success' | 'error';
    msg: string;
};

declare const AccessKeyManagementWidget: {
    new (...params: any[]): {
        init(): Promise<void>;
        "__#18@#createNotificationContent"({ type, msg }: {
            type: "success" | "error";
            msg: string;
        }): string;
        "__#18@#createNotification"(type: "success" | "error"): {
            setContent(templateOrString: string | HTMLTemplateElement): void;
            nodeName: string;
            close(): void;
            show(): void;
            remove(): void;
            "__#29651@#private": any;
            logger: {
                error(...data: any[]): void;
                warn(...data: any[]): void;
                info(...data: any[]): void;
                debug(...data: any[]): void;
            };
            readonly asyncEle: Promise<Element>;
            readonly ele: Element;
        };
        "__#18@#onNotificationsUpdate": (notifications: {
            type: "success" | "error";
            msg: string;
        }[]) => void;
        "__#29641@#isInit": boolean;
        connectedCallback: (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & {
            (): void;
            (): void;
        } & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void);
        accessKey: string;
        readonly accessKeyLabel: string;
        autocapitalize: string;
        dir: string;
        draggable: boolean;
        hidden: boolean;
        inert: boolean;
        innerText: string;
        lang: string;
        readonly offsetHeight: number;
        readonly offsetLeft: number;
        readonly offsetParent: Element;
        readonly offsetTop: number;
        readonly offsetWidth: number;
        outerText: string;
        popover: string;
        spellcheck: boolean;
        title: string;
        translate: boolean;
        attachInternals: (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals) & (() => ElementInternals);
        click: (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void);
        hidePopover: (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void);
        showPopover: (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void);
        togglePopover: ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean) & ((force?: boolean) => boolean);
        addEventListener: {
            <K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_1 extends keyof HTMLElementEventMap>(type: K_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_2 extends keyof HTMLElementEventMap>(type: K_2, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_2]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_3 extends keyof HTMLElementEventMap>(type: K_3, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_3]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_4 extends keyof HTMLElementEventMap>(type: K_4, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_4]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_5 extends keyof HTMLElementEventMap>(type: K_5, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_5]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_6 extends keyof HTMLElementEventMap>(type: K_6, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_6]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_7 extends keyof HTMLElementEventMap>(type: K_7, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_7]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_8 extends keyof HTMLElementEventMap>(type: K_8, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_8]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_9 extends keyof HTMLElementEventMap>(type: K_9, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_9]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_10 extends keyof HTMLElementEventMap>(type: K_10, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_10]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_11 extends keyof HTMLElementEventMap>(type: K_11, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_11]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_12 extends keyof HTMLElementEventMap>(type: K_12, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_12]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_13 extends keyof HTMLElementEventMap>(type: K_13, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_13]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_14 extends keyof HTMLElementEventMap>(type: K_14, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_14]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_15 extends keyof HTMLElementEventMap>(type: K_15, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_15]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        } & {
            <K_16 extends keyof HTMLElementEventMap>(type: K_16, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_16]) => any, options?: boolean | AddEventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        };
        removeEventListener: {
            <K_1_1 extends keyof HTMLElementEventMap>(type: K_1_1, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_1]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_2 extends keyof HTMLElementEventMap>(type: K_1_2, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_2]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_3 extends keyof HTMLElementEventMap>(type: K_1_3, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_3]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_4 extends keyof HTMLElementEventMap>(type: K_1_4, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_4]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_5 extends keyof HTMLElementEventMap>(type: K_1_5, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_5]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_6 extends keyof HTMLElementEventMap>(type: K_1_6, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_6]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_7 extends keyof HTMLElementEventMap>(type: K_1_7, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_7]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_8 extends keyof HTMLElementEventMap>(type: K_1_8, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_8]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_17 extends keyof HTMLElementEventMap>(type: K_17, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_17]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_9 extends keyof HTMLElementEventMap>(type: K_1_9, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_9]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_10 extends keyof HTMLElementEventMap>(type: K_1_10, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_10]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_11 extends keyof HTMLElementEventMap>(type: K_1_11, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_11]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_12 extends keyof HTMLElementEventMap>(type: K_1_12, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_12]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_13 extends keyof HTMLElementEventMap>(type: K_1_13, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_13]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_14 extends keyof HTMLElementEventMap>(type: K_1_14, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_14]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_15 extends keyof HTMLElementEventMap>(type: K_1_15, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_15]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        } & {
            <K_1_16 extends keyof HTMLElementEventMap>(type: K_1_16, listener: (this: HTMLElement, ev: HTMLElementEventMap[K_1_16]) => any, options?: boolean | EventListenerOptions): void;
            (type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
        };
        attributeChangedCallback: ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & {
            (attrName: string, oldValue: string, newValue: string): void;
            (attrName: string, oldValue: string, newValue: string): void;
        } & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void) & ((attrName: string, oldValue: string, newValue: string) => void);
        readonly attributes: NamedNodeMap;
        readonly classList: DOMTokenList;
        className: string;
        readonly clientHeight: number;
        readonly clientLeft: number;
        readonly clientTop: number;
        readonly clientWidth: number;
        id: string;
        readonly localName: string;
        readonly namespaceURI: string;
        onfullscreenchange: ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any);
        onfullscreenerror: ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any) & ((this: Element, ev: Event) => any);
        outerHTML: string;
        readonly ownerDocument: Document;
        readonly part: DOMTokenList;
        readonly prefix: string;
        readonly scrollHeight: number;
        scrollLeft: number;
        scrollTop: number;
        readonly scrollWidth: number;
        readonly shadowRoot: ShadowRoot;
        slot: string;
        readonly tagName: string;
        attachShadow: ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot) & ((init: ShadowRootInit) => ShadowRoot);
        checkVisibility: ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean) & ((options?: CheckVisibilityOptions) => boolean);
        closest: {
            <K_2_1 extends keyof HTMLElementTagNameMap>(selector: K_2_1): HTMLElementTagNameMap[K_2_1];
            <K_3_1 extends keyof SVGElementTagNameMap>(selector: K_3_1): SVGElementTagNameMap[K_3_1];
            <K_4_1 extends keyof MathMLElementTagNameMap>(selector: K_4_1): MathMLElementTagNameMap[K_4_1];
            <E extends Element = Element>(selectors: string): E;
        } & {
            <K_2_2 extends keyof HTMLElementTagNameMap>(selector: K_2_2): HTMLElementTagNameMap[K_2_2];
            <K_3_2 extends keyof SVGElementTagNameMap>(selector: K_3_2): SVGElementTagNameMap[K_3_2];
            <K_4_2 extends keyof MathMLElementTagNameMap>(selector: K_4_2): MathMLElementTagNameMap[K_4_2];
            <E_1 extends Element = Element>(selectors: string): E_1;
        } & {
            <K_2_3 extends keyof HTMLElementTagNameMap>(selector: K_2_3): HTMLElementTagNameMap[K_2_3];
            <K_3_3 extends keyof SVGElementTagNameMap>(selector: K_3_3): SVGElementTagNameMap[K_3_3];
            <K_4_3 extends keyof MathMLElementTagNameMap>(selector: K_4_3): MathMLElementTagNameMap[K_4_3];
            <E_2 extends Element = Element>(selectors: string): E_2;
        } & {
            <K_2_4 extends keyof HTMLElementTagNameMap>(selector: K_2_4): HTMLElementTagNameMap[K_2_4];
            <K_3_4 extends keyof SVGElementTagNameMap>(selector: K_3_4): SVGElementTagNameMap[K_3_4];
            <K_4_4 extends keyof MathMLElementTagNameMap>(selector: K_4_4): MathMLElementTagNameMap[K_4_4];
            <E_3 extends Element = Element>(selectors: string): E_3;
        } & {
            <K_2_5 extends keyof HTMLElementTagNameMap>(selector: K_2_5): HTMLElementTagNameMap[K_2_5];
            <K_3_5 extends keyof SVGElementTagNameMap>(selector: K_3_5): SVGElementTagNameMap[K_3_5];
            <K_4_5 extends keyof MathMLElementTagNameMap>(selector: K_4_5): MathMLElementTagNameMap[K_4_5];
            <E_4 extends Element = Element>(selectors: string): E_4;
        } & {
            <K_2_6 extends keyof HTMLElementTagNameMap>(selector: K_2_6): HTMLElementTagNameMap[K_2_6];
            <K_3_6 extends keyof SVGElementTagNameMap>(selector: K_3_6): SVGElementTagNameMap[K_3_6];
            <K_4_6 extends keyof MathMLElementTagNameMap>(selector: K_4_6): MathMLElementTagNameMap[K_4_6];
            <E_5 extends Element = Element>(selectors: string): E_5;
        } & {
            <K_2_7 extends keyof HTMLElementTagNameMap>(selector: K_2_7): HTMLElementTagNameMap[K_2_7];
            <K_3_7 extends keyof SVGElementTagNameMap>(selector: K_3_7): SVGElementTagNameMap[K_3_7];
            <K_4_7 extends keyof MathMLElementTagNameMap>(selector: K_4_7): MathMLElementTagNameMap[K_4_7];
            <E_6 extends Element = Element>(selectors: string): E_6;
        } & {
            <K_2_8 extends keyof HTMLElementTagNameMap>(selector: K_2_8): HTMLElementTagNameMap[K_2_8];
            <K_3_8 extends keyof SVGElementTagNameMap>(selector: K_3_8): SVGElementTagNameMap[K_3_8];
            <K_4_8 extends keyof MathMLElementTagNameMap>(selector: K_4_8): MathMLElementTagNameMap[K_4_8];
            <E_7 extends Element = Element>(selectors: string): E_7;
        } & {
            <K_18 extends keyof HTMLElementTagNameMap>(selector: K_18): HTMLElementTagNameMap[K_18];
            <K_19 extends keyof SVGElementTagNameMap>(selector: K_19): SVGElementTagNameMap[K_19];
            <K_20 extends keyof MathMLElementTagNameMap>(selector: K_20): MathMLElementTagNameMap[K_20];
            <E_8 extends Element = Element>(selectors: string): E_8;
        } & {
            <K_2_9 extends keyof HTMLElementTagNameMap>(selector: K_2_9): HTMLElementTagNameMap[K_2_9];
            <K_3_9 extends keyof SVGElementTagNameMap>(selector: K_3_9): SVGElementTagNameMap[K_3_9];
            <K_4_9 extends keyof MathMLElementTagNameMap>(selector: K_4_9): MathMLElementTagNameMap[K_4_9];
            <E_9 extends Element = Element>(selectors: string): E_9;
        } & {
            <K_2_10 extends keyof HTMLElementTagNameMap>(selector: K_2_10): HTMLElementTagNameMap[K_2_10];
            <K_3_10 extends keyof SVGElementTagNameMap>(selector: K_3_10): SVGElementTagNameMap[K_3_10];
            <K_4_10 extends keyof MathMLElementTagNameMap>(selector: K_4_10): MathMLElementTagNameMap[K_4_10];
            <E_10 extends Element = Element>(selectors: string): E_10;
        } & {
            <K_2_11 extends keyof HTMLElementTagNameMap>(selector: K_2_11): HTMLElementTagNameMap[K_2_11];
            <K_3_11 extends keyof SVGElementTagNameMap>(selector: K_3_11): SVGElementTagNameMap[K_3_11];
            <K_4_11 extends keyof MathMLElementTagNameMap>(selector: K_4_11): MathMLElementTagNameMap[K_4_11];
            <E_11 extends Element = Element>(selectors: string): E_11;
        } & {
            <K_2_12 extends keyof HTMLElementTagNameMap>(selector: K_2_12): HTMLElementTagNameMap[K_2_12];
            <K_3_12 extends keyof SVGElementTagNameMap>(selector: K_3_12): SVGElementTagNameMap[K_3_12];
            <K_4_12 extends keyof MathMLElementTagNameMap>(selector: K_4_12): MathMLElementTagNameMap[K_4_12];
            <E_12 extends Element = Element>(selectors: string): E_12;
        } & {
            <K_2_13 extends keyof HTMLElementTagNameMap>(selector: K_2_13): HTMLElementTagNameMap[K_2_13];
            <K_3_13 extends keyof SVGElementTagNameMap>(selector: K_3_13): SVGElementTagNameMap[K_3_13];
            <K_4_13 extends keyof MathMLElementTagNameMap>(selector: K_4_13): MathMLElementTagNameMap[K_4_13];
            <E_13 extends Element = Element>(selectors: string): E_13;
        } & {
            <K_2_14 extends keyof HTMLElementTagNameMap>(selector: K_2_14): HTMLElementTagNameMap[K_2_14];
            <K_3_14 extends keyof SVGElementTagNameMap>(selector: K_3_14): SVGElementTagNameMap[K_3_14];
            <K_4_14 extends keyof MathMLElementTagNameMap>(selector: K_4_14): MathMLElementTagNameMap[K_4_14];
            <E_14 extends Element = Element>(selectors: string): E_14;
        } & {
            <K_2_15 extends keyof HTMLElementTagNameMap>(selector: K_2_15): HTMLElementTagNameMap[K_2_15];
            <K_3_15 extends keyof SVGElementTagNameMap>(selector: K_3_15): SVGElementTagNameMap[K_3_15];
            <K_4_15 extends keyof MathMLElementTagNameMap>(selector: K_4_15): MathMLElementTagNameMap[K_4_15];
            <E_15 extends Element = Element>(selectors: string): E_15;
        } & {
            <K_2_16 extends keyof HTMLElementTagNameMap>(selector: K_2_16): HTMLElementTagNameMap[K_2_16];
            <K_3_16 extends keyof SVGElementTagNameMap>(selector: K_3_16): SVGElementTagNameMap[K_3_16];
            <K_4_16 extends keyof MathMLElementTagNameMap>(selector: K_4_16): MathMLElementTagNameMap[K_4_16];
            <E_16 extends Element = Element>(selectors: string): E_16;
        };
        computedStyleMap: (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly) & (() => StylePropertyMapReadOnly);
        getAttribute: ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string) & ((qualifiedName: string) => string);
        getAttributeNS: ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string) & ((namespace: string, localName: string) => string);
        getAttributeNames: (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]) & (() => string[]);
        getAttributeNode: ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr) & ((qualifiedName: string) => Attr);
        getAttributeNodeNS: ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr) & ((namespace: string, localName: string) => Attr);
        getBoundingClientRect: (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect) & (() => DOMRect);
        getClientRects: (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList) & (() => DOMRectList);
        getElementsByClassName: ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>) & ((classNames: string) => HTMLCollectionOf<Element>);
        getElementsByTagName: {
            <K_5_1 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_1): HTMLCollectionOf<HTMLElementTagNameMap[K_5_1]>;
            <K_6_1 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_1): HTMLCollectionOf<SVGElementTagNameMap[K_6_1]>;
            <K_7_1 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_1): HTMLCollectionOf<MathMLElementTagNameMap[K_7_1]>;
            <K_8_1 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_1): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_1]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_2 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_2): HTMLCollectionOf<HTMLElementTagNameMap[K_5_2]>;
            <K_6_2 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_2): HTMLCollectionOf<SVGElementTagNameMap[K_6_2]>;
            <K_7_2 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_2): HTMLCollectionOf<MathMLElementTagNameMap[K_7_2]>;
            <K_8_2 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_2): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_2]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_3 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_3): HTMLCollectionOf<HTMLElementTagNameMap[K_5_3]>;
            <K_6_3 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_3): HTMLCollectionOf<SVGElementTagNameMap[K_6_3]>;
            <K_7_3 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_3): HTMLCollectionOf<MathMLElementTagNameMap[K_7_3]>;
            <K_8_3 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_3): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_3]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_4 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_4): HTMLCollectionOf<HTMLElementTagNameMap[K_5_4]>;
            <K_6_4 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_4): HTMLCollectionOf<SVGElementTagNameMap[K_6_4]>;
            <K_7_4 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_4): HTMLCollectionOf<MathMLElementTagNameMap[K_7_4]>;
            <K_8_4 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_4): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_4]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_5 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_5): HTMLCollectionOf<HTMLElementTagNameMap[K_5_5]>;
            <K_6_5 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_5): HTMLCollectionOf<SVGElementTagNameMap[K_6_5]>;
            <K_7_5 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_5): HTMLCollectionOf<MathMLElementTagNameMap[K_7_5]>;
            <K_8_5 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_5): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_5]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_6 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_6): HTMLCollectionOf<HTMLElementTagNameMap[K_5_6]>;
            <K_6_6 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_6): HTMLCollectionOf<SVGElementTagNameMap[K_6_6]>;
            <K_7_6 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_6): HTMLCollectionOf<MathMLElementTagNameMap[K_7_6]>;
            <K_8_6 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_6): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_6]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_7 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_7): HTMLCollectionOf<HTMLElementTagNameMap[K_5_7]>;
            <K_6_7 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_7): HTMLCollectionOf<SVGElementTagNameMap[K_6_7]>;
            <K_7_7 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_7): HTMLCollectionOf<MathMLElementTagNameMap[K_7_7]>;
            <K_8_7 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_7): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_7]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_8 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_8): HTMLCollectionOf<HTMLElementTagNameMap[K_5_8]>;
            <K_6_8 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_8): HTMLCollectionOf<SVGElementTagNameMap[K_6_8]>;
            <K_7_8 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_8): HTMLCollectionOf<MathMLElementTagNameMap[K_7_8]>;
            <K_8_8 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_8): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_8]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_21 extends keyof HTMLElementTagNameMap>(qualifiedName: K_21): HTMLCollectionOf<HTMLElementTagNameMap[K_21]>;
            <K_22 extends keyof SVGElementTagNameMap>(qualifiedName: K_22): HTMLCollectionOf<SVGElementTagNameMap[K_22]>;
            <K_23 extends keyof MathMLElementTagNameMap>(qualifiedName: K_23): HTMLCollectionOf<MathMLElementTagNameMap[K_23]>;
            <K_24 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_24): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_24]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_9 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_9): HTMLCollectionOf<HTMLElementTagNameMap[K_5_9]>;
            <K_6_9 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_9): HTMLCollectionOf<SVGElementTagNameMap[K_6_9]>;
            <K_7_9 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_9): HTMLCollectionOf<MathMLElementTagNameMap[K_7_9]>;
            <K_8_9 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_9): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_9]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_10 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_10): HTMLCollectionOf<HTMLElementTagNameMap[K_5_10]>;
            <K_6_10 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_10): HTMLCollectionOf<SVGElementTagNameMap[K_6_10]>;
            <K_7_10 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_10): HTMLCollectionOf<MathMLElementTagNameMap[K_7_10]>;
            <K_8_10 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_10): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_10]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_11 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_11): HTMLCollectionOf<HTMLElementTagNameMap[K_5_11]>;
            <K_6_11 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_11): HTMLCollectionOf<SVGElementTagNameMap[K_6_11]>;
            <K_7_11 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_11): HTMLCollectionOf<MathMLElementTagNameMap[K_7_11]>;
            <K_8_11 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_11): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_11]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_12 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_12): HTMLCollectionOf<HTMLElementTagNameMap[K_5_12]>;
            <K_6_12 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_12): HTMLCollectionOf<SVGElementTagNameMap[K_6_12]>;
            <K_7_12 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_12): HTMLCollectionOf<MathMLElementTagNameMap[K_7_12]>;
            <K_8_12 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_12): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_12]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_13 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_13): HTMLCollectionOf<HTMLElementTagNameMap[K_5_13]>;
            <K_6_13 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_13): HTMLCollectionOf<SVGElementTagNameMap[K_6_13]>;
            <K_7_13 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_13): HTMLCollectionOf<MathMLElementTagNameMap[K_7_13]>;
            <K_8_13 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_13): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_13]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_14 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_14): HTMLCollectionOf<HTMLElementTagNameMap[K_5_14]>;
            <K_6_14 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_14): HTMLCollectionOf<SVGElementTagNameMap[K_6_14]>;
            <K_7_14 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_14): HTMLCollectionOf<MathMLElementTagNameMap[K_7_14]>;
            <K_8_14 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_14): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_14]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_15 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_15): HTMLCollectionOf<HTMLElementTagNameMap[K_5_15]>;
            <K_6_15 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_15): HTMLCollectionOf<SVGElementTagNameMap[K_6_15]>;
            <K_7_15 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_15): HTMLCollectionOf<MathMLElementTagNameMap[K_7_15]>;
            <K_8_15 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_15): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_15]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        } & {
            <K_5_16 extends keyof HTMLElementTagNameMap>(qualifiedName: K_5_16): HTMLCollectionOf<HTMLElementTagNameMap[K_5_16]>;
            <K_6_16 extends keyof SVGElementTagNameMap>(qualifiedName: K_6_16): HTMLCollectionOf<SVGElementTagNameMap[K_6_16]>;
            <K_7_16 extends keyof MathMLElementTagNameMap>(qualifiedName: K_7_16): HTMLCollectionOf<MathMLElementTagNameMap[K_7_16]>;
            <K_8_16 extends keyof HTMLElementDeprecatedTagNameMap>(qualifiedName: K_8_16): HTMLCollectionOf<HTMLElementDeprecatedTagNameMap[K_8_16]>;
            (qualifiedName: string): HTMLCollectionOf<Element>;
        };
        getElementsByTagNameNS: {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        } & {
            (namespaceURI: "http://www.w3.org/1999/xhtml", localName: string): HTMLCollectionOf<HTMLElement>;
            (namespaceURI: "http://www.w3.org/2000/svg", localName: string): HTMLCollectionOf<SVGElement>;
            (namespaceURI: "http://www.w3.org/1998/Math/MathML", localName: string): HTMLCollectionOf<MathMLElement>;
            (namespace: string, localName: string): HTMLCollectionOf<Element>;
        };
        hasAttribute: ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean) & ((qualifiedName: string) => boolean);
        hasAttributeNS: ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean) & ((namespace: string, localName: string) => boolean);
        hasAttributes: (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean);
        hasPointerCapture: ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean) & ((pointerId: number) => boolean);
        insertAdjacentElement: ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element) & ((where: InsertPosition, element: Element) => Element);
        insertAdjacentHTML: ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void) & ((position: InsertPosition, text: string) => void);
        insertAdjacentText: ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void) & ((where: InsertPosition, data: string) => void);
        matches: ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean);
        releasePointerCapture: ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void);
        removeAttribute: ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void) & ((qualifiedName: string) => void);
        removeAttributeNS: ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void) & ((namespace: string, localName: string) => void);
        removeAttributeNode: ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr);
        requestFullscreen: ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>) & ((options?: FullscreenOptions) => Promise<void>);
        requestPointerLock: (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void);
        scroll: {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        };
        scrollBy: {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        };
        scrollIntoView: ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void) & ((arg?: boolean | ScrollIntoViewOptions) => void);
        scrollTo: {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        } & {
            (options?: ScrollToOptions): void;
            (x: number, y: number): void;
        };
        setAttribute: ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void) & ((qualifiedName: string, value: string) => void);
        setAttributeNS: ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void) & ((namespace: string, qualifiedName: string, value: string) => void);
        setAttributeNode: ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr);
        setAttributeNodeNS: ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr) & ((attr: Attr) => Attr);
        setPointerCapture: ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void) & ((pointerId: number) => void);
        toggleAttribute: ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean) & ((qualifiedName: string, force?: boolean) => boolean);
        webkitMatchesSelector: ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean) & ((selectors: string) => boolean);
        readonly baseURI: string;
        readonly childNodes: NodeListOf<ChildNode>;
        readonly firstChild: ChildNode;
        readonly isConnected: boolean;
        readonly lastChild: ChildNode;
        readonly nextSibling: ChildNode;
        readonly nodeName: string;
        readonly nodeType: number;
        nodeValue: string;
        readonly parentElement: HTMLElement;
        readonly parentNode: ParentNode;
        readonly previousSibling: ChildNode;
        textContent: string;
        appendChild: (<T_1 extends Node>(node: T_1) => T_1) & (<T_1_1 extends Node>(node: T_1_1) => T_1_1) & (<T_1_2 extends Node>(node: T_1_2) => T_1_2) & (<T_1_3 extends Node>(node: T_1_3) => T_1_3) & (<T_1_4 extends Node>(node: T_1_4) => T_1_4) & (<T_1_5 extends Node>(node: T_1_5) => T_1_5) & (<T_1_6 extends Node>(node: T_1_6) => T_1_6) & (<T_1_7 extends Node>(node: T_1_7) => T_1_7) & (<T extends Node>(node: T) => T) & (<T_1_8 extends Node>(node: T_1_8) => T_1_8) & (<T_1_9 extends Node>(node: T_1_9) => T_1_9) & (<T_1_10 extends Node>(node: T_1_10) => T_1_10) & (<T_1_11 extends Node>(node: T_1_11) => T_1_11) & (<T_1_12 extends Node>(node: T_1_12) => T_1_12) & (<T_1_13 extends Node>(node: T_1_13) => T_1_13) & (<T_1_14 extends Node>(node: T_1_14) => T_1_14) & (<T_1_15 extends Node>(node: T_1_15) => T_1_15);
        cloneNode: ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node) & ((deep?: boolean) => Node);
        compareDocumentPosition: ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number) & ((other: Node) => number);
        contains: ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean) & ((other: Node) => boolean);
        getRootNode: ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node) & ((options?: GetRootNodeOptions) => Node);
        hasChildNodes: (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean) & (() => boolean);
        insertBefore: (<T_2 extends Node>(node: T_2, child: Node) => T_2) & (<T_2_1 extends Node>(node: T_2_1, child: Node) => T_2_1) & (<T_2_2 extends Node>(node: T_2_2, child: Node) => T_2_2) & (<T_2_3 extends Node>(node: T_2_3, child: Node) => T_2_3) & (<T_2_4 extends Node>(node: T_2_4, child: Node) => T_2_4) & (<T_2_5 extends Node>(node: T_2_5, child: Node) => T_2_5) & (<T_2_6 extends Node>(node: T_2_6, child: Node) => T_2_6) & (<T_2_7 extends Node>(node: T_2_7, child: Node) => T_2_7) & (<T_3 extends Node>(node: T_3, child: Node) => T_3) & (<T_2_8 extends Node>(node: T_2_8, child: Node) => T_2_8) & (<T_2_9 extends Node>(node: T_2_9, child: Node) => T_2_9) & (<T_2_10 extends Node>(node: T_2_10, child: Node) => T_2_10) & (<T_2_11 extends Node>(node: T_2_11, child: Node) => T_2_11) & (<T_2_12 extends Node>(node: T_2_12, child: Node) => T_2_12) & (<T_2_13 extends Node>(node: T_2_13, child: Node) => T_2_13) & (<T_2_14 extends Node>(node: T_2_14, child: Node) => T_2_14) & (<T_2_15 extends Node>(node: T_2_15, child: Node) => T_2_15);
        isDefaultNamespace: ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean) & ((namespace: string) => boolean);
        isEqualNode: ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean);
        isSameNode: ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean) & ((otherNode: Node) => boolean);
        lookupNamespaceURI: ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string) & ((prefix: string) => string);
        lookupPrefix: ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string) & ((namespace: string) => string);
        normalize: (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void);
        removeChild: (<T_3_1 extends Node>(child: T_3_1) => T_3_1) & (<T_3_2 extends Node>(child: T_3_2) => T_3_2) & (<T_3_3 extends Node>(child: T_3_3) => T_3_3) & (<T_3_4 extends Node>(child: T_3_4) => T_3_4) & (<T_3_5 extends Node>(child: T_3_5) => T_3_5) & (<T_3_6 extends Node>(child: T_3_6) => T_3_6) & (<T_3_7 extends Node>(child: T_3_7) => T_3_7) & (<T_3_8 extends Node>(child: T_3_8) => T_3_8) & (<T_4 extends Node>(child: T_4) => T_4) & (<T_3_9 extends Node>(child: T_3_9) => T_3_9) & (<T_3_10 extends Node>(child: T_3_10) => T_3_10) & (<T_3_11 extends Node>(child: T_3_11) => T_3_11) & (<T_3_12 extends Node>(child: T_3_12) => T_3_12) & (<T_3_13 extends Node>(child: T_3_13) => T_3_13) & (<T_3_14 extends Node>(child: T_3_14) => T_3_14) & (<T_3_15 extends Node>(child: T_3_15) => T_3_15) & (<T_3_16 extends Node>(child: T_3_16) => T_3_16);
        replaceChild: (<T_4_1 extends Node>(node: Node, child: T_4_1) => T_4_1) & (<T_4_2 extends Node>(node: Node, child: T_4_2) => T_4_2) & (<T_4_3 extends Node>(node: Node, child: T_4_3) => T_4_3) & (<T_4_4 extends Node>(node: Node, child: T_4_4) => T_4_4) & (<T_4_5 extends Node>(node: Node, child: T_4_5) => T_4_5) & (<T_4_6 extends Node>(node: Node, child: T_4_6) => T_4_6) & (<T_4_7 extends Node>(node: Node, child: T_4_7) => T_4_7) & (<T_4_8 extends Node>(node: Node, child: T_4_8) => T_4_8) & (<T_5 extends Node>(node: Node, child: T_5) => T_5) & (<T_4_9 extends Node>(node: Node, child: T_4_9) => T_4_9) & (<T_4_10 extends Node>(node: Node, child: T_4_10) => T_4_10) & (<T_4_11 extends Node>(node: Node, child: T_4_11) => T_4_11) & (<T_4_12 extends Node>(node: Node, child: T_4_12) => T_4_12) & (<T_4_13 extends Node>(node: Node, child: T_4_13) => T_4_13) & (<T_4_14 extends Node>(node: Node, child: T_4_14) => T_4_14) & (<T_4_15 extends Node>(node: Node, child: T_4_15) => T_4_15) & (<T_4_16 extends Node>(node: Node, child: T_4_16) => T_4_16);
        readonly ELEMENT_NODE: 1;
        readonly ATTRIBUTE_NODE: 2;
        readonly TEXT_NODE: 3;
        readonly CDATA_SECTION_NODE: 4;
        readonly ENTITY_REFERENCE_NODE: 5;
        readonly ENTITY_NODE: 6;
        readonly PROCESSING_INSTRUCTION_NODE: 7;
        readonly COMMENT_NODE: 8;
        readonly DOCUMENT_NODE: 9;
        readonly DOCUMENT_TYPE_NODE: 10;
        readonly DOCUMENT_FRAGMENT_NODE: 11;
        readonly NOTATION_NODE: 12;
        readonly DOCUMENT_POSITION_DISCONNECTED: 1;
        readonly DOCUMENT_POSITION_PRECEDING: 2;
        readonly DOCUMENT_POSITION_FOLLOWING: 4;
        readonly DOCUMENT_POSITION_CONTAINS: 8;
        readonly DOCUMENT_POSITION_CONTAINED_BY: 16;
        readonly DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32;
        dispatchEvent: ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean) & ((event: Event) => boolean);
        ariaAtomic: string;
        ariaAutoComplete: string;
        ariaBusy: string;
        ariaChecked: string;
        ariaColCount: string;
        ariaColIndex: string;
        ariaColSpan: string;
        ariaCurrent: string;
        ariaDescription: string;
        ariaDisabled: string;
        ariaExpanded: string;
        ariaHasPopup: string;
        ariaHidden: string;
        ariaInvalid: string;
        ariaKeyShortcuts: string;
        ariaLabel: string;
        ariaLevel: string;
        ariaLive: string;
        ariaModal: string;
        ariaMultiLine: string;
        ariaMultiSelectable: string;
        ariaOrientation: string;
        ariaPlaceholder: string;
        ariaPosInSet: string;
        ariaPressed: string;
        ariaReadOnly: string;
        ariaRequired: string;
        ariaRoleDescription: string;
        ariaRowCount: string;
        ariaRowIndex: string;
        ariaRowSpan: string;
        ariaSelected: string;
        ariaSetSize: string;
        ariaSort: string;
        ariaValueMax: string;
        ariaValueMin: string;
        ariaValueNow: string;
        ariaValueText: string;
        role: string;
        animate: ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation) & ((keyframes: PropertyIndexedKeyframes | Keyframe[], options?: number | KeyframeAnimationOptions) => Animation);
        getAnimations: ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]) & ((options?: GetAnimationsOptions) => Animation[]);
        after: ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void);
        before: ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void);
        remove: (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void);
        replaceWith: ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void);
        innerHTML: string;
        readonly nextElementSibling: Element;
        readonly previousElementSibling: Element;
        readonly childElementCount: number;
        readonly children: HTMLCollection;
        readonly firstElementChild: Element;
        readonly lastElementChild: Element;
        append: ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void);
        prepend: ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void);
        querySelector: {
            <K_9_1 extends keyof HTMLElementTagNameMap>(selectors: K_9_1): HTMLElementTagNameMap[K_9_1];
            <K_10_1 extends keyof SVGElementTagNameMap>(selectors: K_10_1): SVGElementTagNameMap[K_10_1];
            <K_11_1 extends keyof MathMLElementTagNameMap>(selectors: K_11_1): MathMLElementTagNameMap[K_11_1];
            <K_12_1 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_1): HTMLElementDeprecatedTagNameMap[K_12_1];
            <E_1_1 extends Element = Element>(selectors: string): E_1_1;
        } & {
            <K_9_2 extends keyof HTMLElementTagNameMap>(selectors: K_9_2): HTMLElementTagNameMap[K_9_2];
            <K_10_2 extends keyof SVGElementTagNameMap>(selectors: K_10_2): SVGElementTagNameMap[K_10_2];
            <K_11_2 extends keyof MathMLElementTagNameMap>(selectors: K_11_2): MathMLElementTagNameMap[K_11_2];
            <K_12_2 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_2): HTMLElementDeprecatedTagNameMap[K_12_2];
            <E_1_2 extends Element = Element>(selectors: string): E_1_2;
        } & {
            <K_9_3 extends keyof HTMLElementTagNameMap>(selectors: K_9_3): HTMLElementTagNameMap[K_9_3];
            <K_10_3 extends keyof SVGElementTagNameMap>(selectors: K_10_3): SVGElementTagNameMap[K_10_3];
            <K_11_3 extends keyof MathMLElementTagNameMap>(selectors: K_11_3): MathMLElementTagNameMap[K_11_3];
            <K_12_3 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_3): HTMLElementDeprecatedTagNameMap[K_12_3];
            <E_1_3 extends Element = Element>(selectors: string): E_1_3;
        } & {
            <K_9_4 extends keyof HTMLElementTagNameMap>(selectors: K_9_4): HTMLElementTagNameMap[K_9_4];
            <K_10_4 extends keyof SVGElementTagNameMap>(selectors: K_10_4): SVGElementTagNameMap[K_10_4];
            <K_11_4 extends keyof MathMLElementTagNameMap>(selectors: K_11_4): MathMLElementTagNameMap[K_11_4];
            <K_12_4 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_4): HTMLElementDeprecatedTagNameMap[K_12_4];
            <E_1_4 extends Element = Element>(selectors: string): E_1_4;
        } & {
            <K_9_5 extends keyof HTMLElementTagNameMap>(selectors: K_9_5): HTMLElementTagNameMap[K_9_5];
            <K_10_5 extends keyof SVGElementTagNameMap>(selectors: K_10_5): SVGElementTagNameMap[K_10_5];
            <K_11_5 extends keyof MathMLElementTagNameMap>(selectors: K_11_5): MathMLElementTagNameMap[K_11_5];
            <K_12_5 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_5): HTMLElementDeprecatedTagNameMap[K_12_5];
            <E_1_5 extends Element = Element>(selectors: string): E_1_5;
        } & {
            <K_9_6 extends keyof HTMLElementTagNameMap>(selectors: K_9_6): HTMLElementTagNameMap[K_9_6];
            <K_10_6 extends keyof SVGElementTagNameMap>(selectors: K_10_6): SVGElementTagNameMap[K_10_6];
            <K_11_6 extends keyof MathMLElementTagNameMap>(selectors: K_11_6): MathMLElementTagNameMap[K_11_6];
            <K_12_6 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_6): HTMLElementDeprecatedTagNameMap[K_12_6];
            <E_1_6 extends Element = Element>(selectors: string): E_1_6;
        } & {
            <K_9_7 extends keyof HTMLElementTagNameMap>(selectors: K_9_7): HTMLElementTagNameMap[K_9_7];
            <K_10_7 extends keyof SVGElementTagNameMap>(selectors: K_10_7): SVGElementTagNameMap[K_10_7];
            <K_11_7 extends keyof MathMLElementTagNameMap>(selectors: K_11_7): MathMLElementTagNameMap[K_11_7];
            <K_12_7 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_7): HTMLElementDeprecatedTagNameMap[K_12_7];
            <E_1_7 extends Element = Element>(selectors: string): E_1_7;
        } & {
            <K_9_8 extends keyof HTMLElementTagNameMap>(selectors: K_9_8): HTMLElementTagNameMap[K_9_8];
            <K_10_8 extends keyof SVGElementTagNameMap>(selectors: K_10_8): SVGElementTagNameMap[K_10_8];
            <K_11_8 extends keyof MathMLElementTagNameMap>(selectors: K_11_8): MathMLElementTagNameMap[K_11_8];
            <K_12_8 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_8): HTMLElementDeprecatedTagNameMap[K_12_8];
            <E_1_8 extends Element = Element>(selectors: string): E_1_8;
        } & {
            <K_25 extends keyof HTMLElementTagNameMap>(selectors: K_25): HTMLElementTagNameMap[K_25];
            <K_26 extends keyof SVGElementTagNameMap>(selectors: K_26): SVGElementTagNameMap[K_26];
            <K_27 extends keyof MathMLElementTagNameMap>(selectors: K_27): MathMLElementTagNameMap[K_27];
            <K_28 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_28): HTMLElementDeprecatedTagNameMap[K_28];
            <E_17 extends Element = Element>(selectors: string): E_17;
        } & {
            <K_9_9 extends keyof HTMLElementTagNameMap>(selectors: K_9_9): HTMLElementTagNameMap[K_9_9];
            <K_10_9 extends keyof SVGElementTagNameMap>(selectors: K_10_9): SVGElementTagNameMap[K_10_9];
            <K_11_9 extends keyof MathMLElementTagNameMap>(selectors: K_11_9): MathMLElementTagNameMap[K_11_9];
            <K_12_9 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_9): HTMLElementDeprecatedTagNameMap[K_12_9];
            <E_1_9 extends Element = Element>(selectors: string): E_1_9;
        } & {
            <K_9_10 extends keyof HTMLElementTagNameMap>(selectors: K_9_10): HTMLElementTagNameMap[K_9_10];
            <K_10_10 extends keyof SVGElementTagNameMap>(selectors: K_10_10): SVGElementTagNameMap[K_10_10];
            <K_11_10 extends keyof MathMLElementTagNameMap>(selectors: K_11_10): MathMLElementTagNameMap[K_11_10];
            <K_12_10 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_10): HTMLElementDeprecatedTagNameMap[K_12_10];
            <E_1_10 extends Element = Element>(selectors: string): E_1_10;
        } & {
            <K_9_11 extends keyof HTMLElementTagNameMap>(selectors: K_9_11): HTMLElementTagNameMap[K_9_11];
            <K_10_11 extends keyof SVGElementTagNameMap>(selectors: K_10_11): SVGElementTagNameMap[K_10_11];
            <K_11_11 extends keyof MathMLElementTagNameMap>(selectors: K_11_11): MathMLElementTagNameMap[K_11_11];
            <K_12_11 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_11): HTMLElementDeprecatedTagNameMap[K_12_11];
            <E_1_11 extends Element = Element>(selectors: string): E_1_11;
        } & {
            <K_9_12 extends keyof HTMLElementTagNameMap>(selectors: K_9_12): HTMLElementTagNameMap[K_9_12];
            <K_10_12 extends keyof SVGElementTagNameMap>(selectors: K_10_12): SVGElementTagNameMap[K_10_12];
            <K_11_12 extends keyof MathMLElementTagNameMap>(selectors: K_11_12): MathMLElementTagNameMap[K_11_12];
            <K_12_12 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_12): HTMLElementDeprecatedTagNameMap[K_12_12];
            <E_1_12 extends Element = Element>(selectors: string): E_1_12;
        } & {
            <K_9_13 extends keyof HTMLElementTagNameMap>(selectors: K_9_13): HTMLElementTagNameMap[K_9_13];
            <K_10_13 extends keyof SVGElementTagNameMap>(selectors: K_10_13): SVGElementTagNameMap[K_10_13];
            <K_11_13 extends keyof MathMLElementTagNameMap>(selectors: K_11_13): MathMLElementTagNameMap[K_11_13];
            <K_12_13 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_13): HTMLElementDeprecatedTagNameMap[K_12_13];
            <E_1_13 extends Element = Element>(selectors: string): E_1_13;
        } & {
            <K_9_14 extends keyof HTMLElementTagNameMap>(selectors: K_9_14): HTMLElementTagNameMap[K_9_14];
            <K_10_14 extends keyof SVGElementTagNameMap>(selectors: K_10_14): SVGElementTagNameMap[K_10_14];
            <K_11_14 extends keyof MathMLElementTagNameMap>(selectors: K_11_14): MathMLElementTagNameMap[K_11_14];
            <K_12_14 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_14): HTMLElementDeprecatedTagNameMap[K_12_14];
            <E_1_14 extends Element = Element>(selectors: string): E_1_14;
        } & {
            <K_9_15 extends keyof HTMLElementTagNameMap>(selectors: K_9_15): HTMLElementTagNameMap[K_9_15];
            <K_10_15 extends keyof SVGElementTagNameMap>(selectors: K_10_15): SVGElementTagNameMap[K_10_15];
            <K_11_15 extends keyof MathMLElementTagNameMap>(selectors: K_11_15): MathMLElementTagNameMap[K_11_15];
            <K_12_15 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_15): HTMLElementDeprecatedTagNameMap[K_12_15];
            <E_1_15 extends Element = Element>(selectors: string): E_1_15;
        } & {
            <K_9_16 extends keyof HTMLElementTagNameMap>(selectors: K_9_16): HTMLElementTagNameMap[K_9_16];
            <K_10_16 extends keyof SVGElementTagNameMap>(selectors: K_10_16): SVGElementTagNameMap[K_10_16];
            <K_11_16 extends keyof MathMLElementTagNameMap>(selectors: K_11_16): MathMLElementTagNameMap[K_11_16];
            <K_12_16 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_12_16): HTMLElementDeprecatedTagNameMap[K_12_16];
            <E_1_16 extends Element = Element>(selectors: string): E_1_16;
        };
        querySelectorAll: {
            <K_13_1 extends keyof HTMLElementTagNameMap>(selectors: K_13_1): NodeListOf<HTMLElementTagNameMap[K_13_1]>;
            <K_14_1 extends keyof SVGElementTagNameMap>(selectors: K_14_1): NodeListOf<SVGElementTagNameMap[K_14_1]>;
            <K_15_1 extends keyof MathMLElementTagNameMap>(selectors: K_15_1): NodeListOf<MathMLElementTagNameMap[K_15_1]>;
            <K_16_1 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_1): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_1]>;
            <E_2_1 extends Element = Element>(selectors: string): NodeListOf<E_2_1>;
        } & {
            <K_13_2 extends keyof HTMLElementTagNameMap>(selectors: K_13_2): NodeListOf<HTMLElementTagNameMap[K_13_2]>;
            <K_14_2 extends keyof SVGElementTagNameMap>(selectors: K_14_2): NodeListOf<SVGElementTagNameMap[K_14_2]>;
            <K_15_2 extends keyof MathMLElementTagNameMap>(selectors: K_15_2): NodeListOf<MathMLElementTagNameMap[K_15_2]>;
            <K_16_2 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_2): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_2]>;
            <E_2_2 extends Element = Element>(selectors: string): NodeListOf<E_2_2>;
        } & {
            <K_13_3 extends keyof HTMLElementTagNameMap>(selectors: K_13_3): NodeListOf<HTMLElementTagNameMap[K_13_3]>;
            <K_14_3 extends keyof SVGElementTagNameMap>(selectors: K_14_3): NodeListOf<SVGElementTagNameMap[K_14_3]>;
            <K_15_3 extends keyof MathMLElementTagNameMap>(selectors: K_15_3): NodeListOf<MathMLElementTagNameMap[K_15_3]>;
            <K_16_3 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_3): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_3]>;
            <E_2_3 extends Element = Element>(selectors: string): NodeListOf<E_2_3>;
        } & {
            <K_13_4 extends keyof HTMLElementTagNameMap>(selectors: K_13_4): NodeListOf<HTMLElementTagNameMap[K_13_4]>;
            <K_14_4 extends keyof SVGElementTagNameMap>(selectors: K_14_4): NodeListOf<SVGElementTagNameMap[K_14_4]>;
            <K_15_4 extends keyof MathMLElementTagNameMap>(selectors: K_15_4): NodeListOf<MathMLElementTagNameMap[K_15_4]>;
            <K_16_4 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_4): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_4]>;
            <E_2_4 extends Element = Element>(selectors: string): NodeListOf<E_2_4>;
        } & {
            <K_13_5 extends keyof HTMLElementTagNameMap>(selectors: K_13_5): NodeListOf<HTMLElementTagNameMap[K_13_5]>;
            <K_14_5 extends keyof SVGElementTagNameMap>(selectors: K_14_5): NodeListOf<SVGElementTagNameMap[K_14_5]>;
            <K_15_5 extends keyof MathMLElementTagNameMap>(selectors: K_15_5): NodeListOf<MathMLElementTagNameMap[K_15_5]>;
            <K_16_5 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_5): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_5]>;
            <E_2_5 extends Element = Element>(selectors: string): NodeListOf<E_2_5>;
        } & {
            <K_13_6 extends keyof HTMLElementTagNameMap>(selectors: K_13_6): NodeListOf<HTMLElementTagNameMap[K_13_6]>;
            <K_14_6 extends keyof SVGElementTagNameMap>(selectors: K_14_6): NodeListOf<SVGElementTagNameMap[K_14_6]>;
            <K_15_6 extends keyof MathMLElementTagNameMap>(selectors: K_15_6): NodeListOf<MathMLElementTagNameMap[K_15_6]>;
            <K_16_6 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_6): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_6]>;
            <E_2_6 extends Element = Element>(selectors: string): NodeListOf<E_2_6>;
        } & {
            <K_13_7 extends keyof HTMLElementTagNameMap>(selectors: K_13_7): NodeListOf<HTMLElementTagNameMap[K_13_7]>;
            <K_14_7 extends keyof SVGElementTagNameMap>(selectors: K_14_7): NodeListOf<SVGElementTagNameMap[K_14_7]>;
            <K_15_7 extends keyof MathMLElementTagNameMap>(selectors: K_15_7): NodeListOf<MathMLElementTagNameMap[K_15_7]>;
            <K_16_7 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_7): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_7]>;
            <E_2_7 extends Element = Element>(selectors: string): NodeListOf<E_2_7>;
        } & {
            <K_13_8 extends keyof HTMLElementTagNameMap>(selectors: K_13_8): NodeListOf<HTMLElementTagNameMap[K_13_8]>;
            <K_14_8 extends keyof SVGElementTagNameMap>(selectors: K_14_8): NodeListOf<SVGElementTagNameMap[K_14_8]>;
            <K_15_8 extends keyof MathMLElementTagNameMap>(selectors: K_15_8): NodeListOf<MathMLElementTagNameMap[K_15_8]>;
            <K_16_8 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_8): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_8]>;
            <E_2_8 extends Element = Element>(selectors: string): NodeListOf<E_2_8>;
        } & {
            <K_29 extends keyof HTMLElementTagNameMap>(selectors: K_29): NodeListOf<HTMLElementTagNameMap[K_29]>;
            <K_30 extends keyof SVGElementTagNameMap>(selectors: K_30): NodeListOf<SVGElementTagNameMap[K_30]>;
            <K_31 extends keyof MathMLElementTagNameMap>(selectors: K_31): NodeListOf<MathMLElementTagNameMap[K_31]>;
            <K_32 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_32): NodeListOf<HTMLElementDeprecatedTagNameMap[K_32]>;
            <E_18 extends Element = Element>(selectors: string): NodeListOf<E_18>;
        } & {
            <K_13_9 extends keyof HTMLElementTagNameMap>(selectors: K_13_9): NodeListOf<HTMLElementTagNameMap[K_13_9]>;
            <K_14_9 extends keyof SVGElementTagNameMap>(selectors: K_14_9): NodeListOf<SVGElementTagNameMap[K_14_9]>;
            <K_15_9 extends keyof MathMLElementTagNameMap>(selectors: K_15_9): NodeListOf<MathMLElementTagNameMap[K_15_9]>;
            <K_16_9 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_9): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_9]>;
            <E_2_9 extends Element = Element>(selectors: string): NodeListOf<E_2_9>;
        } & {
            <K_13_10 extends keyof HTMLElementTagNameMap>(selectors: K_13_10): NodeListOf<HTMLElementTagNameMap[K_13_10]>;
            <K_14_10 extends keyof SVGElementTagNameMap>(selectors: K_14_10): NodeListOf<SVGElementTagNameMap[K_14_10]>;
            <K_15_10 extends keyof MathMLElementTagNameMap>(selectors: K_15_10): NodeListOf<MathMLElementTagNameMap[K_15_10]>;
            <K_16_10 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_10): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_10]>;
            <E_2_10 extends Element = Element>(selectors: string): NodeListOf<E_2_10>;
        } & {
            <K_13_11 extends keyof HTMLElementTagNameMap>(selectors: K_13_11): NodeListOf<HTMLElementTagNameMap[K_13_11]>;
            <K_14_11 extends keyof SVGElementTagNameMap>(selectors: K_14_11): NodeListOf<SVGElementTagNameMap[K_14_11]>;
            <K_15_11 extends keyof MathMLElementTagNameMap>(selectors: K_15_11): NodeListOf<MathMLElementTagNameMap[K_15_11]>;
            <K_16_11 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_11): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_11]>;
            <E_2_11 extends Element = Element>(selectors: string): NodeListOf<E_2_11>;
        } & {
            <K_13_12 extends keyof HTMLElementTagNameMap>(selectors: K_13_12): NodeListOf<HTMLElementTagNameMap[K_13_12]>;
            <K_14_12 extends keyof SVGElementTagNameMap>(selectors: K_14_12): NodeListOf<SVGElementTagNameMap[K_14_12]>;
            <K_15_12 extends keyof MathMLElementTagNameMap>(selectors: K_15_12): NodeListOf<MathMLElementTagNameMap[K_15_12]>;
            <K_16_12 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_12): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_12]>;
            <E_2_12 extends Element = Element>(selectors: string): NodeListOf<E_2_12>;
        } & {
            <K_13_13 extends keyof HTMLElementTagNameMap>(selectors: K_13_13): NodeListOf<HTMLElementTagNameMap[K_13_13]>;
            <K_14_13 extends keyof SVGElementTagNameMap>(selectors: K_14_13): NodeListOf<SVGElementTagNameMap[K_14_13]>;
            <K_15_13 extends keyof MathMLElementTagNameMap>(selectors: K_15_13): NodeListOf<MathMLElementTagNameMap[K_15_13]>;
            <K_16_13 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_13): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_13]>;
            <E_2_13 extends Element = Element>(selectors: string): NodeListOf<E_2_13>;
        } & {
            <K_13_14 extends keyof HTMLElementTagNameMap>(selectors: K_13_14): NodeListOf<HTMLElementTagNameMap[K_13_14]>;
            <K_14_14 extends keyof SVGElementTagNameMap>(selectors: K_14_14): NodeListOf<SVGElementTagNameMap[K_14_14]>;
            <K_15_14 extends keyof MathMLElementTagNameMap>(selectors: K_15_14): NodeListOf<MathMLElementTagNameMap[K_15_14]>;
            <K_16_14 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_14): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_14]>;
            <E_2_14 extends Element = Element>(selectors: string): NodeListOf<E_2_14>;
        } & {
            <K_13_15 extends keyof HTMLElementTagNameMap>(selectors: K_13_15): NodeListOf<HTMLElementTagNameMap[K_13_15]>;
            <K_14_15 extends keyof SVGElementTagNameMap>(selectors: K_14_15): NodeListOf<SVGElementTagNameMap[K_14_15]>;
            <K_15_15 extends keyof MathMLElementTagNameMap>(selectors: K_15_15): NodeListOf<MathMLElementTagNameMap[K_15_15]>;
            <K_16_15 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_15): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_15]>;
            <E_2_15 extends Element = Element>(selectors: string): NodeListOf<E_2_15>;
        } & {
            <K_13_16 extends keyof HTMLElementTagNameMap>(selectors: K_13_16): NodeListOf<HTMLElementTagNameMap[K_13_16]>;
            <K_14_16 extends keyof SVGElementTagNameMap>(selectors: K_14_16): NodeListOf<SVGElementTagNameMap[K_14_16]>;
            <K_15_16 extends keyof MathMLElementTagNameMap>(selectors: K_15_16): NodeListOf<MathMLElementTagNameMap[K_15_16]>;
            <K_16_16 extends keyof HTMLElementDeprecatedTagNameMap>(selectors: K_16_16): NodeListOf<HTMLElementDeprecatedTagNameMap[K_16_16]>;
            <E_2_16 extends Element = Element>(selectors: string): NodeListOf<E_2_16>;
        };
        replaceChildren: ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void) & ((...nodes: (string | Node)[]) => void);
        readonly assignedSlot: HTMLSlotElement;
        readonly attributeStyleMap: StylePropertyMap;
        readonly style: CSSStyleDeclaration;
        contentEditable: string;
        enterKeyHint: string;
        inputMode: string;
        readonly isContentEditable: boolean;
        onabort: ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any);
        onanimationcancel: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any);
        onanimationend: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any);
        onanimationiteration: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any);
        onanimationstart: ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any) & ((this: GlobalEventHandlers, ev: AnimationEvent) => any);
        onauxclick: ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any);
        onbeforeinput: ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any) & ((this: GlobalEventHandlers, ev: InputEvent) => any);
        onbeforetoggle: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onblur: ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any);
        oncancel: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        oncanplay: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        oncanplaythrough: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onchange: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onclick: ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any);
        onclose: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        oncontextmenu: ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any);
        oncopy: ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any);
        oncuechange: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        oncut: ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any);
        ondblclick: ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any);
        ondrag: ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any);
        ondragend: ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any);
        ondragenter: ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any);
        ondragleave: ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any);
        ondragover: ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any);
        ondragstart: ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any);
        ondrop: ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any) & ((this: GlobalEventHandlers, ev: DragEvent) => any);
        ondurationchange: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onemptied: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onended: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onerror: OnErrorEventHandlerNonNull;
        onfocus: ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any) & ((this: GlobalEventHandlers, ev: FocusEvent) => any);
        onformdata: ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any) & ((this: GlobalEventHandlers, ev: FormDataEvent) => any);
        ongotpointercapture: ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any);
        oninput: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        oninvalid: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onkeydown: ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any);
        onkeypress: ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any);
        onkeyup: ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any) & ((this: GlobalEventHandlers, ev: KeyboardEvent) => any);
        onload: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onloadeddata: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onloadedmetadata: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onloadstart: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onlostpointercapture: ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any);
        onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any);
        onmouseenter: ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any);
        onmouseleave: ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any);
        onmousemove: ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any);
        onmouseout: ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any);
        onmouseover: ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any);
        onmouseup: ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any) & ((this: GlobalEventHandlers, ev: MouseEvent) => any);
        onpaste: ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any) & ((this: GlobalEventHandlers, ev: ClipboardEvent) => any);
        onpause: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onplay: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onplaying: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onpointercancel: ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any);
        onpointerdown: ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any);
        onpointerenter: ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any);
        onpointerleave: ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any);
        onpointermove: ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any);
        onpointerout: ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any);
        onpointerover: ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any);
        onpointerup: ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any) & ((this: GlobalEventHandlers, ev: PointerEvent) => any);
        onprogress: ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any) & ((this: GlobalEventHandlers, ev: ProgressEvent<EventTarget>) => any);
        onratechange: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onreset: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onresize: ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any) & ((this: GlobalEventHandlers, ev: UIEvent) => any);
        onscroll: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onscrollend: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onsecuritypolicyviolation: ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any) & ((this: GlobalEventHandlers, ev: SecurityPolicyViolationEvent) => any);
        onseeked: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onseeking: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onselect: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onselectionchange: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onselectstart: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onslotchange: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onstalled: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onsubmit: ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any) & ((this: GlobalEventHandlers, ev: SubmitEvent) => any);
        onsuspend: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        ontimeupdate: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        ontoggle: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        ontouchcancel?: ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any);
        ontouchend?: ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any);
        ontouchmove?: ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any);
        ontouchstart?: ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any) & ((this: GlobalEventHandlers, ev: TouchEvent) => any);
        ontransitioncancel: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any);
        ontransitionend: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any);
        ontransitionrun: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any);
        ontransitionstart: ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any) & ((this: GlobalEventHandlers, ev: TransitionEvent) => any);
        onvolumechange: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onwaiting: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onwebkitanimationend: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onwebkitanimationiteration: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onwebkitanimationstart: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onwebkittransitionend: ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any) & ((this: GlobalEventHandlers, ev: Event) => any);
        onwheel: ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any) & ((this: GlobalEventHandlers, ev: WheelEvent) => any);
        autofocus: boolean;
        readonly dataset: DOMStringMap;
        nonce: string;
        tabIndex: number;
        blur: (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void);
        focus: ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void) & ((options?: FocusOptions) => void);
        "__#29655@#NotificationDriverWrapper": new (refOrRefFn: Element | (() => HTMLElement), config: {
            logger: {
                error(...data: any[]): void;
                warn(...data: any[]): void;
                info(...data: any[]): void;
                debug(...data: any[]): void;
            };
        }) => {
            setContent(templateOrString: string | HTMLTemplateElement): void;
            nodeName: string;
            close(): void;
            show(): void;
            remove(): void;
            "__#29651@#private": any;
            logger: {
                error(...data: any[]): void;
                warn(...data: any[]): void;
                info(...data: any[]): void;
                debug(...data: any[]): void;
            };
            readonly asyncEle: Promise<Element>;
            readonly ele: Element;
        };
        createNotification(config?: {
            mode: "success" | "error";
            duration: number;
            'has-close-button'?: boolean;
            position?: "top-stretch" | "top-start" | "top-center" | "top-end" | "middle" | "bottom-start" | "bottom-center" | "bottom-end" | "bottom-stretch";
            size: "xs" | "sm" | "md" | "lg";
            bordered?: boolean;
        } & {
            [key: string]: string | number | boolean;
        }): {
            setContent(templateOrString: string | HTMLTemplateElement): void;
            nodeName: string;
            close(): void;
            show(): void;
            remove(): void;
            "__#29651@#private": any;
            logger: {
                error(...data: any[]): void;
                warn(...data: any[]): void;
                info(...data: any[]): void;
                debug(...data: any[]): void;
            };
            readonly asyncEle: Promise<Element>;
            readonly ele: Element;
        };
        "__#29650@#getComponentsVersion": (() => Promise<string>) & (() => Promise<string>) & (() => Promise<string>) & (() => Promise<string>);
        "__#29650@#descopeUi": Promise<any>;
        readonly descopeUi: Promise<any>;
        "__#29650@#loadDescopeUiComponent": ((componentName: string) => Promise<any>) & ((componentName: string) => Promise<any>) & ((componentName: string) => Promise<any>) & ((componentName: string) => Promise<any>);
        "__#29650@#getDescopeUi": (() => Promise<any>) & (() => Promise<any>) & (() => Promise<any>) & (() => Promise<any>);
        loadDescopeUiComponents: ((templateOrComponentNames: string[] | HTMLTemplateElement) => Promise<any[]>) & ((templateOrComponentNames: string[] | HTMLTemplateElement) => Promise<any[]>) & ((templateOrComponentNames: string[] | HTMLTemplateElement) => Promise<any[]>) & ((templateOrComponentNames: string[] | HTMLTemplateElement) => Promise<any[]>);
        readonly baseCdnUrl: string;
        injectNpmLib: ((libName: string, version: string, filePath?: string, overrides?: string[]) => Promise<{
            id: string;
            url: URL;
        }>) & ((libName: string, version: string, filePath?: string, overrides?: string[]) => Promise<{
            id: string;
            url: URL;
        }>) & ((libName: string, version: string, filePath?: string, overrides?: string[]) => Promise<{
            id: string;
            url: URL;
        }>) & ((libName: string, version: string, filePath?: string, overrides?: string[]) => Promise<{
            id: string;
            url: URL;
        }>);
        "__#29640@#logger": _descope_sdk_mixins.Logger;
        "__#29640@#wrapLogger": ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger) & ((logger: Partial<_descope_sdk_mixins.Logger>) => _descope_sdk_mixins.Logger);
        logger: _descope_sdk_mixins.Logger;
        onLogEvent: ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", data: any[]) => void) & ((logLevel: "error" | "warn" | "info" | "debug", args: any[]) => void);
        readonly config: Promise<_descope_sdk_mixins.Config>;
        "__#29646@#configCacheClear": (() => void) & (() => void) & (() => void) & (() => void) & (() => void);
        "__#29646@#_configResource": Promise<_descope_sdk_mixins.Config>;
        "__#29646@#fetchConfig": (() => Promise<_descope_sdk_mixins.Config>) & (() => Promise<_descope_sdk_mixins.Config>) & (() => Promise<_descope_sdk_mixins.Config>) & (() => Promise<_descope_sdk_mixins.Config>) & (() => Promise<_descope_sdk_mixins.Config>);
        "__#29645@#callbacks": Map<string, () => void> & Map<string, () => void> & Map<string, () => void> & Map<string, () => void> & Map<string, () => void>;
        onReset: ((sectionId: string, callback: () => void | Promise<void>) => () => void) & ((sectionId: string, callback: () => void | Promise<void>) => () => void) & ((sectionId: string, callback: () => void | Promise<void>) => () => void) & ((sectionId: string, callback: () => void | Promise<void>) => () => void) & ((sectionId: string, callback: () => void | Promise<void>) => () => void);
        reset: ((...sectionIds: string[]) => Promise<void>) & ((...sectionIds: string[]) => Promise<void>) & ((...sectionIds: string[]) => Promise<void>) & ((...sectionIds: string[]) => Promise<void>) & ((...sectionIds: string[]) => Promise<void>);
        "__#29643@#handleError": ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void) & ((attrName: string, newValue: string) => void);
        "__#29642@#observeMappings": {};
        observeAttribute: ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any) & ((attrName: string, onAttrChange: (attrName: string, value: string) => void) => () => any);
        observeAttributes: ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void) & ((attrs: string[], cb: (attrName: string, value: string) => void) => () => void);
        "__#29644@#lastBaseUrl"?: string;
        "__#29644@#workingBaseUrl"?: string;
        "__#29644@#getResourceUrls": ((filename: string) => (URL & {
            baseUrl: string;
        }) | (URL & {
            baseUrl: string;
        })[]) & ((filename: string) => (URL & {
            baseUrl: string;
        }) | (URL & {
            baseUrl: string;
        })[]) & ((filename: string) => (URL & {
            baseUrl: string;
        }) | (URL & {
            baseUrl: string;
        })[]) & ((filename: string) => (URL & {
            baseUrl: string;
        }) | (URL & {
            baseUrl: string;
        })[]) & ((filename: string) => (URL & {
            baseUrl: string;
        }) | (URL & {
            baseUrl: string;
        })[]) & ((filename: string) => (URL & {
            baseUrl: string;
        }) | (URL & {
            baseUrl: string;
        })[]) & ((filename: string) => (URL & {
            baseUrl: string;
        }) | (URL & {
            baseUrl: string;
        })[]);
        fetchStaticResource: (<F extends "text" | "json">(filename: string, format: F) => Promise<{
            body: F extends "json" ? Record<string, any> : string;
            headers: Record<string, string>;
        }>) & (<F_1 extends "text" | "json">(filename: string, format: F_1) => Promise<{
            body: F_1 extends "json" ? Record<string, any> : string;
            headers: Record<string, string>;
        }>) & (<F_2 extends "text" | "json">(filename: string, format: F_2) => Promise<{
            body: F_2 extends "json" ? Record<string, any> : string;
            headers: Record<string, string>;
        }>) & (<F_3 extends "text" | "json">(filename: string, format: F_3) => Promise<{
            body: F_3 extends "json" ? Record<string, any> : string;
            headers: Record<string, string>;
        }>) & (<F_4 extends "text" | "json">(filename: string, format: F_4) => Promise<{
            body: F_4 extends "json" ? Record<string, any> : string;
            headers: Record<string, string>;
        }>) & (<F_1_1 extends "text" | "json">(filename: string, format: F_1_1) => Promise<{
            body: F_1_1 extends "json" ? Record<string, any> : string;
            headers: Record<string, string>;
        }>) & (<F_2_1 extends "text" | "json">(filename: string, format: F_2_1) => Promise<{
            body: F_2_1 extends "json" ? Record<string, any> : string;
            headers: Record<string, string>;
        }>);
        readonly baseStaticUrl: string;
        readonly baseUrl: string;
        readonly projectId: string;
        contentRootElement: HTMLElement;
        rootElement: HTMLElement;
        injectStyle: ((cssString: string, { prepend }?: {
            prepend?: boolean;
        }) => CSSStyleSheet | {
            styleEle: HTMLStyleElement;
            ref: HTMLElement | ShadowRoot;
            replaceSync(cssString: string): void;
            readonly cssRules: CSSRuleList;
        }) & ((cssString: string, { prepend }?: {
            prepend?: boolean;
        }) => CSSStyleSheet | {
            styleEle: HTMLStyleElement;
            ref: HTMLElement | ShadowRoot;
            replaceSync(cssString: string): void;
            readonly cssRules: CSSRuleList;
        }) & ((cssString: string, { prepend }?: {
            prepend?: boolean;
        }) => CSSStyleSheet | {
            styleEle: HTMLStyleElement;
            ref: HTMLElement | ShadowRoot;
            replaceSync(cssString: string): void;
            readonly cssRules: CSSRuleList;
        }) & ((cssString: string, { prepend }?: {
            prepend?: boolean;
        }) => CSSStyleSheet | {
            styleEle: HTMLStyleElement;
            ref: HTMLElement | ShadowRoot;
            replaceSync(cssString: string): void;
            readonly cssRules: CSSRuleList;
        }) & ((cssString: string, { prepend }?: {
            prepend?: boolean;
        }) => CSSStyleSheet | {
            styleEle: HTMLStyleElement;
            ref: HTMLElement | ShadowRoot;
            replaceSync(cssString: string): void;
            readonly cssRules: CSSRuleList;
        });
        "__#29647@#setNonce": (() => void) & (() => void) & (() => void) & (() => void) & (() => void);
        state: State;
        "__#5@#api": {
            accesskey: {
                search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                deleteBatch: (ids: string[]) => Promise<any>;
                create: (config: CreateAccessKeyConfig) => Promise<{
                    cleartext: string;
                    key: AccessKey;
                }>;
                activate: (ids: string[]) => Promise<any>;
                deactivate: (ids: string[]) => Promise<any>;
            };
            tenant: {
                getTenantRoles: () => Promise<{
                    roles: Role[];
                }>;
            };
        };
        "__#5@#createSdk": (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void) & (() => void);
        readonly tenantId: string;
        readonly widgetId: string;
        readonly mock: string;
        readonly api: {
            accesskey: {
                search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                deleteBatch: (ids: string[]) => Promise<any>;
                create: (config: CreateAccessKeyConfig) => Promise<{
                    cleartext: string;
                    key: AccessKey;
                }>;
                activate: (ids: string[]) => Promise<any>;
                deactivate: (ids: string[]) => Promise<any>;
            };
            tenant: {
                getTenantRoles: () => Promise<{
                    roles: Role[];
                }>;
            };
        };
        readonly refreshCookieName: string;
        actions: _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        } & _reduxjs_toolkit.CaseReducerActions<{
            setSelectedAccessKeysIds: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }, { payload }: {
                payload: any;
                type: string;
            }) => void;
            clearNotifications: (state: {
                accessKeysList: {
                    data: {
                        id: string;
                        name: string;
                        roleNames: string[];
                        permittedIps: string[];
                        status: string;
                        createdTime: number;
                        expireTime: number;
                        expireTimeFormatted?: string;
                        createdTimeFormatted?: string;
                        createdBy: string;
                        clientId: string;
                        editable: boolean;
                        boundUserId: string;
                    }[];
                    loading: boolean;
                    error: unknown;
                };
                createAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                activateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deactivateAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                deleteAccessKey: {
                    loading: boolean;
                    error: unknown;
                };
                tenantRoles: {
                    loading: boolean;
                    error: unknown;
                    data: {
                        name: string;
                        description: string;
                        permissionNames: string[];
                        createdTime: Date;
                        tenantId: string;
                    }[];
                };
                searchParams: {
                    text: string;
                    sort: {
                        field: string;
                        desc: boolean;
                    }[];
                };
                selectedAccessKeysIds: string[];
                notifications: {
                    type: "success" | "error";
                    msg: string;
                }[];
            }) => void;
        }, "widget"> & {
            searchAccessKeys: _reduxjs_toolkit.AsyncThunk<any, void | SearchAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            createAccessKey: _reduxjs_toolkit.AsyncThunk<any, CreateAccessKeyConfig, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            activateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deactivateAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            deleteAccessKeys: _reduxjs_toolkit.AsyncThunk<any, string[], {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
            getTenantRoles: _reduxjs_toolkit.AsyncThunk<any, never, {
                extra: {
                    api: {
                        accesskey: {
                            search: (config: SearchAccessKeyConfig) => Promise<AccessKey[]>;
                            deleteBatch: (ids: string[]) => Promise<any>;
                            create: (config: CreateAccessKeyConfig) => Promise<{
                                cleartext: string;
                                key: AccessKey;
                            }>;
                            activate: (ids: string[]) => Promise<any>;
                            deactivate: (ids: string[]) => Promise<any>;
                        };
                        tenant: {
                            getTenantRoles: () => Promise<{
                                roles: Role[];
                            }>;
                        };
                    };
                };
                state?: unknown;
                dispatch?: redux.Dispatch<redux.UnknownAction>;
                rejectValue?: unknown;
                serializedErrorType?: unknown;
                pendingMeta?: unknown;
                fulfilledMeta?: unknown;
                rejectedMeta?: unknown;
            }>;
        };
        subscribe: <SelectorR = State>(cb: (state: SelectorR) => void, selector?: (state: {
            accessKeysList: {
                data: {
                    id: string;
                    name: string;
                    roleNames: string[];
                    permittedIps: string[];
                    status: string;
                    createdTime: number;
                    expireTime: number;
                    expireTimeFormatted?: string;
                    createdTimeFormatted?: string;
                    createdBy: string;
                    clientId: string;
                    editable: boolean;
                    boundUserId: string;
                }[];
                loading: boolean;
                error: unknown;
            };
            createAccessKey: {
                loading: boolean;
                error: unknown;
            };
            activateAccessKey: {
                loading: boolean;
                error: unknown;
            };
            deactivateAccessKey: {
                loading: boolean;
                error: unknown;
            };
            deleteAccessKey: {
                loading: boolean;
                error: unknown;
            };
            tenantRoles: {
                loading: boolean;
                error: unknown;
                data: {
                    name: string;
                    description: string;
                    permissionNames: string[];
                    createdTime: Date;
                    tenantId: string;
                }[];
            };
            searchParams: {
                text: string;
                sort: {
                    field: string;
                    desc: boolean;
                }[];
            };
            selectedAccessKeysIds: string[];
            notifications: {
                type: "success" | "error";
                msg: string;
            }[];
        }) => SelectorR) => redux.Unsubscribe;
        deactivateButton: _descope_sdk_component_drivers.ButtonDriver;
        "__#14@#initDeactivateButton"(): void;
        "__#14@#onIsAccessKeySelectedUpdate": (canModify: boolean) => void;
        onWidgetRootReady: (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
        deactivateAccessKeysModal: _descope_sdk_component_drivers.ModalDriver;
        "__#13@#initDeactivateAccessKeyModal"(): Promise<void>;
        "__#6@#initWidgetRoot": (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>) & (() => Promise<void>);
        fetchWidgetPage: ((filename: string) => Promise<string>) & ((filename: string) => Promise<string>) & ((filename: string) => Promise<string>) & ((filename: string) => Promise<string>) & ((filename: string) => Promise<string>) & ((filename: string) => Promise<string>) & ((filename: string) => Promise<string>) & ((filename: string) => Promise<string>) & ((filename: string) => Promise<string>) & ((filename: string) => Promise<string>) & ((filename: string) => Promise<string>);
        "__#29654@#ModalDriverWrapper": new (refOrRefFn: Element | (() => HTMLElement), config: {
            logger: {
                error(...data: any[]): void;
                warn(...data: any[]): void;
                info(...data: any[]): void;
                debug(...data: any[]): void;
            };
        }) => {
            setContent(template: HTMLTemplateElement): void;
            "__#29653@#private": any;
            beforeOpen: () => void | Promise<void>;
            afterClose: () => void;
            nodeName: string;
            close(): void;
            open(): Promise<void>;
            reset(): void;
            remove(): void;
            "__#29651@#private": any;
            logger: {
                error(...data: any[]): void;
                warn(...data: any[]): void;
                info(...data: any[]): void;
                debug(...data: any[]): void;
            };
            readonly asyncEle: Promise<Element>;
            readonly ele: Element;
        };
        createModal(config?: Record<string, string>): _descope_sdk_component_drivers.ModalDriver;
        activateButton: _descope_sdk_component_drivers.ButtonDriver;
        "__#9@#initActivateButton"(): void;
        "__#9@#onIsAccessKeySelectedUpdate": (canModify: boolean) => void;
        activateAccessKeysModal: _descope_sdk_component_drivers.ModalDriver;
        "__#8@#initActivateAccessKeyModal"(): Promise<void>;
        searchInput: _descope_sdk_component_drivers.TextFieldDriver;
        "__#17@#onInput": (this: any, ...args: any[]) => void;
        "__#17@#initSearchInput"(): void;
        deleteButton: _descope_sdk_component_drivers.ButtonDriver;
        "__#16@#initDeleteButton"(): void;
        "__#16@#onIsAccessKeySelectedUpdate": (canModify: boolean) => void;
        deleteAccessKeysModal: _descope_sdk_component_drivers.ModalDriver;
        "__#15@#initDeleteAccessKeyModal"(): Promise<void>;
        createButton: _descope_sdk_component_drivers.ButtonDriver;
        "__#12@#initCreateButton"(): void;
        createAccessKeyModal: _descope_sdk_component_drivers.ModalDriver;
        "__#11@#rolesMultiSelect": _descope_sdk_component_drivers.MultiSelectDriver;
        "__#11@#initCreateAccessKeyModal"(): Promise<void>;
        "__#11@#updateRolesMultiSelect": () => Promise<void>;
        createdAccessKeyModal: _descope_sdk_component_drivers.ModalDriver;
        "__#10@#initCreatedAccessKeyModal"(): Promise<void>;
        validateForm(rootEle: Element): boolean;
        getFormInputs(rootEle: Element): HTMLInputElement[];
        getFormData(rootEle: Element): any;
        setFormData(rootEle: Element, data: Record<string, any>): void;
        resetFormData(rootEle: Element): void;
        getFormFieldNames(rootEle: Element): string[];
        disableFormField(rootEle: Element, name: string): void;
        removeFormField(rootEle: Element, name: string): void;
        accessKeysTable: _descope_sdk_component_drivers.GridDriver<AccessKey>;
        "__#7@#initAccessKeysTable"(): void;
        "__#7@#onAccessKeysListUpdate": (accessKeysList: {
            expireTimeFormatted: string;
            createdTimeFormatted: string;
            status: string;
            id: string;
            name: string;
            roleNames: string[];
            permittedIps: string[];
            createdTime: number;
            expireTime: number;
            createdBy: string;
            clientId: string;
            editable: boolean;
            boundUserId: string;
        }[]) => void;
        "__#7@#onColumnSortChange": (this: any, ...args: any[]) => void;
        "__#29656@#globalStyle": _descope_sdk_mixins.InjectedStyle;
        readonly theme: _descope_sdk_mixins.ThemeOptions;
        readonly styleId: string;
        "__#29656@#_themeResource": Promise<void | Record<string, any>>;
        "__#29656@#fetchTheme"(): Promise<Record<string, any>>;
        readonly "__#29656@#themeResource": Promise<void | Record<string, any>>;
        "__#29656@#loadGlobalStyle"(): Promise<void>;
        "__#29656@#loadComponentsStyle"(): Promise<void>;
        "__#29656@#getFontsConfig"(): Promise<Record<string, {
            url?: string;
        }>>;
        "__#29656@#loadFonts"(): Promise<void>;
        "__#29656@#applyTheme"(): Promise<void>;
        "__#29656@#onThemeChange": () => void;
        "__#29656@#loadTheme"(): void;
        "__#29656@#toggleOsThemeChangeListener": (listen: boolean) => void;
        "__#29649@#debuggerEle": HTMLElement & {
            updateData: (data: {
                title: string;
                description?: string;
            } | {
                title: string;
                description?: string;
            }[]) => void;
        };
        "__#29649@#disableDebugger"(): void;
        "__#29649@#enableDebugger"(): Promise<void>;
        readonly debug: boolean;
        "__#29649@#handleDebugMode"(): void;
        "__#29649@#updateDebuggerMessages"(title: string, description: string): void;
    };
};

declare global {
    interface HTMLElement {
        attributeChangedCallback(attrName: string, oldValue: string | null, newValue: string | null): void;
        connectedCallback(): void;
    }
}

export { AccessKeyManagementWidget as default };
