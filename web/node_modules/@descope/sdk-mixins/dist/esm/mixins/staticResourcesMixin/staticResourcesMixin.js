import { __classPrivateFieldGet, __classPrivateFieldSet } from 'tslib';
import { createSingletonMixin, compose, pathJoin } from '@descope/sdk-helpers';
import { loggerMixin } from '../loggerMixin/loggerMixin.js';
import { ASSETS_FOLDER, BASE_CONTENT_URL, OVERRIDE_CONTENT_URL } from './constants.js';
import { projectIdMixin } from '../projectIdMixin.js';
import { baseUrlMixin } from '../baseUrlMixin.js';
import { fetchWithFallbacks } from './fetchWithFallbacks.js';

function getResourceUrl({ projectId, filename, assetsFolder = ASSETS_FOLDER, baseUrl = BASE_CONTENT_URL, }) {
    const url = new URL(baseUrl);
    url.pathname = pathJoin(url.pathname, projectId, assetsFolder, filename);
    // we want to keep the baseUrl so we can use it later
    url.baseUrl = baseUrl;
    return url;
}
const staticResourcesMixin = createSingletonMixin((superclass) => {
    var _StaticResourcesMixinClass_instances, _StaticResourcesMixinClass_lastBaseUrl, _StaticResourcesMixinClass_workingBaseUrl, _StaticResourcesMixinClass_getResourceUrls, _a;
    const BaseClass = compose(loggerMixin, projectIdMixin, baseUrlMixin)(superclass);
    // the logic should be as following:
    // if there is a local storage override, use it
    // otherwise, if there is a base-static-url attribute, use it
    // otherwise, try to use base-url, and check if it's working
    // if it's working, use it
    // if not, use the default content url
    return _a = class StaticResourcesMixinClass extends BaseClass {
            constructor() {
                super(...arguments);
                _StaticResourcesMixinClass_instances.add(this);
                _StaticResourcesMixinClass_lastBaseUrl.set(this, void 0);
                _StaticResourcesMixinClass_workingBaseUrl.set(this, void 0);
            }
            async fetchStaticResource(filename, format) {
                const resourceUrls = __classPrivateFieldGet(this, _StaticResourcesMixinClass_instances, "m", _StaticResourcesMixinClass_getResourceUrls).call(this, filename);
                // if there are multiple resource urls, it means that there are fallbacks,
                // if one of the options (which is not the last) is working, we want to keep using it by updating the workingBaseUrl
                const onSuccess = !Array.isArray(resourceUrls)
                    ? null
                    : (index) => {
                        if (index !== resourceUrls.length - 1) {
                            const { baseUrl } = resourceUrls[index];
                            __classPrivateFieldSet(this, _StaticResourcesMixinClass_workingBaseUrl, baseUrl, "f");
                        }
                    };
                try {
                    const res = await fetchWithFallbacks(resourceUrls, { cache: 'default' }, { logger: this.logger, onSuccess });
                    return {
                        body: await res[format](),
                        headers: Object.fromEntries(res.headers.entries()),
                    };
                }
                catch (e) {
                    this.logger.error(e.message);
                }
            }
            get baseStaticUrl() {
                return this.getAttribute('base-static-url') || '';
            }
        },
        _StaticResourcesMixinClass_lastBaseUrl = new WeakMap(),
        _StaticResourcesMixinClass_workingBaseUrl = new WeakMap(),
        _StaticResourcesMixinClass_instances = new WeakSet(),
        _StaticResourcesMixinClass_getResourceUrls = function _StaticResourcesMixinClass_getResourceUrls(filename) {
            const overrideUrl = OVERRIDE_CONTENT_URL || this.baseStaticUrl;
            if (overrideUrl) {
                return getResourceUrl({
                    projectId: this.projectId,
                    filename,
                    baseUrl: overrideUrl,
                });
            }
            const isBaseUrlUpdated = __classPrivateFieldGet(this, _StaticResourcesMixinClass_lastBaseUrl, "f") !== this.baseUrl;
            const shouldFallbackFetch = isBaseUrlUpdated && !!this.baseUrl;
            // if the base url has changed, reset the working base url
            if (isBaseUrlUpdated) {
                __classPrivateFieldSet(this, _StaticResourcesMixinClass_lastBaseUrl, this.baseUrl, "f");
                __classPrivateFieldSet(this, _StaticResourcesMixinClass_workingBaseUrl, undefined, "f");
            }
            const resourceUrl = getResourceUrl({
                projectId: this.projectId,
                filename,
                baseUrl: __classPrivateFieldGet(this, _StaticResourcesMixinClass_workingBaseUrl, "f"),
            });
            // if there is no reason to check the baseUrl, generate the resource url according to the priority
            if (!shouldFallbackFetch) {
                return resourceUrl;
            }
            const resourceUrlFromBaseUrl = getResourceUrl({
                projectId: this.projectId,
                filename,
                baseUrl: this.baseUrl + '/pages',
            });
            return [resourceUrlFromBaseUrl, resourceUrl];
        },
        _a;
});

export { getResourceUrl, staticResourcesMixin };
//# sourceMappingURL=staticResourcesMixin.js.map
