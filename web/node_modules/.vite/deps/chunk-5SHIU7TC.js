import {
  __assign,
  __rest,
  __spreadArray
} from "./chunk-C4K4ZQL2.js";
import {
  __require
} from "./chunk-KEXKKQVW.js";

// node_modules/jwt-decode/build/esm/index.js
var InvalidTokenError = class extends Error {
};
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, (m3, p4) => {
    let code = p4.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = "0" + code;
    }
    return "%" + code;
  }));
}
function base64UrlDecode(str) {
  let output = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(output);
  } catch (err) {
    return atob(output);
  }
}
function jwtDecode(token, options) {
  if (typeof token !== "string") {
    throw new InvalidTokenError("Invalid token specified: must be a string");
  }
  options || (options = {});
  const pos = options.header === true ? 0 : 1;
  const part = token.split(".")[pos];
  if (typeof part !== "string") {
    throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
  }
  let decoded;
  try {
    decoded = base64UrlDecode(part);
  } catch (e) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
  }
  try {
    return JSON.parse(decoded);
  } catch (e) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
  }
}

// node_modules/@descope/core-js-sdk/dist/index.esm.js
var t = { accessKey: { exchange: "/v1/auth/accesskey/exchange" }, otp: { verify: "/v1/auth/otp/verify", signIn: "/v1/auth/otp/signin", signUp: "/v1/auth/otp/signup", update: { email: "/v1/auth/otp/update/email", phone: "/v1/auth/otp/update/phone" }, signUpOrIn: "/v1/auth/otp/signup-in" }, magicLink: { verify: "/v1/auth/magiclink/verify", signIn: "/v1/auth/magiclink/signin", signUp: "/v1/auth/magiclink/signup", update: { email: "/v1/auth/magiclink/update/email", phone: "/v1/auth/magiclink/update/phone" }, signUpOrIn: "/v1/auth/magiclink/signup-in" }, enchantedLink: { verify: "/v1/auth/enchantedlink/verify", signIn: "/v1/auth/enchantedlink/signin", signUp: "/v1/auth/enchantedlink/signup", session: "/v1/auth/enchantedlink/pending-session", update: { email: "/v1/auth/enchantedlink/update/email" }, signUpOrIn: "/v1/auth/enchantedlink/signup-in" }, oauth: { start: "/v1/auth/oauth/authorize", exchange: "/v1/auth/oauth/exchange", startNative: "v1/auth/oauth/native/start", finishNative: "v1/auth/oauth/native/finish", oneTap: { getOneTapClientId: "/v1/auth/onetap/clientid/{provider}", exchangeOneTapIDToken: "/v1/auth/onetap/idtoken/exchange", verifyOneTapIDToken: "/v1/auth/onetap/idtoken/verify" } }, outbound: { connect: "/v1/outbound/oauth/connect" }, saml: { start: "/v1/auth/saml/authorize", exchange: "/v1/auth/saml/exchange" }, totp: { verify: "/v1/auth/totp/verify", signUp: "/v1/auth/totp/signup", update: "/v1/auth/totp/update" }, notp: { signIn: "/v1/auth/notp/whatsapp/signin", signUp: "/v1/auth/notp/whatsapp/signup", signUpOrIn: "/v1/auth/notp/whatsapp/signup-in", session: "/v1/auth/notp/pending-session" }, webauthn: { signUp: { start: "/v1/auth/webauthn/signup/start", finish: "/v1/auth/webauthn/signup/finish" }, signIn: { start: "/v1/auth/webauthn/signin/start", finish: "/v1/auth/webauthn/signin/finish" }, signUpOrIn: { start: "/v1/auth/webauthn/signup-in/start" }, update: { start: "v1/auth/webauthn/update/start", finish: "/v1/auth/webauthn/update/finish" } }, password: { signUp: "/v1/auth/password/signup", signIn: "/v1/auth/password/signin", sendReset: "/v1/auth/password/reset", update: "/v1/auth/password/update", replace: "/v1/auth/password/replace", policy: "/v1/auth/password/policy" }, refresh: "/v1/auth/refresh", tryRefresh: "/v1/auth/try-refresh", selectTenant: "/v1/auth/tenant/select", logout: "/v1/auth/logout", logoutAll: "/v1/auth/logoutall", me: "/v1/auth/me", myTenants: "/v1/auth/me/tenants", history: "/v1/auth/me/history", flow: { start: "/v1/flow/start", next: "/v1/flow/next" } };
var n = "<region>";
var o = `https://api.${n}descope.com`;
var s = 1e3;
var i = 6e5;
var a = "dct";
var r = () => {
  const e = {};
  return { headers(t2) {
    const n2 = "function" == typeof t2.entries ? Object.fromEntries(t2.entries()) : t2;
    return e.Headers = JSON.stringify(n2), this;
  }, body(t2) {
    return e.Body = t2, this;
  }, url(t2) {
    return e.Url = t2.toString(), this;
  }, method(t2) {
    return e.Method = t2, this;
  }, title(t2) {
    return e.Title = t2, this;
  }, status(t2) {
    return e.Status = t2, this;
  }, retries(t2) {
    return e.Retries = t2, this;
  }, build: () => Object.keys(e).flatMap((t2) => e[t2] ? [`${"Title" !== t2 ? `${t2}: ` : ""}${e[t2]}`] : []).join("\n") };
};
var p = [521, 524];
var l = (e) => async (...t2) => {
  let n2 = await e(...t2);
  p.includes(n2.status) && (n2 = await e(...t2), n2.retries = 1);
  const o3 = await n2.text();
  return n2.text = () => Promise.resolve(o3), n2.json = () => Promise.resolve(JSON.parse(o3)), n2.clone = () => n2, n2;
};
var d = (e, t2) => {
  const n2 = t2 || fetch;
  return n2 || null == e || e.warn("Fetch is not defined, you will not be able to send http requests, if you are running in a test, make sure fetch is defined globally"), e ? async (...t3) => {
    if (!n2) throw Error("Cannot send http request, fetch is not defined, if you are running in a test, make sure fetch is defined globally");
    e.log(((e2) => r().title("Request").url(e2[0]).method(e2[1].method).headers(e2[1].headers).body(e2[1].body).build())(t3));
    const o3 = await l(n2)(...t3);
    return e[o3.ok ? "log" : "error"](await (async (e2) => {
      const t4 = await e2.text();
      return r().title("Response").url(e2.url.toString()).status(`${e2.status} ${e2.statusText}`).headers(e2.headers).body(t4).retries(e2.retries).build();
    })(o3)), o3;
  } : l(n2);
};
var u;
var c = () => {
  if (u) return u;
  const e = /* @__PURE__ */ new Date(), t2 = `${e.getUTCFullYear().toString()}-${(e.getUTCMonth() + 1).toString().padStart(2, "0")}-${e.getUTCDate().toString().padStart(2, "0")}-${e.getUTCHours().toString().padStart(2, "0")}:${e.getUTCMinutes().toString().padStart(2, "0")}:${e.getUTCSeconds().toString().padStart(2, "0")}:${e.getUTCMilliseconds().toString()}`, n2 = Math.floor(1e3 + 9e3 * Math.random());
  return u = `${t2}-${n2}`, u;
};
var g;
!function(e) {
  e.get = "GET", e.delete = "DELETE", e.post = "POST", e.put = "PUT", e.patch = "PATCH";
}(g || (g = {}));
var h = ({ path: e, baseUrl: t2, queryParams: o3, projectId: s2 }) => {
  const i3 = s2.slice(1, -27);
  t2 = t2.replace(n, i3 ? i3 + "." : "");
  let a2 = e ? `${t2.replace(/\/$/, "")}/${null == e ? void 0 : e.replace(/^\//, "")}` : t2;
  if (o3) {
    const e2 = Object.keys(o3);
    e2.forEach((t3, n2) => {
      a2 = `${a2}${0 === n2 ? "?" : ""}${t3}=${encodeURIComponent(o3[t3])}${n2 === e2.length - 1 ? "" : "&"}`;
    });
  }
  return a2;
};
var v = (...e) => new Headers(e.reduce((e2, t2) => (((e3) => Array.isArray(e3) ? e3 : e3 instanceof Headers ? Array.from(e3.entries()) : e3 ? Object.entries(e3) : [])(t2).forEach(([t3, n2]) => {
  e2[t3] = "function" == typeof n2 ? n2() : n2;
}), e2), {}));
var f = { "Content-Type": "application/json" };
var m = (e, t2 = "") => {
  let n2 = e;
  return t2 && (n2 = n2 + ":" + t2), { Authorization: `Bearer ${n2}` };
};
var k = (e, t2) => {
  const n2 = { "x-descope-sdk-session-id": c(), "x-descope-sdk-name": "core-js", "x-descope-sdk-version": "2.49.0", "x-descope-project-id": e };
  return t2 && (n2["x-descope-refresh-cookie-name"] = t2), n2;
};
var I = (e) => {
  try {
    e = JSON.parse(e);
  } catch (e2) {
    return false;
  }
  return "object" == typeof e && null !== e;
};
var b = /* @__PURE__ */ ((e) => (t2) => {
  var n2;
  return e(Object.assign(Object.assign({}, t2), { hooks: { beforeRequest: (e2) => {
    var n3;
    const o3 = [].concat((null === (n3 = t2.hooks) || void 0 === n3 ? void 0 : n3.beforeRequest) || []);
    return null == o3 ? void 0 : o3.reduce((e3, t3) => t3(e3), e2);
  }, afterRequest: async (e2, n3) => {
    var o3;
    const s2 = [].concat((null === (o3 = t2.hooks) || void 0 === o3 ? void 0 : o3.afterRequest) || []);
    if (0 == s2.length) return;
    (await Promise.allSettled(null == s2 ? void 0 : s2.map((t3) => t3(e2, null == n3 ? void 0 : n3.clone())))).forEach((e3) => {
      var n4;
      return "rejected" === e3.status && (null === (n4 = t2.logger) || void 0 === n4 ? void 0 : n4.error(e3.reason));
    });
  }, transformResponse: null === (n2 = t2.hooks) || void 0 === n2 ? void 0 : n2.transformResponse } }));
})(({ baseUrl: e, projectId: t2, baseConfig: n2, refreshCookieName: s2, logger: i3, hooks: a2, cookiePolicy: r3, fetch: p4 }) => {
  const l4 = e || o, u3 = d(i3, p4), c3 = async (e2) => {
    var o3;
    const i4 = (null == a2 ? void 0 : a2.beforeRequest) ? a2.beforeRequest(e2) : e2, { path: p5, body: d4, headers: c4, queryParams: g3, method: b4, token: y3 } = i4, O4 = ((e3) => void 0 === e3 ? void 0 : JSON.stringify(e3))(d4), w3 = { headers: v(m(t2, y3), k(t2, s2), (null == n2 ? void 0 : n2.baseHeaders) || {}, I(O4) ? f : {}, c4), method: b4, body: O4 };
    null !== r3 && (w3.credentials = r3 || "include");
    const j3 = await u3(h({ path: p5, baseUrl: l4, queryParams: g3, projectId: t2 }), w3);
    if ((null == a2 ? void 0 : a2.afterRequest) && await a2.afterRequest(e2, null == j3 ? void 0 : j3.clone()), null == a2 ? void 0 : a2.transformResponse) {
      const e3 = await j3.json(), t3 = ((null === (o3 = j3.headers) || void 0 === o3 ? void 0 : o3.get("set-cookie")) || "").split(";").reduce((e4, t4) => {
        const [n4, o4] = t4.split("=");
        return Object.assign(Object.assign({}, e4), { [n4.trim()]: o4 });
      }, {}), n3 = Object.assign(Object.assign({}, j3), { json: () => Promise.resolve(e3), cookies: t3 });
      return n3.clone = () => n3, a2.transformResponse(n3);
    }
    return j3;
  };
  return { get: (e2, { headers: t3, queryParams: n3, token: o3 } = {}) => c3({ path: e2, headers: t3, queryParams: n3, body: void 0, method: g.get, token: o3 }), post: (e2, t3, { headers: n3, queryParams: o3, token: s3 } = {}) => c3({ path: e2, headers: n3, queryParams: o3, body: t3, method: g.post, token: s3 }), patch: (e2, t3, { headers: n3, queryParams: o3, token: s3 } = {}) => c3({ path: e2, headers: n3, queryParams: o3, body: t3, method: g.patch, token: s3 }), put: (e2, t3, { headers: n3, queryParams: o3, token: s3 } = {}) => c3({ path: e2, headers: n3, queryParams: o3, body: t3, method: g.put, token: s3 }), delete: (e2, { headers: t3, queryParams: n3, token: o3 } = {}) => c3({ path: e2, headers: t3, queryParams: n3, body: void 0, method: g.delete, token: o3 }), hooks: a2, buildUrl: (e2, n3) => h({ projectId: t2, baseUrl: l4, path: e2, queryParams: n3 }) };
});
var y = { TOO_MANY_REQUESTS: 429 };
function O(e, t2, n2) {
  var o3;
  let s2 = w(e);
  if (t2) {
    if (!(null == s2 ? void 0 : s2.tenants) && (null == s2 ? void 0 : s2[a]) === t2) return (null == s2 ? void 0 : s2[n2]) || [];
    s2 = null === (o3 = null == s2 ? void 0 : s2.tenants) || void 0 === o3 ? void 0 : o3[t2];
  }
  const i3 = null == s2 ? void 0 : s2[n2];
  return Array.isArray(i3) ? i3 : [];
}
function w(t2) {
  if ("string" != typeof t2 || !t2) throw new Error("Invalid token provided");
  return jwtDecode(t2);
}
function j(e) {
  const { exp: t2 } = w(e);
  return (/* @__PURE__ */ new Date()).getTime() / 1e3 > t2;
}
function U(e) {
  let t2 = w(e);
  const n2 = Object.keys(null == t2 ? void 0 : t2.tenants);
  return Array.isArray(n2) ? n2 : [];
}
function T(e, t2) {
  return O(e, t2, "permissions");
}
function R(e, t2) {
  return O(e, t2, "roles");
}
var x = (...e) => e.join("/").replace(/\/{2,}/g, "/");
async function P(e, t2) {
  var n2;
  const o3 = await e, s2 = { code: o3.status, ok: o3.ok, response: o3 }, i3 = await o3.clone().json();
  return o3.ok ? s2.data = t2 ? t2(i3) : i3 : (s2.error = i3, o3.status === y.TOO_MANY_REQUESTS && Object.assign(s2.error, { retryAfter: Number.parseInt(null === (n2 = o3.headers) || void 0 === n2 ? void 0 : n2.get("retry-after")) || 0 })), s2;
}
function $(e) {
  var t2;
  return (null === (t2 = w(e)) || void 0 === t2 ? void 0 : t2[a]) || "";
}
var q = (e, t2) => (n2 = t2) => (t3) => !e(t3) && n2.replace("{val}", t3);
var S = (e, t2) => (n2 = t2) => (t3) => {
  const o3 = e.filter((e2) => e2(t3));
  return !(o3.length < e.length) && (n2 ? n2.replace("{val}", t3) : o3.join(" OR "));
};
var C = (...e) => ({ validate: (t2) => (e.forEach((e2) => {
  const n2 = e2(t2);
  if (n2) throw new Error(n2);
}), true) });
var A = (e) => (t2) => e.test(t2);
var L = A(/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/);
var E = A(/^\+[1-9]{1}[0-9]{3,14}$/);
var M = (e, t2) => (n2) => C(...t2).validate(((e2, t3, n3) => {
  const o3 = (Array.isArray(t3) ? t3.join(".") : String(t3)).replace(/\[\\?("|')?(\w|d)+\\?("|')?\]/g, (e3, t4, n4) => "." + n4).split("."), s2 = o3.length;
  let i3 = 0, a2 = e2 === Object(e2) ? e2 : void 0;
  for (; null != a2 && i3 < s2; ) a2 = a2[o3[i3++]];
  return i3 && i3 === s2 && void 0 !== a2 ? a2 : n3;
})(n2, e));
var N = q(L, '"{val}" is not a valid email');
var D = q(E, '"{val}" is not a valid phone number');
var H = q((J = 1, (e) => e.length >= J), "Minimum length is 1");
var J;
var z = q((e) => "string" == typeof e, "Input is not a string");
var _ = q((e) => Array.isArray(e), "Input is not an array");
var F = q((e) => "boolean" == typeof e, "Input is not a boolean");
var K = q((e) => void 0 === e, "Input is defined");
var V = S([z(), K()], "Input is not a string or undefined");
var Y = S([_(), F()], "Input is not an array or boolean");
var Z = (...e) => (t2) => (...n2) => (e.forEach((e2, t3) => C(...e2).validate(n2[t3])), t2(...n2));
var B = (e) => [z(`"${e}" must be a string`)];
var Q = (e) => [V(`"${e}" must be string or undefined`)];
var G = (e) => [z(`"${e}" must be a string`), H(`"${e}" must not be empty`)];
var W = (e) => [z(`"${e}" must be a string`), N()];
var X = (e) => [z(`"${e}" must be a string`), D()];
var ee = Z(G("accessKey"));
var te = (e) => ({ exchange: ee((n2, o3) => P(e.post(t.accessKey.exchange, { loginOptions: o3 }, { token: n2 }))) });
var ne = (e, t2, n2) => (t2.forEach((t3) => {
  const o3 = t3.split(".");
  let s2 = o3.shift(), i3 = e;
  for (; o3.length > 0; ) {
    if (i3 = i3[s2], !s2 || !i3) throw Error(`Invalid path "${t3}", "${s2}" is missing or has no value`);
    s2 = o3.shift();
  }
  if ("function" != typeof i3[s2]) throw Error(`"${t3}" is not a function`);
  const a2 = i3[s2];
  i3[s2] = n2(a2);
}), e);
var oe = ({ pollingIntervalMs: e = 1e3, timeoutMs: t2 = 6e5 } = {}) => ({ pollingIntervalMs: Math.max(e || s, s), timeoutMs: Math.min(t2 || i, i) });
var se;
var ie;
!function(e) {
  e.sms = "sms", e.voice = "voice", e.whatsapp = "whatsapp";
}(se || (se = {})), function(e) {
  e.email = "email";
}(ie || (ie = {}));
var ae = Object.assign(Object.assign({}, se), ie);
var re;
!function(e) {
  e.waiting = "waiting", e.running = "running", e.completed = "completed", e.failed = "failed";
}(re || (re = {}));
var pe = G("loginId");
var le = Z(G("token"));
var de = Z(pe);
var ue = Z(G("pendingRef"));
var ce = Z(pe, W("email"));
var ge = (e) => ({ verify: le((n2) => P(e.post(t.enchantedLink.verify, { token: n2 }))), signIn: de((n2, o3, s2, i3) => P(e.post(x(t.enchantedLink.signIn, ae.email), { loginId: n2, URI: o3, loginOptions: s2 }, { token: i3 }))), signUpOrIn: de((n2, o3, s2) => P(e.post(x(t.enchantedLink.signUpOrIn, ae.email), { loginId: n2, URI: o3, loginOptions: s2 }))), signUp: de((n2, o3, s2, i3) => P(e.post(x(t.enchantedLink.signUp, ae.email), { loginId: n2, URI: o3, user: s2, loginOptions: i3 }))), waitForSession: ue((n2, o3) => new Promise((s2) => {
  const { pollingIntervalMs: i3, timeoutMs: a2 } = oe(o3);
  let r3;
  const p4 = setInterval(async () => {
    const o4 = await e.post(t.enchantedLink.session, { pendingRef: n2 });
    o4.ok && (clearInterval(p4), r3 && clearTimeout(r3), s2(P(Promise.resolve(o4))));
  }, i3);
  r3 = setTimeout(() => {
    s2({ error: { errorDescription: `Session polling timeout exceeded: ${a2}ms`, errorCode: "0" }, ok: false }), clearInterval(p4);
  }, a2);
})), update: { email: ce((n2, o3, s2, i3, a2) => P(e.post(t.enchantedLink.update.email, Object.assign({ loginId: n2, email: o3, URI: s2 }, a2), { token: i3 }))) } });
var he = Z(G("flowId"));
var ve = Z(G("executionId"), G("stepId"), G("interactionId"));
var fe = (e) => ({ start: he((n2, o3, s2, i3, a2, r3, p4) => P(e.post(t.flow.start, { flowId: n2, options: o3, conditionInteractionId: s2, interactionId: i3, componentsVersion: a2, flowVersions: r3, input: p4 }))), next: ve((n2, o3, s2, i3, a2, r3) => P(e.post(t.flow.next, { executionId: n2, stepId: o3, interactionId: s2, version: i3, componentsVersion: a2, input: r3 }))) });
var me = G("loginId");
var ke = Z(G("token"));
var Ie = Z(me);
var be = Z(me, X("phone"));
var ye = Z(me, W("email"));
var Oe = Object.keys(ae).filter((e) => e !== se.voice);
var we = (e) => ({ verify: ke((n2) => P(e.post(t.magicLink.verify, { token: n2 }))), signIn: Oe.reduce((n2, o3) => Object.assign(Object.assign({}, n2), { [o3]: Ie((n3, s2, i3, a2) => P(e.post(x(t.magicLink.signIn, o3), { loginId: n3, URI: s2, loginOptions: i3 }, { token: a2 }))) }), {}), signUp: Oe.reduce((n2, o3) => Object.assign(Object.assign({}, n2), { [o3]: Ie((n3, s2, i3, a2) => P(e.post(x(t.magicLink.signUp, o3), { loginId: n3, URI: s2, user: i3, loginOptions: a2 }))) }), {}), signUpOrIn: Oe.reduce((n2, o3) => Object.assign(Object.assign({}, n2), { [o3]: Ie((n3, s2, i3) => P(e.post(x(t.magicLink.signUpOrIn, o3), { loginId: n3, URI: s2, loginOptions: i3 }))) }), {}), update: { email: ye((n2, o3, s2, i3, a2) => P(e.post(t.magicLink.update.email, Object.assign({ loginId: n2, email: o3, URI: s2 }, a2), { token: i3 }))), phone: Object.keys(se).filter((e2) => e2 !== se.voice).reduce((n2, o3) => Object.assign(Object.assign({}, n2), { [o3]: be((n3, s2, i3, a2, r3) => P(e.post(x(t.magicLink.update.phone, o3), Object.assign({ loginId: n3, phone: s2, URI: i3 }, r3), { token: a2 }))) }), {}) } });
var je;
!function(e) {
  e.facebook = "facebook", e.github = "github", e.google = "google", e.microsoft = "microsoft", e.gitlab = "gitlab", e.apple = "apple", e.discord = "discord", e.linkedin = "linkedin", e.slack = "slack";
}(je || (je = {}));
var Ue = Z(G("code"));
var Te = (e) => ({ start: Object.assign((n2, o3, s2, i3, a2) => P(e.post(t.oauth.start, s2 || {}, { queryParams: Object.assign(Object.assign({ provider: n2 }, o3 && { redirectURL: o3 }), a2 && { loginHint: a2 }), token: i3 })), Object.keys(je).reduce((n2, o3) => Object.assign(Object.assign({}, n2), { [o3]: (n3, s2, i3, a2) => P(e.post(t.oauth.start, s2 || {}, { queryParams: Object.assign(Object.assign({ provider: o3 }, n3 && { redirectURL: n3 }), a2 && { loginHint: a2 }), token: i3 })) }), {})), exchange: Ue((n2) => P(e.post(t.oauth.exchange, { code: n2 }))), startNative: (n2, o3, s2) => P(e.post(t.oauth.startNative, { provider: n2, loginOptions: o3, implicit: s2 })), finishNative: (n2, o3, s2, i3, a2) => P(e.post(t.oauth.finishNative, { provider: n2, stateId: o3, user: s2, code: i3, idToken: a2 })), getOneTapClientId: (n2) => P(e.get(t.oauth.oneTap.getOneTapClientId.replace("{provider}", n2))), verifyOneTapIDToken: (n2, o3, s2, i3) => P(e.post(t.oauth.oneTap.verifyOneTapIDToken, { provider: n2, idToken: o3, nonce: s2, loginOptions: i3 })), exchangeOneTapIDToken: (n2, o3, s2, i3) => P(e.post(t.oauth.oneTap.exchangeOneTapIDToken, { provider: n2, idToken: o3, nonce: s2, loginOptions: i3 })) });
var Re = G("appId");
var xe = Z(Re);
var Pe = (e) => ({ connect: xe((n2, o3, s2) => {
  const i3 = null == o3 ? void 0 : o3.tenantId, a2 = null == o3 ? void 0 : o3.tenantLevel;
  return null == o3 || delete o3.tenantId, null == o3 || delete o3.tenantLevel, P(e.post(t.outbound.connect, { appId: n2, tenantId: i3, tenantLevel: a2, options: o3 }, { token: s2 }));
}) });
var $e = G("loginId");
var qe = Z($e, G("code"));
var Se = Z($e);
var Ce = Z($e, X("phone"));
var Ae = Z($e, W("email"));
var Le = (e) => ({ verify: Object.keys(ae).reduce((n2, o3) => Object.assign(Object.assign({}, n2), { [o3]: qe((n3, s2) => P(e.post(x(t.otp.verify, o3), { code: s2, loginId: n3 }))) }), {}), signIn: Object.keys(ae).reduce((n2, o3) => Object.assign(Object.assign({}, n2), { [o3]: Se((n3, s2, i3) => P(e.post(x(t.otp.signIn, o3), { loginId: n3, loginOptions: s2 }, { token: i3 }))) }), {}), signUp: Object.keys(ae).reduce((n2, o3) => Object.assign(Object.assign({}, n2), { [o3]: Se((n3, s2, i3) => P(e.post(x(t.otp.signUp, o3), { loginId: n3, user: s2, loginOptions: i3 }))) }), {}), signUpOrIn: Object.keys(ae).reduce((n2, o3) => Object.assign(Object.assign({}, n2), { [o3]: Se((n3, s2) => P(e.post(x(t.otp.signUpOrIn, o3), { loginId: n3, loginOptions: s2 }))) }), {}), update: { email: Ae((n2, o3, s2, i3) => P(e.post(t.otp.update.email, Object.assign({ loginId: n2, email: o3 }, i3), { token: s2 }))), phone: Object.keys(se).reduce((n2, o3) => Object.assign(Object.assign({}, n2), { [o3]: Ce((n3, s2, i3, a2) => P(e.post(x(t.otp.update.phone, o3), Object.assign({ loginId: n3, phone: s2 }, a2), { token: i3 }))) }), {}) } });
var Ee = Z(G("tenant"));
var Me = Z(G("code"));
var Ne = (e) => ({ start: Ee((n2, o3, s2, i3, a2, r3, p4) => P(e.post(t.saml.start, s2 || {}, Object.assign({ queryParams: Object.assign(Object.assign(Object.assign(Object.assign({ tenant: n2 }, o3 && { redirectURL: o3 }), a2 && { ssoId: a2 }), r3 && { forceAuthn: "true" }), p4 && { loginHint: p4 }) }, i3 && { token: i3 })))), exchange: Me((n2) => P(e.post(t.saml.exchange, { code: n2 }))) });
var De = G("loginId");
var He = Z(De, G("code"));
var Je = Z(De);
var ze = Z(De);
var _e = (e) => ({ signUp: Je((n2, o3) => P(e.post(t.totp.signUp, { loginId: n2, user: o3 }))), verify: He((n2, o3, s2, i3) => P(e.post(t.totp.verify, { loginId: n2, code: o3, loginOptions: s2 }, { token: i3 }))), update: ze((n2, o3) => P(e.post(t.totp.update, { loginId: n2 }, { token: o3 }))) });
var Fe = G("loginId");
var Ke = G("newPassword");
var Ve = Z(Fe, G("password"));
var Ye = Z(Fe);
var Ze = Z(Fe, Ke);
var Be = Z(Fe, G("oldPassword"), Ke);
var Qe = (e) => ({ signUp: Ve((n2, o3, s2, i3) => P(e.post(t.password.signUp, { loginId: n2, password: o3, user: s2, loginOptions: i3 }))), signIn: Ve((n2, o3, s2) => P(e.post(t.password.signIn, { loginId: n2, password: o3, loginOptions: s2 }))), sendReset: Ye((n2, o3, s2) => P(e.post(t.password.sendReset, { loginId: n2, redirectUrl: o3, templateOptions: s2 }))), update: Ze((n2, o3, s2) => P(e.post(t.password.update, { loginId: n2, newPassword: o3 }, { token: s2 }))), replace: Be((n2, o3, s2) => P(e.post(t.password.replace, { loginId: n2, oldPassword: o3, newPassword: s2 }))), policy: () => P(e.get(t.password.policy)) });
var Ge = B("loginId");
var We = G("loginId");
var Xe = G("origin");
var et = Z(We, Xe, G("name"));
var tt = Z(We, Xe);
var nt = Z(Ge, Xe);
var ot = Z(We, Xe, Q("token"));
var st = Z(G("transactionId"), G("response"));
var it = (e) => ({ signUp: { start: et((n2, o3, s2, i3) => P(e.post(t.webauthn.signUp.start, { user: { loginId: n2, name: s2 }, origin: o3, passkeyOptions: i3 }))), finish: st((n2, o3) => P(e.post(t.webauthn.signUp.finish, { transactionId: n2, response: o3 }))) }, signIn: { start: nt((n2, o3, s2, i3, a2) => P(e.post(t.webauthn.signIn.start, { loginId: n2, origin: o3, loginOptions: s2, passkeyOptions: a2 }, { token: i3 }))), finish: st((n2, o3) => P(e.post(t.webauthn.signIn.finish, { transactionId: n2, response: o3 }))) }, signUpOrIn: { start: tt((n2, o3, s2) => P(e.post(t.webauthn.signUpOrIn.start, { loginId: n2, origin: o3, passkeyOptions: s2 }))) }, update: { start: ot((n2, o3, s2, i3) => P(e.post(t.webauthn.update.start, { loginId: n2, origin: o3, passkeyOptions: i3 }, { token: s2 }))), finish: st((n2, o3) => P(e.post(t.webauthn.update.finish, { transactionId: n2, response: o3 }))) } });
var at = B("loginId");
var rt = Z(at);
var pt = Z(G("pendingRef"));
var lt = (e) => ({ signUpOrIn: rt((n2, o3) => P(e.post(t.notp.signUpOrIn, { loginId: n2, loginOptions: o3 }))), signUp: rt((n2, o3, s2) => P(e.post(t.notp.signUp, { loginId: n2, user: o3, loginOptions: s2 }))), signIn: rt((n2, o3, s2) => P(e.post(t.notp.signIn, { loginId: n2, loginOptions: o3 }, { token: s2 }))), waitForSession: pt((n2, o3) => new Promise((s2) => {
  const { pollingIntervalMs: i3, timeoutMs: a2 } = oe(o3);
  let r3;
  const p4 = setInterval(async () => {
    const o4 = await e.post(t.notp.session, { pendingRef: n2 });
    o4.ok && (clearInterval(p4), r3 && clearTimeout(r3), s2(P(Promise.resolve(o4))));
  }, i3);
  r3 = setTimeout(() => {
    s2({ error: { errorDescription: `Session polling timeout exceeded: ${a2}ms`, errorCode: "0" }, ok: false }), clearInterval(p4);
  }, a2);
})) });
var dt = Z(G("token"));
var ut = Z(Q("token"));
var ct;
var gt;
var ht = Z([(ct = "projectId", gt = G("projectId"), q(M(ct, gt))())])((e) => {
  const { projectId: n2, logger: o3, baseUrl: s2, cookiePolicy: i3, baseHeaders: a2 = {}, refreshCookieName: r3, fetch: p4 } = e;
  return l4 = b({ baseUrl: s2, projectId: n2, logger: o3, hooks: { get beforeRequest() {
    var t2;
    return null === (t2 = e.hooks) || void 0 === t2 ? void 0 : t2.beforeRequest;
  }, get afterRequest() {
    var t2;
    return null === (t2 = e.hooks) || void 0 === t2 ? void 0 : t2.afterRequest;
  }, get transformResponse() {
    var t2;
    return null === (t2 = e.hooks) || void 0 === t2 ? void 0 : t2.transformResponse;
  } }, cookiePolicy: i3, baseConfig: { baseHeaders: a2 }, refreshCookieName: r3, fetch: p4 }), { accessKey: te(l4), otp: Le(l4), magicLink: we(l4), enchantedLink: ge(l4), oauth: Te(l4), outbound: Pe(l4), saml: Ne(l4), totp: _e(l4), notp: lt(l4), webauthn: it(l4), password: Qe(l4), flow: fe(l4), refresh: ut((e2, n3, o4, s3) => {
    const i4 = {};
    o4 && (i4.externalToken = o4);
    const a3 = s3 ? t.tryRefresh : t.refresh;
    return P(l4.post(a3, i4, { token: e2, queryParams: n3 }));
  }), selectTenant: Z([z("tenantId")], [V('"token" must be string or undefined')])((e2, n3) => P(l4.post(t.selectTenant, { tenant: e2 }, { token: n3 }))), logout: ut((e2) => P(l4.post(t.logout, {}, { token: e2 }))), logoutAll: ut((e2) => P(l4.post(t.logoutAll, {}, { token: e2 }))), me: ut((e2) => P(l4.get(t.me, { token: e2 }))), myTenants: Z([Y('"tenants" must a string array or a boolean')], [V('"token" must be string or undefined')])((e2, n3) => {
    const o4 = {};
    return "boolean" == typeof e2 ? o4.dct = e2 : o4.ids = e2, P(l4.post(t.myTenants, o4, { token: n3 }));
  }), history: ut((e2) => P(l4.get(t.history, { token: e2 }))), isJwtExpired: dt(j), getTenants: dt(U), getJwtPermissions: dt(T), getJwtRoles: dt(R), getCurrentTenant: dt($), httpClient: l4 };
  var l4;
});
var vt = Object.assign(ht, { DeliveryMethods: ae });

// node_modules/js-cookie/dist/js.cookie.mjs
function assign(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = arguments[i3];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target;
}
var defaultConverter = {
  read: function(value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function init(converter, defaultAttributes) {
  function set(name, value, attributes) {
    if (typeof document === "undefined") {
      return;
    }
    attributes = assign({}, defaultAttributes, attributes);
    if (typeof attributes.expires === "number") {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }
    name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
    var stringifiedAttributes = "";
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue;
      }
      stringifiedAttributes += "; " + attributeName;
      if (attributes[attributeName] === true) {
        continue;
      }
      stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
    }
    return document.cookie = name + "=" + converter.write(value, name) + stringifiedAttributes;
  }
  function get(name) {
    if (typeof document === "undefined" || arguments.length && !name) {
      return;
    }
    var cookies = document.cookie ? document.cookie.split("; ") : [];
    var jar = {};
    for (var i3 = 0; i3 < cookies.length; i3++) {
      var parts = cookies[i3].split("=");
      var value = parts.slice(1).join("=");
      try {
        var found = decodeURIComponent(parts[0]);
        jar[found] = converter.read(value, found);
        if (name === found) {
          break;
        }
      } catch (e) {
      }
    }
    return name ? jar[name] : jar;
  }
  return Object.create(
    {
      set,
      get,
      remove: function(name, attributes) {
        set(
          name,
          "",
          assign({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function(attributes) {
        return init(this.converter, assign({}, this.attributes, attributes));
      },
      withConverter: function(converter2) {
        return init(assign({}, this.converter, converter2), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  );
}
var api = init(defaultConverter, { path: "/" });

// node_modules/@fingerprintjs/fingerprintjs-pro/dist/fp.esm.min.js
function r2(e, t2) {
  return function(e2, t3) {
    return Object.prototype.hasOwnProperty.call(e2, t3);
  }(e, t2) ? e[t2] : void 0;
}
function o2(e, t2, n2, r3) {
  var o3, i3 = document, a2 = "securitypolicyviolation", u3 = function(t3) {
    var n3 = new URL(e, location.href), r4 = t3.blockedURI;
    r4 !== n3.href && r4 !== n3.protocol.slice(0, -1) && r4 !== n3.origin || (o3 = t3, R3());
  };
  i3.addEventListener(a2, u3);
  var R3 = function() {
    return i3.removeEventListener(a2, u3);
  };
  return null == r3 || r3.then(R3, R3), Promise.resolve().then(t2).then(function(e2) {
    return R3(), e2;
  }, function(e2) {
    return new Promise(function(e3) {
      var t3 = new MessageChannel();
      t3.port1.onmessage = function() {
        return e3();
      }, t3.port2.postMessage(null);
    }).then(function() {
      if (R3(), o3) return n2(o3);
      throw e2;
    });
  });
}
var i2 = { default: "endpoint" };
var f2 = "Blocked by CSP";
var l2 = "The endpoint parameter is not a valid URL";
function E2(e) {
  for (var t2 = "", n2 = 0; n2 < e.length; ++n2) if (n2 > 0) {
    var r3 = e[n2].toLowerCase();
    r3 !== e[n2] ? t2 += " ".concat(r3) : t2 += e[n2];
  } else t2 += e[n2].toUpperCase();
  return t2;
}
var d2 = E2("WrongRegion");
var p2 = E2("SubscriptionNotActive");
var v2 = E2("UnsupportedVersion");
var _2 = E2("InstallationMethodRestricted");
var O2 = E2("HostnameRestricted");
var h2 = E2("IntegrationFailed");
var I2 = "API key required";
var U2 = "3.11.6";
var b2 = "Failed to load the JS script of the agent";
var C2 = "9319";
function M2(t2, n2) {
  var r3, o3, i3, a2, u3, R3, c3, s2 = [], E4 = (r3 = function(t3) {
    var n3 = __spreadArray([], t3, true);
    return { current: function() {
      return n3[0];
    }, postpone: function() {
      var e = n3.shift();
      void 0 !== e && n3.push(e);
    }, exclude: function() {
      n3.shift();
    } };
  }(t2), a2 = 100, u3 = 3e3, R3 = 0, o3 = function() {
    return Math.random() * Math.min(u3, a2 * Math.pow(2, R3++));
  }, i3 = /* @__PURE__ */ new Set(), [r3.current(), function(e, t3) {
    var n3, a3 = t3 instanceof Error ? t3.message : "";
    if (a3 === f2 || a3 === l2) r3.exclude(), n3 = 0;
    else if (a3 === C2) r3.exclude();
    else if (a3 === b2) {
      var u4 = Date.now() - e.getTime() < 50, R4 = r3.current();
      R4 && u4 && !i3.has(R4) && (i3.add(R4), n3 = 0), r3.postpone();
    } else r3.postpone();
    var c4 = r3.current();
    return void 0 === c4 ? void 0 : [c4, null != n3 ? n3 : e.getTime() + o3() - Date.now()];
  }]), d4 = E4[0], p4 = E4[1];
  if (void 0 === d4) return Promise.reject(new TypeError("The list of script URL patterns is empty"));
  var v4 = function(e) {
    var t3 = /* @__PURE__ */ new Date(), r4 = function(n3) {
      return s2.push({ url: e, startedAt: t3, finishedAt: /* @__PURE__ */ new Date(), error: n3 });
    }, o4 = n2(e);
    return o4.then(function() {
      return r4();
    }, r4), o4.catch(function(e2) {
      if (null != c3 || (c3 = e2), s2.length >= 5) throw c3;
      var n3 = p4(t3, e2);
      if (!n3) throw c3;
      var r5, o5 = n3[0], i4 = n3[1];
      return (r5 = i4, new Promise(function(e3) {
        return setTimeout(e3, r5);
      })).then(function() {
        return v4(o5);
      });
    });
  };
  return v4(d4).then(function(e) {
    return [e, s2];
  });
}
var K2 = "https://fpnpmcdn.net/v<version>/<apiKey>/loader_v<loaderVersion>.js";
var B2 = K2;
function F2(e) {
  var o3;
  e.scriptUrlPattern;
  var i3 = e.token, a2 = e.apiKey, u3 = void 0 === a2 ? i3 : a2, R3 = __rest(e, ["scriptUrlPattern", "token", "apiKey"]), c3 = null !== (o3 = r2(e, "scriptUrlPattern")) && void 0 !== o3 ? o3 : K2, s2 = function() {
    var e2 = [], t2 = function() {
      e2.push({ time: /* @__PURE__ */ new Date(), state: document.visibilityState });
    }, n2 = function(e3, t3, n3, r3) {
      return e3.addEventListener(t3, n3, r3), function() {
        return e3.removeEventListener(t3, n3, r3);
      };
    }(document, "visibilitychange", t2);
    return t2(), [e2, n2];
  }(), f4 = s2[0], l4 = s2[1];
  return Promise.resolve().then(function() {
    if (!u3 || "string" != typeof u3) throw new Error(I2);
    var e2 = function(e3, t2) {
      return (Array.isArray(e3) ? e3 : [e3]).map(function(e4) {
        return function(e5, t3) {
          var n2 = encodeURIComponent;
          return e5.replace(/<[^<>]+>/g, function(e6) {
            return "<version>" === e6 ? "3" : "<apiKey>" === e6 ? n2(t3) : "<loaderVersion>" === e6 ? n2(U2) : e6;
          });
        }(String(e4), t2);
      });
    }(c3, u3);
    return M2(e2, V2);
  }).catch(function(e2) {
    throw l4(), function(e3) {
      if (e3 instanceof Error && e3.message === C2) return new Error(b2);
      return e3;
    }(e2);
  }).then(function(e2) {
    var t2 = e2[0], r3 = e2[1];
    return l4(), t2.load(__assign(__assign({}, R3), { ldi: { attempts: r3, visibilityStates: f4 } }));
  });
}
function V2(e) {
  return o2(e, function() {
    return function(e2) {
      return new Promise(function(t2, n2) {
        if (function(e3) {
          if (URL.prototype) try {
            return new URL(e3, location.href), false;
          } catch (t3) {
            if (t3 instanceof Error && "TypeError" === t3.name) return true;
            throw t3;
          }
        }(e2)) throw new Error(l2);
        var r3 = document.createElement("script"), o3 = function() {
          var e3;
          return null === (e3 = r3.parentNode) || void 0 === e3 ? void 0 : e3.removeChild(r3);
        }, i3 = document.head || document.getElementsByTagName("head")[0];
        r3.onload = function() {
          o3(), t2();
        }, r3.onerror = function() {
          o3(), n2(new Error(b2));
        }, r3.async = true, r3.src = e2, i3.appendChild(r3);
      });
    }(e);
  }, function() {
    throw new Error(f2);
  }).then(k2);
}
function k2() {
  var e = window, t2 = "__fpjs_p_l_b", n2 = e[t2];
  if (function(e2, t3) {
    var n3, r3 = null === (n3 = Object.getOwnPropertyDescriptor) || void 0 === n3 ? void 0 : n3.call(Object, e2, t3);
    (null == r3 ? void 0 : r3.configurable) ? delete e2[t3] : r3 && !r3.writable || (e2[t3] = void 0);
  }(e, t2), "function" != typeof (null == n2 ? void 0 : n2.load)) throw new Error(C2);
  return n2;
}

// node_modules/@descope/web-js-sdk/dist/index.esm.js
var c2 = (e) => {
  try {
    return jwtDecode(e).exp;
  } catch (e2) {
    return null;
  }
};
var l3 = (e) => {
  const { refresh_expire_in: t2, refresh_token: n2 } = e;
  return t2 ? Math.floor(Date.now() / 1e3) + t2 : c2(n2);
};
var d3 = (e) => {
  const { expires_in: t2, expires_at: n2, access_token: o3 } = e;
  return n2 || (t2 ? Math.floor(Date.now() / 1e3) + t2 : o3 ? c2(o3) : void 0);
};
var u2 = (e, t2) => {
  var n2;
  return ["beforeRequest", "afterRequest"].reduce((n3, o3) => {
    var i3;
    return n3[o3] = [].concat((null === (i3 = e.hooks) || void 0 === i3 ? void 0 : i3[o3]) || []).concat((null == t2 ? void 0 : t2[o3]) || []), n3;
  }, null !== (n2 = e.hooks) && void 0 !== n2 ? n2 : e.hooks = {}), e;
};
var p3 = async (t2) => {
  if (!(null == t2 ? void 0 : t2.ok)) return {};
  const n2 = await (null == t2 ? void 0 : t2.clone().json());
  return ((t3) => {
    const { access_token: n3, id_token: o3, refresh_token: i3, refresh_expire_in: r3 } = t3, a2 = __rest(t3, ["access_token", "id_token", "refresh_token", "refresh_expire_in"]);
    return Object.assign({ sessionJwt: t3.sessionJwt || n3, idToken: o3, refreshJwt: t3.refreshJwt || i3, sessionExpiration: t3.sessionExpiration || d3(t3), cookieExpiration: t3.cookieExpiration || l3(t3) }, a2);
  })((null == n2 ? void 0 : n2.authInfo) || n2 || {});
};
var g2 = async (e) => {
  const t2 = await p3(e);
  return (null == t2 ? void 0 : t2.user) || ((null == t2 ? void 0 : t2.hasOwnProperty("userId")) ? t2 : void 0);
};
var f3 = "undefined" != typeof localStorage;
var w2 = (e, t2) => f3 && (null === localStorage || void 0 === localStorage ? void 0 : localStorage.setItem(e, t2));
var h3 = (e) => f3 && (null === localStorage || void 0 === localStorage ? void 0 : localStorage.getItem(e));
var v3 = (e) => f3 && (null === localStorage || void 0 === localStorage ? void 0 : localStorage.removeItem(e));
var y2 = (...e) => {
  console.debug(...e);
};
var m2 = "3.2.0";
var b3 = "undefined" != typeof window;
var S2 = Math.pow(2, 31) - 1;
var k3 = `https://descopecdn.com/npm/oidc-client-ts@${m2}/dist/browser/oidc-client-ts.min.js`;
var I3 = `https://cdn.jsdelivr.net/npm/oidc-client-ts@${m2}/dist/browser/oidc-client-ts.min.js`;
var _3 = (e) => {
  let t2 = ((n2 = e) ? n2.getTime() - (/* @__PURE__ */ new Date()).getTime() : 0) - 2e4;
  var n2;
  return t2 > S2 && (y2(`Timeout is too large (${t2}ms), setting it to ${S2}ms`), t2 = S2), t2;
};
var O3 = "DS";
var x2 = "DSR";
var U3 = "DSI";
function j2(e, t2, n2) {
  if (t2) {
    const { cookieDomain: o3, cookiePath: r3, cookieSameSite: a2, cookieExpiration: s2, cookieSecure: c3 } = n2, l4 = new Date(1e3 * s2), d4 = function(e2) {
      const t3 = window.location.hostname.split("."), n3 = e2.split(".");
      return t3.slice(-n3.length).join(".") === e2;
    }(o3);
    api.set(e, t2, { path: r3, domain: d4 ? o3 : void 0, expires: l4, sameSite: a2, secure: c3 });
  }
}
function C3(e = "") {
  return h3(`${e}${x2}`) || "";
}
function D2(e = "") {
  return api.get(O3) || h3(`${e}${O3}`) || "";
}
function R2(e = "") {
  return h3(`${e}${U3}`) || "";
}
function T2(e = "") {
  v3(`${e}${x2}`), v3(`${e}${O3}`), v3(`${e}${U3}`), api.remove(O3);
}
var A2 = b3 && (null === localStorage || void 0 === localStorage ? void 0 : localStorage.getItem("fingerprint.endpoint.url")) || "https://api.descope.com";
var E3 = "vsid";
var J2 = "vrid";
var $2 = "fp";
var L2 = (e = false) => {
  const t2 = localStorage.getItem($2);
  if (!t2) return null;
  const n2 = JSON.parse(t2);
  return (/* @__PURE__ */ new Date()).getTime() > n2.expiry && !e ? null : n2.value;
};
var N2 = async (e, t2 = A2) => {
  try {
    if (L2()) return;
    const n2 = (Date.now().toString(36) + Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2)).substring(0, 27), o3 = new URL(t2);
    o3.pathname = "/fXj8gt3x8VulJBna/x96Emn69oZwcd7I6";
    const i3 = new URL(t2);
    i3.pathname = "/fXj8gt3x8VulJBna/w78aRZnnDZ3Aqw0I";
    const c3 = i3.toString() + "?apiKey=<apiKey>&version=<version>&loaderVersion=<loaderVersion>", l4 = F2({ apiKey: e, endpoint: [o3.toString(), i2], scriptUrlPattern: [c3, B2] }), d4 = await l4, { requestId: u3 } = await d4.get({ linkedId: n2 }), p4 = ((e2, t3) => ({ [E3]: e2, [J2]: t3 }))(n2, u3);
    ((e2) => {
      const t3 = { value: e2, expiry: (/* @__PURE__ */ new Date()).getTime() + 864e5 };
      localStorage.setItem($2, JSON.stringify(t3));
    })(p4);
  } catch (e2) {
    console.warn("Could not load fingerprint", e2);
  }
};
var P2 = () => {
  localStorage.removeItem($2);
};
var K3 = (e) => {
  const t2 = L2(true);
  return t2 && e.body && (e.body.fpData = t2), e;
};
var q2 = "descopeFlowNonce";
var F3 = "X-Descope-Flow-Nonce";
var V3 = "/v1/flow/start";
var M3 = "/v1/flow/next";
var H2 = (e, t2 = q2) => `${t2}${e}`;
var B3 = (e, t2 = q2) => {
  try {
    const n2 = H2(e, t2);
    v3(n2);
  } catch (e2) {
    console.error("Error removing flow nonce:", e2);
  }
};
var G2 = (e) => {
  var t2;
  return (null === (t2 = /.*\|#\|(.*)/.exec(e)) || void 0 === t2 ? void 0 : t2[1]) || null;
};
var W2 = (e) => {
  var t2;
  return e.path === M3 && (null === (t2 = e.body) || void 0 === t2 ? void 0 : t2.executionId) ? G2(e.body.executionId) : null;
};
var X2 = "dls_last_user_login_id";
var Z2 = "dls_last_user_display_name";
var z2 = () => h3(X2);
var Q2 = () => h3(Z2);
var Y2 = (e) => async (...t2) => {
  var n2;
  t2[1] = t2[1] || {};
  const [, o3 = {}] = t2, i3 = z2(), r3 = Q2();
  i3 && (null !== (n2 = o3.lastAuth) && void 0 !== n2 || (o3.lastAuth = {}), o3.lastAuth.loginId = i3, o3.lastAuth.name = r3);
  return await e(...t2);
};
var ee2 = (e) => (t2) => async (...n2) => {
  const o3 = await t2(...n2);
  return e || (v3(X2), v3(Z2)), o3;
};
function te2() {
  const e = [];
  return { pub: (t2) => {
    e.forEach((e2) => e2(t2));
  }, sub: (t2) => {
    const n2 = e.push(t2) - 1;
    return () => e.splice(n2, 1);
  } };
}
var ne2 = (e) => (t2) => async (...n2) => {
  const o3 = await t2(...n2);
  return T2(e), o3;
};
async function oe2(e) {
  const t2 = function(e2) {
    var t3;
    const n3 = JSON.parse(e2);
    return n3.publicKey.challenge = le2(n3.publicKey.challenge), n3.publicKey.user.id = le2(n3.publicKey.user.id), null === (t3 = n3.publicKey.excludeCredentials) || void 0 === t3 || t3.forEach((e3) => {
      e3.id = le2(e3.id);
    }), n3;
  }(e), n2 = await navigator.credentials.create(t2);
  return o3 = n2, JSON.stringify({ id: o3.id, rawId: de2(o3.rawId), type: o3.type, response: { attestationObject: de2(o3.response.attestationObject), clientDataJSON: de2(o3.response.clientDataJSON) } });
  var o3;
}
async function ie2(e) {
  const t2 = se2(e);
  return ce2(await navigator.credentials.get(t2));
}
async function re2(e, t2) {
  const n2 = se2(e);
  n2.signal = t2.signal, n2.mediation = "conditional";
  return ce2(await navigator.credentials.get(n2));
}
async function ae2(e = false) {
  if (!b3) return Promise.resolve(false);
  const t2 = !!(window.PublicKeyCredential && navigator.credentials && navigator.credentials.create && navigator.credentials.get);
  return t2 && e && PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable ? PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable() : t2;
}
function se2(e) {
  var t2;
  const n2 = JSON.parse(e);
  return n2.publicKey.challenge = le2(n2.publicKey.challenge), null === (t2 = n2.publicKey.allowCredentials) || void 0 === t2 || t2.forEach((e2) => {
    e2.id = le2(e2.id);
  }), n2;
}
function ce2(e) {
  return JSON.stringify({ id: e.id, rawId: de2(e.rawId), type: e.type, response: { authenticatorData: de2(e.response.authenticatorData), clientDataJSON: de2(e.response.clientDataJSON), signature: de2(e.response.signature), userHandle: e.response.userHandle ? de2(e.response.userHandle) : void 0 } });
}
function le2(e) {
  const t2 = e.replace(/_/g, "/").replace(/-/g, "+");
  return Uint8Array.from(atob(t2), (e2) => e2.charCodeAt(0)).buffer;
}
function de2(e) {
  return btoa(String.fromCharCode.apply(null, new Uint8Array(e))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
}
var ue2;
var pe2 = (ue2 = (e) => ({ async signUp(t2, n2, o3) {
  const i3 = await e.webauthn.signUp.start(t2, window.location.origin, n2, o3);
  if (!i3.ok) return i3;
  const r3 = await oe2(i3.data.options);
  return await e.webauthn.signUp.finish(i3.data.transactionId, r3);
}, async signIn(t2, n2) {
  const o3 = await e.webauthn.signIn.start(t2, window.location.origin, void 0, void 0, n2);
  if (!o3.ok) return o3;
  const i3 = await ie2(o3.data.options);
  return await e.webauthn.signIn.finish(o3.data.transactionId, i3);
}, async signUpOrIn(t2, n2) {
  var o3;
  const i3 = await e.webauthn.signUpOrIn.start(t2, window.location.origin, n2);
  if (!i3.ok) return i3;
  if (null === (o3 = i3.data) || void 0 === o3 ? void 0 : o3.create) {
    const t3 = await oe2(i3.data.options);
    return await e.webauthn.signUp.finish(i3.data.transactionId, t3);
  }
  {
    const t3 = await ie2(i3.data.options);
    return await e.webauthn.signIn.finish(i3.data.transactionId, t3);
  }
}, async update(t2, n2, o3) {
  const i3 = await e.webauthn.update.start(t2, window.location.origin, n2, o3);
  if (!i3.ok) return i3;
  const r3 = await oe2(i3.data.options);
  return await e.webauthn.update.finish(i3.data.transactionId, r3);
}, helpers: { create: oe2, get: ie2, isSupported: ae2, conditional: re2 } }), (...e) => {
  const t2 = ue2(...e);
  return Object.assign(t2.signUp, e[0].webauthn.signUp), Object.assign(t2.signIn, e[0].webauthn.signIn), Object.assign(t2.signUpOrIn, e[0].webauthn.signUpOrIn), Object.assign(t2.update, e[0].webauthn.update), t2;
});
var ge2 = { config: "/fedcm/config" };
var fe2 = () => {
  if (window.crypto && window.crypto.getRandomValues) {
    const e = new Uint8Array(16);
    return window.crypto.getRandomValues(e), Array.from(e, (e2) => e2.toString(16).padStart(2, "0")).join("");
  }
  return Math.random().toString(36).substring(2);
};
async function we2(e, t2) {
  var n2;
  try {
    await he2(e, t2);
  } catch (e2) {
    null === (n2 = null == t2 ? void 0 : t2.onFailed) || void 0 === n2 || n2.call(t2, e2);
  }
}
async function he2(e, t2) {
  var n2, o3;
  const i3 = await async function(e2, t3 = "google", n3, o4, i4) {
    const r3 = fe2(), a2 = await async function() {
      return new Promise((e3, t4) => {
        if (window.google) return void e3(window.google.accounts.id);
        let n4 = document.getElementById("google-gsi-client-script");
        n4 || (n4 = document.createElement("script"), document.head.appendChild(n4), n4.async = true, n4.defer = true, n4.id = "google-gsi-client-script", n4.src = "https://accounts.google.com/gsi/client"), n4.onload = function() {
          window.google ? e3(window.google.accounts.id) : t4("Failed to load Google GSI client script - not loaded properly");
        }, n4.onerror = function() {
          t4("Failed to load Google GSI client script - failed to load");
        };
      });
    }(), s2 = await e2.oauth.getOneTapClientId(t3);
    if (!s2.ok) throw new Error("Failed to get OneTap client ID for provider " + t3);
    const c3 = s2.data.clientId;
    return new Promise((e3) => {
      var s3, l4;
      const d4 = (n4) => {
        e3({ provider: t3, nonce: r3, credential: null == n4 ? void 0 : n4.credential });
      };
      a2.initialize(Object.assign(Object.assign({}, n3), { itp_support: null === (s3 = null == n3 ? void 0 : n3.itp_support) || void 0 === s3 || s3, use_fedcm_for_prompt: null === (l4 = null == n3 ? void 0 : n3.use_fedcm_for_prompt) || void 0 === l4 || l4, client_id: c3, callback: d4, nonce: r3 })), a2.prompt((e4) => {
        var t4, n4;
        if (i4 && (null == e4 ? void 0 : e4.isDismissedMoment())) {
          const n5 = null === (t4 = e4.getDismissedReason) || void 0 === t4 ? void 0 : t4.call(e4);
          return null == i4 || i4(n5), void d4();
        }
        if (o4 && (null == e4 ? void 0 : e4.isSkippedMoment())) {
          const t5 = null === (n4 = e4.getSkippedReason) || void 0 === n4 ? void 0 : n4.call(e4);
          return null == o4 || o4(t5), void d4();
        }
      });
    });
  }(e, t2.provider, t2.oneTapConfig, t2.onSkipped, t2.onDismissed);
  if (!i3.credential) return null;
  if (null == t2 ? void 0 : t2.onCodeReceived) {
    const o4 = await e.oauth.verifyOneTapIDToken(i3.provider, i3.credential, i3.nonce, null == t2 ? void 0 : t2.loginOptions);
    if (!o4.ok || !o4.data) throw new Error("Failed to verify OneTap client ID for provider " + i3.provider);
    null === (n2 = null == t2 ? void 0 : t2.onCodeReceived) || void 0 === n2 || n2.call(t2, o4.data.code);
  } else {
    const n3 = await e.oauth.exchangeOneTapIDToken(i3.provider, i3.credential, i3.nonce, null == t2 ? void 0 : t2.loginOptions);
    if (!n3.ok || !n3.data) throw new Error("Failed to exchange OneTap client ID for provider " + i3.provider);
    null === (o3 = null == t2 ? void 0 : t2.onAuthenticated) || void 0 === o3 || o3.call(t2, n3.data);
  }
}
var ve2 = (e) => Object.assign(Object.assign({}, e.flow), { start: async (...t2) => {
  const n2 = await ae2(), o3 = Object.assign(Object.assign({ location: window.location.href }, t2[1]), { deviceInfo: { webAuthnSupport: n2 }, startOptionsVersion: 1 });
  return t2[1] = o3, e.flow.start(...t2);
} });
var ye2 = () => window.location.search.includes("code") && window.location.search.includes("state");
var me2;
var be2 = (e, t2) => new Promise((n2, o3) => {
  if (!e.length) return o3(new Error("No URLs provided to loadScriptWithFallback"));
  const i3 = t2();
  if (i3) return n2(i3);
  const r3 = e.shift(), a2 = document.createElement("script");
  a2.src = r3, a2.id = ((e2) => {
    let t3 = 0;
    for (let n3 = 0; n3 < e2.length; n3++) t3 = (t3 << 5) - t3 + e2.charCodeAt(n3), t3 |= 0;
    return Math.abs(t3).toString(16);
  })(r3), a2.onload = () => {
    const e2 = t2();
    if (e2) return n2(e2);
    throw new Error("Could not get entry after loading script from URL");
  }, a2.addEventListener("error", () => {
    be2(e, t2), a2.setAttribute("data-error", "true");
  }), document.body.appendChild(a2);
});
var Se2 = async (e, t2, n2) => {
  me2 || (me2 = (async () => {
    try {
      return __require("oidc-client-ts");
    } catch (e2) {
      return be2([k3, I3], () => window.oidc);
    }
  })());
  const { OidcClient: o3, WebStorageStateStore: i3 } = await me2;
  if (!o3) throw new Error("oidc-client-ts is not installed. Please install it by running `npm install oidc-client-ts`");
  const r3 = t2, a2 = (null == n2 ? void 0 : n2.redirectUri) || window.location.href, s2 = (null == n2 ? void 0 : n2.scope) || "openid email roles descope.custom_claims offline_access", c3 = `${r3}_user`;
  let l4 = e.httpClient.buildUrl(t2);
  (null == n2 ? void 0 : n2.applicationId) && (l4 = `${l4}/${n2.applicationId}`);
  const d4 = { authority: l4, client_id: t2, redirect_uri: a2, response_type: "code", scope: s2, stateStore: new i3({ store: window.localStorage, prefix: r3 }), loadUserInfo: true, fetchRequestCredentials: "same-origin" };
  return (null == n2 ? void 0 : n2.redirectUri) && (d4.redirect_uri = n2.redirectUri), (null == n2 ? void 0 : n2.scope) && (d4.scope = n2.scope), { client: new o3(d4), stateUserKey: c3 };
};
var ke2 = (e, t2, n2) => {
  const o3 = async () => {
    let o4, i4;
    return o4 && i4 || ({ client: o4, stateUserKey: i4 } = await Se2(e, t2, n2)), { client: o4, stateUserKey: i4 };
  }, i3 = async (t3 = "") => {
    var n3;
    const { client: i4, stateUserKey: r3 } = await o3(), a2 = await i4.processSigninResponse(t3 || window.location.href);
    var s2;
    return await (null === (n3 = e.httpClient.hooks) || void 0 === n3 ? void 0 : n3.afterRequest({}, new Response(JSON.stringify(a2)))), window.localStorage.setItem(r3, JSON.stringify({ id_token: (s2 = a2).id_token, session_state: s2.session_state, profile: s2.profile })), (() => {
      const e2 = new URL(window.location.href);
      e2.searchParams.delete("code"), e2.searchParams.delete("state"), window.history.replaceState({}, document.title, e2.toString());
    })(), a2;
  };
  return { loginWithRedirect: async (e2 = {}, t3 = false) => {
    const { client: n3 } = await o3(), i4 = await n3.createSigninRequest(e2), { url: r3 } = i4;
    return t3 || (window.location.href = r3), { ok: true, data: i4 };
  }, finishLogin: i3, finishLoginIfNeed: async (e2 = "") => {
    if (ye2()) return await i3(e2);
  }, refreshToken: async (t3) => {
    var n3;
    const { client: i4, stateUserKey: r3 } = await o3(), a2 = ((e2) => {
      const t4 = window.localStorage.getItem(e2);
      return t4 ? JSON.parse(t4) : null;
    })(r3);
    if (!a2) throw new Error("User not found in storage to refresh token");
    let s2 = t3;
    if (!s2) {
      const t4 = {};
      e.httpClient.hooks.beforeRequest(t4), s2 = t4.token;
    }
    const c3 = await i4.useRefreshToken({ state: { refresh_token: s2, session_state: a2.session_state, profile: a2.profile } });
    return await (null === (n3 = e.httpClient.hooks) || void 0 === n3 ? void 0 : n3.afterRequest({}, new Response(JSON.stringify(c3)))), c3;
  }, logout: async (e2, t3 = false) => {
    const { client: n3, stateUserKey: i4 } = await o3();
    e2 || (e2 = {}), e2.id_token_hint = e2.id_token_hint || R2(), e2.post_logout_redirect_uri = e2.post_logout_redirect_uri || window.location.href;
    const r3 = await n3.createSignoutRequest(e2), { url: a2 } = r3;
    return window.localStorage.removeItem(i4), t3 || window.location.replace(a2), r3;
  } };
};
var Ie2 = (/* @__PURE__ */ function(...e) {
  return (t2) => e.reduce((e2, t3) => t3(e2), t2);
}((t2) => (n2) => {
  var { fpKey: o3, fpLoad: i3 } = n2, r3 = __rest(n2, ["fpKey", "fpLoad"]);
  return b3 ? (o3 && i3 && N2(o3).catch(() => null), t2(u2(r3, { beforeRequest: K3 }))) : t2(r3);
}, (n2) => (i3) => {
  var { autoRefresh: r3 } = i3, a2 = __rest(i3, ["autoRefresh"]);
  if (!r3 || "undefined" != typeof window && window.descopeBridge) return n2(a2);
  const { clearAllTimers: s2, setTimer: c3 } = /* @__PURE__ */ (() => {
    const e = [];
    return { clearAllTimers: () => {
      for (; e.length; ) clearTimeout(e.pop());
    }, setTimer: (t2, n3) => {
      e.push(setTimeout(t2, n3));
    } };
  })();
  let l4, d4;
  b3 && document.addEventListener("visibilitychange", () => {
    "visible" === document.visibilityState && l4 && /* @__PURE__ */ new Date() > l4 && (y2("Expiration time passed, refreshing session"), g3.refresh(C3() || d4));
  });
  const g3 = n2(u2(a2, { afterRequest: async (e, n3) => {
    const { sessionJwt: o3, refreshJwt: i4, sessionExpiration: r4 } = await p3(n3);
    if (401 === (null == n3 ? void 0 : n3.status)) y2("Received 401, canceling all timers"), s2();
    else if (o3 || r4) {
      if (l4 = ((e3, n5) => {
        if (n5) return new Date(1e3 * n5);
        y2("Could not extract expiration time from session token, trying to decode the token");
        try {
          const n6 = jwtDecode(e3);
          if (n6.exp) return new Date(1e3 * n6.exp);
        } catch (e4) {
          return null;
        }
      })(o3, r4), !l4) return void y2("Could not extract expiration time from session token");
      d4 = i4;
      const e2 = _3(l4);
      if (s2(), e2 <= 2e4) return void y2("Session is too close to expiration, not setting refresh timer");
      const n4 = new Date(Date.now() + e2).toLocaleTimeString("en-US", { hour12: false });
      y2(`Setting refresh timer for ${n4}. (${e2}ms)`), c3(() => {
        y2("Refreshing session due to timer"), g3.refresh(C3() || i4);
      }, e2);
    }
  } }));
  return ne(g3, ["logout", "logoutAll", "oidc.logout"], (e) => async (...t2) => {
    const n3 = await e(...t2);
    return y2("Clearing all timers"), s2(), n3;
  });
}, (e) => (t2) => e(Object.assign(Object.assign({}, t2), { baseHeaders: Object.assign({ "x-descope-sdk-name": "web-js", "x-descope-sdk-version": "1.35.1" }, t2.baseHeaders) })), (e) => (t2) => {
  const n2 = te2(), i3 = te2(), r3 = te2(), a2 = e(u2(t2, { afterRequest: async (e2, t3) => {
    if (401 === (null == t3 ? void 0 : t3.status)) i3.pub(null), r3.pub(null), n2.pub(null);
    else {
      const e3 = await g2(t3);
      e3 && r3.pub(e3);
      const { sessionJwt: o3, sessionExpiration: a3 } = await p3(t3);
      o3 && i3.pub(o3), (a3 || o3) && n2.pub(a3 || 42);
    }
  } })), s2 = ne(a2, ["logout", "logoutAll", "oidc.logout"], (e2) => async (...t3) => {
    const o3 = await e2(...t3);
    return i3.pub(null), r3.pub(null), n2.pub(null), o3;
  });
  return Object.assign(s2, { onSessionTokenChange: i3.sub, onUserChange: r3.sub, onIsAuthenticatedChange: (e2) => n2.sub((t3) => {
    e2(!!t3);
  }) });
}, (t2) => (n2) => {
  const { enableFlowNonce: o3 = true, nonceStoragePrefix: i3 = q2 } = n2, r3 = __rest(n2, ["enableFlowNonce", "nonceStoragePrefix"]);
  if (!o3) return t2(r3);
  ((e = q2) => {
    try {
      if (!f3) return;
      for (let t3 = 0; t3 < localStorage.length; t3++) {
        const n3 = localStorage.key(t3);
        if (n3 && n3.startsWith(e)) {
          const e2 = h3(n3);
          if (e2) try {
            JSON.parse(e2).expiry < Date.now() && v3(n3);
          } catch (e3) {
            v3(n3);
          }
        }
      }
    } catch (e2) {
      console.error("Error cleaning up expired nonces:", e2);
    }
  })(i3);
  return t2(u2(r3, { afterRequest: async (e, t3) => {
    if (e.path !== V3 && e.path !== M3) return;
    const { nonce: n3, executionId: o4 } = await (async (e2, t4) => {
      try {
        const n4 = t4.headers.get(F3);
        let o5 = await t4.clone().json().then((e3) => (null == e3 ? void 0 : e3.executionId) || null).catch(() => null);
        return o5 || (o5 = W2(e2)), { nonce: n4, executionId: G2(o5) };
      } catch (e3) {
        return { nonce: null, executionId: null };
      }
    })(e, t3);
    if (n3 && o4) {
      ((e2, t4, n4, o5 = q2) => {
        try {
          const i4 = H2(e2, o5), r4 = n4 ? 172800 : 10800, a2 = { value: t4, expiry: Date.now() + 1e3 * r4, isStart: n4 };
          w2(i4, JSON.stringify(a2));
        } catch (e3) {
          console.error("Error setting flow nonce:", e3);
        }
      })(o4, n3, e.path === V3, i3);
    }
  }, beforeRequest: (e) => {
    if (e.path === M3) {
      const t3 = W2(e);
      if (t3) {
        const n3 = ((e2, t4 = q2) => {
          try {
            const n4 = H2(e2, t4), o4 = h3(n4);
            if (!o4) return null;
            const i4 = JSON.parse(o4);
            return i4.expiry < Date.now() ? (B3(e2, t4), null) : i4.value;
          } catch (e3) {
            return console.error("Error getting flow nonce:", e3), null;
          }
        })(t3, i3);
        n3 && (e.headers = e.headers || {}, e.headers[F3] = n3);
      }
    }
    return e;
  } }));
}, (t2) => (n2) => {
  var { storeLastAuthenticatedUser: i3 = true, keepLastAuthenticatedUserAfterLogout: r3 = false } = n2, a2 = __rest(n2, ["storeLastAuthenticatedUser", "keepLastAuthenticatedUserAfterLogout"]);
  if (!i3) return Object.assign(t2(a2), { getLastUserLoginId: z2, getLastUserDisplayName: Q2 });
  const s2 = t2(u2(a2, { afterRequest: async (e, t3) => {
    var n3;
    const o3 = await g2(t3), i4 = null === (n3 = null == o3 ? void 0 : o3.loginIds) || void 0 === n3 ? void 0 : n3[0], r4 = null == o3 ? void 0 : o3.name;
    i4 && (((e2) => {
      w2(X2, e2);
    })(i4), ((e2) => {
      w2(Z2, e2);
    })(r4));
  } }));
  let c3 = ne(s2, ["flow.start"], Y2);
  return c3 = ne(c3, ["logout", "logoutAll"], ee2(r3)), Object.assign(c3, { getLastUserLoginId: z2, getLastUserDisplayName: Q2 });
}, (t2) => (n2) => {
  var { persistTokens: i3, sessionTokenViaCookie: r3, storagePrefix: a2 } = n2, s2 = __rest(n2, ["persistTokens", "sessionTokenViaCookie", "storagePrefix"]);
  if (!i3 || !b3) return t2(s2);
  const c3 = t2(u2(s2, { beforeRequest: (l4 = a2, (e) => Object.assign(e, { token: e.token || C3(l4) })), afterRequest: async (e, t3) => {
    const n3 = /^\/v\d+\/mgmt\//.test(e.path);
    401 === (null == t3 ? void 0 : t3.status) ? n3 || T2(a2) : ((e2 = {}, t4 = false, n4 = "") => {
      var o3;
      const { sessionJwt: i4, refreshJwt: r4 } = e2;
      if (r4 && w2(`${n4}${x2}`, r4), i4) if (t4) {
        const n5 = t4.sameSite || "Strict", r5 = null === (o3 = t4.secure) || void 0 === o3 || o3;
        j2(O3, i4, Object.assign(Object.assign({}, e2), { cookieSameSite: n5, cookieSecure: r5 }));
      } else w2(`${n4}${O3}`, i4);
      e2.idToken && w2(`${n4}${U3}`, e2.idToken);
    })(await p3(t3), r3, a2);
  } }));
  var l4;
  const d4 = ne(c3, ["logout", "logoutAll", "oidc.logout"], ne2(a2));
  return Object.assign(d4, { getRefreshToken: () => C3(a2), getSessionToken: () => D2(a2), getIdToken: () => R2(a2) });
}))((e) => {
  const t2 = vt(e), o3 = ke2(t2, e.projectId, e.oidcConfig);
  return Object.assign(Object.assign({}, t2), { refresh: async (n2, i4) => {
    var r4;
    if (e.oidcConfig) try {
      return await o3.refreshToken(n2), Promise.resolve({ ok: true });
    } catch (e2) {
      return Promise.resolve({ ok: false, error: { errorCode: "J161001", errorDescription: e2.toString() } });
    }
    const a2 = D2(), s2 = C3();
    let c3 = "";
    if (e.getExternalToken) try {
      c3 = await (null === (r4 = e.getExternalToken) || void 0 === r4 ? void 0 : r4.call(e));
    } catch (e2) {
      y2("Error getting external token while refreshing", e2);
    }
    return t2.refresh(n2, { dcs: a2 ? "t" : "f", dcr: s2 ? "t" : "f" }, c3, i4);
  }, logout: async (n2) => {
    if (e.oidcConfig) try {
      return await o3.logout({ id_token_hint: n2 }), Promise.resolve({ ok: true });
    } catch (e2) {
      return Promise.resolve({ ok: false, error: { errorCode: "J161000", errorDescription: e2.toString() } });
    }
    return t2.logout(n2);
  }, flow: ve2(t2), webauthn: pe2(t2), fedcm: (i3 = t2, r3 = e.projectId, { onetap: { requestExchangeCode(e2) {
    we2(i3, e2);
  }, requestAuthentication(e2) {
    we2(i3, e2);
  } }, async oneTap(e2, t3, n2, o4, r4) {
    await he2(i3, { provider: e2, oneTapConfig: t3, loginOptions: n2, onSkipped: o4, onDismissed: r4 });
  }, async launch(e2) {
    var t3;
    const n2 = { identity: { context: e2 || "signin", providers: [{ configURL: i3.httpClient.buildUrl(r3 + ge2.config), clientId: r3 }] } }, o4 = await (null === (t3 = navigator.credentials) || void 0 === t3 ? void 0 : t3.get(n2));
    return i3.refresh(o4.token);
  }, isSupported: () => b3 && "IdentityCredential" in window, async isLoggedIn(e2) {
    var t3;
    const n2 = i3.httpClient.buildUrl(r3 + ge2.config);
    try {
      const o4 = { identity: { context: e2 || "signin", providers: [{ configURL: n2, clientId: r3 }] } }, i4 = await (null === (t3 = navigator.credentials) || void 0 === t3 ? void 0 : t3.get(o4));
      return !!i4 && !!i4.token;
    } catch (e3) {
      return false;
    }
  } }), oidc: o3 });
  var i3, r3;
});

export {
  N2 as N,
  P2 as P,
  Ie2 as Ie
};
/*! Bundled license information:

js-cookie/dist/js.cookie.mjs:
  (*! js-cookie v3.0.5 | MIT *)
*/
//# sourceMappingURL=chunk-5SHIU7TC.js.map
