{
  "version": 3,
  "sources": ["../../jwt-decode/build/esm/index.js", "../../@descope/core-js-sdk/src/constants/apiPaths.ts", "../../@descope/core-js-sdk/src/constants/index.ts", "../../@descope/core-js-sdk/src/httpClient/helpers/createFetchLogger.ts", "../../@descope/core-js-sdk/src/httpClient/helpers/getClientSessionId.ts", "../../@descope/core-js-sdk/src/httpClient/types.ts", "../../@descope/core-js-sdk/src/httpClient/urlBuilder.ts", "../../@descope/core-js-sdk/src/httpClient/utils.ts", "../../@descope/core-js-sdk/src/httpClient/index.ts", "../../@descope/core-js-sdk/src/httpClient/helpers/index.ts", "../../@descope/core-js-sdk/src/constants/httpStatusCodes.ts", "../../@descope/core-js-sdk/src/sdk/helpers/index.ts", "../../@descope/core-js-sdk/src/sdk/validations/core.ts", "../../@descope/core-js-sdk/src/sdk/validations/validators.ts", "../../@descope/core-js-sdk/src/sdk/validations/index.ts", "../../@descope/core-js-sdk/src/sdk/accesskey.ts", "../../@descope/core-js-sdk/src/utils/wrapWith/index.ts", "../../@descope/core-js-sdk/src/utils/utils.ts", "../../@descope/core-js-sdk/src/sdk/types.ts", "../../@descope/core-js-sdk/src/sdk/enchantedLink/validations.ts", "../../@descope/core-js-sdk/src/sdk/enchantedLink/index.ts", "../../@descope/core-js-sdk/src/sdk/flow/index.ts", "../../@descope/core-js-sdk/src/sdk/magicLink/validations.ts", "../../@descope/core-js-sdk/src/sdk/magicLink/index.ts", "../../@descope/core-js-sdk/src/sdk/oauth/types.ts", "../../@descope/core-js-sdk/src/sdk/oauth/index.ts", "../../@descope/core-js-sdk/src/sdk/outbound/validations.ts", "../../@descope/core-js-sdk/src/sdk/outbound/index.ts", "../../@descope/core-js-sdk/src/sdk/otp/index.ts", "../../@descope/core-js-sdk/src/sdk/saml.ts", "../../@descope/core-js-sdk/src/sdk/totp.ts", "../../@descope/core-js-sdk/src/sdk/password/validations.ts", "../../@descope/core-js-sdk/src/sdk/password/index.ts", "../../@descope/core-js-sdk/src/sdk/webauthn.ts", "../../@descope/core-js-sdk/src/sdk/notp/index.ts", "../../@descope/core-js-sdk/src/sdk/index.ts", "../../@descope/core-js-sdk/src/createSdk.ts", "../../@descope/core-js-sdk/src/index.ts", "../../js-cookie/dist/js.cookie.mjs", "../../@fingerprintjs/fingerprintjs-pro/dist/fp.esm.min.js", "../../@descope/web-js-sdk/src/enhancers/helpers/index.ts", "../../@descope/web-js-sdk/src/enhancers/helpers/logger.ts", "../../@descope/web-js-sdk/src/constants.ts", "../../@descope/web-js-sdk/src/enhancers/withAutoRefresh/helpers.ts", "../../@descope/web-js-sdk/src/enhancers/withPersistTokens/constants.ts", "../../@descope/web-js-sdk/src/enhancers/withPersistTokens/helpers.ts", "../../@descope/web-js-sdk/src/enhancers/withFingerprint/constants.ts", "../../@descope/web-js-sdk/src/enhancers/withFingerprint/helpers.ts", "../../@descope/web-js-sdk/src/enhancers/withFingerprint/index.ts", "../../@descope/web-js-sdk/src/enhancers/withFlowNonce/constants.ts", "../../@descope/web-js-sdk/src/enhancers/withFlowNonce/helpers.ts", "../../@descope/web-js-sdk/src/enhancers/withLastLoggedInUser/constants.ts", "../../@descope/web-js-sdk/src/enhancers/withLastLoggedInUser/helpers.ts", "../../@descope/web-js-sdk/src/enhancers/withLastLoggedInUser/index.ts", "../../@descope/web-js-sdk/src/enhancers/withNotifications/helpers.ts", "../../@descope/web-js-sdk/src/enhancers/withNotifications/index.ts", "../../@descope/web-js-sdk/src/enhancers/withPersistTokens/index.ts", "../../@descope/web-js-sdk/src/sdk/webauthn.ts", "../../@descope/web-js-sdk/src/apiPaths.ts", "../../@descope/web-js-sdk/src/sdk/fedcm.ts", "../../@descope/web-js-sdk/src/sdk/flow.ts", "../../@descope/web-js-sdk/src/sdk/oidc/helpers.ts", "../../@descope/web-js-sdk/src/sdk/oidc/index.ts", "../../@descope/web-js-sdk/src/index.ts", "../../@descope/web-js-sdk/src/enhancers/helpers/compose.ts", "../../@descope/web-js-sdk/src/enhancers/withAutoRefresh/index.ts", "../../@descope/web-js-sdk/src/enhancers/withAnalytics.ts", "../../@descope/web-js-sdk/src/enhancers/withFlowNonce/index.ts", "../../@descope/web-js-sdk/src/sdk/index.ts"],
  "sourcesContent": ["export class InvalidTokenError extends Error {\n}\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n        return \"%\" + code;\n    }));\n}\nfunction base64UrlDecode(str) {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"base64 string is not of the correct length\");\n    }\n    try {\n        return b64DecodeUnicode(output);\n    }\n    catch (err) {\n        return atob(output);\n    }\n}\nexport function jwtDecode(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n    }\n    options || (options = {});\n    const pos = options.header === true ? 0 : 1;\n    const part = token.split(\".\")[pos];\n    if (typeof part !== \"string\") {\n        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);\n    }\n    let decoded;\n    try {\n        decoded = base64UrlDecode(part);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);\n    }\n    try {\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);\n    }\n}\n", "/** API paths for the Descope service APIs */\nexport default {\n  accessKey: {\n    exchange: '/v1/auth/accesskey/exchange',\n  },\n  otp: {\n    verify: '/v1/auth/otp/verify',\n    signIn: '/v1/auth/otp/signin',\n    signUp: '/v1/auth/otp/signup',\n    update: {\n      email: '/v1/auth/otp/update/email',\n      phone: '/v1/auth/otp/update/phone',\n    },\n    signUpOrIn: '/v1/auth/otp/signup-in',\n  },\n  magicLink: {\n    verify: '/v1/auth/magiclink/verify',\n    signIn: '/v1/auth/magiclink/signin',\n    signUp: '/v1/auth/magiclink/signup',\n    update: {\n      email: '/v1/auth/magiclink/update/email',\n      phone: '/v1/auth/magiclink/update/phone',\n    },\n    signUpOrIn: '/v1/auth/magiclink/signup-in',\n  },\n  enchantedLink: {\n    verify: '/v1/auth/enchantedlink/verify',\n    signIn: '/v1/auth/enchantedlink/signin',\n    signUp: '/v1/auth/enchantedlink/signup',\n    session: '/v1/auth/enchantedlink/pending-session',\n    update: {\n      email: '/v1/auth/enchantedlink/update/email',\n    },\n    signUpOrIn: '/v1/auth/enchantedlink/signup-in',\n  },\n  oauth: {\n    start: '/v1/auth/oauth/authorize',\n    exchange: '/v1/auth/oauth/exchange',\n    startNative: 'v1/auth/oauth/native/start',\n    finishNative: 'v1/auth/oauth/native/finish',\n    oneTap: {\n      getOneTapClientId: '/v1/auth/onetap/clientid/{provider}',\n      exchangeOneTapIDToken: '/v1/auth/onetap/idtoken/exchange',\n      verifyOneTapIDToken: '/v1/auth/onetap/idtoken/verify',\n    },\n  },\n  outbound: {\n    connect: '/v1/outbound/oauth/connect',\n  },\n  saml: {\n    start: '/v1/auth/saml/authorize',\n    exchange: '/v1/auth/saml/exchange',\n  },\n  totp: {\n    verify: '/v1/auth/totp/verify',\n    signUp: '/v1/auth/totp/signup',\n    update: '/v1/auth/totp/update',\n  },\n  notp: {\n    signIn: '/v1/auth/notp/whatsapp/signin',\n    signUp: '/v1/auth/notp/whatsapp/signup',\n    signUpOrIn: '/v1/auth/notp/whatsapp/signup-in',\n    session: '/v1/auth/notp/pending-session',\n  },\n  webauthn: {\n    signUp: {\n      start: '/v1/auth/webauthn/signup/start',\n      finish: '/v1/auth/webauthn/signup/finish',\n    },\n    signIn: {\n      start: '/v1/auth/webauthn/signin/start',\n      finish: '/v1/auth/webauthn/signin/finish',\n    },\n    signUpOrIn: {\n      start: '/v1/auth/webauthn/signup-in/start',\n    },\n    update: {\n      start: 'v1/auth/webauthn/update/start',\n      finish: '/v1/auth/webauthn/update/finish',\n    },\n  },\n  password: {\n    signUp: '/v1/auth/password/signup',\n    signIn: '/v1/auth/password/signin',\n    sendReset: '/v1/auth/password/reset',\n    update: '/v1/auth/password/update',\n    replace: '/v1/auth/password/replace',\n    policy: '/v1/auth/password/policy',\n  },\n  refresh: '/v1/auth/refresh',\n  tryRefresh: '/v1/auth/try-refresh',\n  selectTenant: '/v1/auth/tenant/select',\n  logout: '/v1/auth/logout',\n  logoutAll: '/v1/auth/logoutall',\n  me: '/v1/auth/me',\n  myTenants: '/v1/auth/me/tenants',\n  history: '/v1/auth/me/history',\n  flow: {\n    start: '/v1/flow/start',\n    next: '/v1/flow/next',\n  },\n};\n", "/** Default Descope API URL */\nexport const BASE_URL_REGION_PLACEHOLDER = '<region>';\nexport const DEFAULT_BASE_API_URL = `https://api.${BASE_URL_REGION_PLACEHOLDER}descope.com`;\n\n/** Default magic link polling interval for checking if the user clicked on the magic-link/enchanted-link/notp */\nexport const MIN_POLLING_INTERVAL_MS = 1000; // 1 second\n/** Default maximum time we are willing to wait for the magic-link/enchanted-link/notp to be clicked */\nexport const MAX_POLLING_TIMEOUT_MS = 1000 * 60 * 10; // 10 minutes\n\n/**  Descope current tenant claim */\nexport const DESCOPE_CURRENT_TENANT_CLAIM = 'dct';\n\n/** API paths to the Descope service */\nexport { default as apiPaths } from './apiPaths';\n", "import { Logger } from '../../sdk/types';\nimport { Fetch } from '../types';\n\n/** Build a log message around HTTP calls  */\nconst httpLogBuilder = () => {\n  const msg: {\n    Title?: string;\n    Url?: string;\n    Method?: string;\n    Headers?: string;\n    Body?: string;\n    Status?: string;\n    Retries?: number;\n  } = {};\n\n  return {\n    headers(headers: HeadersInit) {\n      const headersObj =\n        typeof headers.entries === 'function'\n          ? Object.fromEntries(headers.entries())\n          : headers;\n      msg.Headers = JSON.stringify(headersObj);\n\n      return this;\n    },\n\n    body(body: string) {\n      msg.Body = body;\n      return this;\n    },\n\n    url(url: URL | string) {\n      msg.Url = url.toString();\n      return this;\n    },\n\n    method(method: string) {\n      msg.Method = method;\n      return this;\n    },\n\n    title(title: string) {\n      msg.Title = title;\n      return this;\n    },\n\n    status(status: string) {\n      msg.Status = status;\n      return this;\n    },\n\n    retries(retries: number) {\n      msg.Retries = retries;\n      return this;\n    },\n\n    build() {\n      return Object.keys(msg)\n        .flatMap((key) =>\n          msg[key] ? [`${key !== 'Title' ? `${key}: ` : ''}${msg[key]}`] : [],\n        )\n        .join('\\n');\n    },\n  };\n};\n\n/** Log the request object */\nconst buildRequestLog = (args: Parameters<Fetch>) =>\n  httpLogBuilder()\n    .title('Request')\n    .url(args[0])\n    .method(args[1].method)\n    .headers(args[1].headers)\n    .body(args[1].body)\n    .build();\n\n// we should retry once in case we got these status codes:\n// 521: Web Server Is Down (Cloudflare error)\n// 524: A Timeout Occurred (Cloudflare error)\nconst retryStatusCodes = [521, 524];\n\n/** Log the response object */\nconst buildResponseLog = async (resp: Response & { retries?: number }) => {\n  const respBody = await resp.text();\n\n  return httpLogBuilder()\n    .title('Response')\n    .url(resp.url.toString())\n    .status(`${resp.status} ${resp.statusText}`)\n    .headers(resp.headers)\n    .body(respBody)\n    .retries(resp.retries)\n    .build();\n};\n\nconst fetchWrapper =\n  (fetch: Fetch) =>\n  async (...args: Parameters<Fetch>) => {\n    let resp: Response & { retries?: number } = await fetch(...args);\n\n    if (retryStatusCodes.includes(resp.status)) {\n      resp = await fetch(...args);\n      resp.retries = 1;\n    }\n\n    // we found out that cloning the response is problematic when using node fetch\n    // so instead, we are reading the body stream once and overriding the clone, text & json functions\n    const respText = await resp.text();\n\n    resp.text = () => Promise.resolve(respText);\n    resp.json = () => Promise.resolve(JSON.parse(respText));\n    resp.clone = () => resp;\n\n    return resp;\n  };\n\n/**\n * Create a fetch with a logger wrapped around it if a logger is given\n * @param logger Logger to send the logs to\n * @param receivedFetch Fetch to be used or built-in fetch if not provided\n *\n */\nconst createFetchLogger = (logger: Logger, receivedFetch?: Fetch) => {\n  const baseFetch = receivedFetch || fetch;\n  if (!baseFetch)\n    // eslint-disable-next-line no-console\n    logger?.warn(\n      'Fetch is not defined, you will not be able to send http requests, if you are running in a test, make sure fetch is defined globally',\n    );\n\n  if (!logger) return fetchWrapper(baseFetch);\n  return async (...args: Parameters<Fetch>) => {\n    if (!baseFetch)\n      throw Error(\n        'Cannot send http request, fetch is not defined, if you are running in a test, make sure fetch is defined globally',\n      );\n    logger.log(buildRequestLog(args));\n    const resp = await fetchWrapper(baseFetch)(...args);\n\n    logger[resp.ok ? 'log' : 'error'](await buildResponseLog(resp));\n\n    return resp;\n  };\n};\n\nexport default createFetchLogger;\n", "let sessionId: string;\n\nexport const getClientSessionId = (): string => {\n  if (sessionId) {\n    return sessionId;\n  }\n  const currentDate = new Date();\n  const utcString = `${currentDate.getUTCFullYear().toString()}-${(\n    currentDate.getUTCMonth() + 1\n  )\n    .toString()\n    .padStart(2, '0')}-${currentDate\n    .getUTCDate()\n    .toString()\n    .padStart(2, '0')}-${currentDate\n    .getUTCHours()\n    .toString()\n    .padStart(2, '0')}:${currentDate\n    .getUTCMinutes()\n    .toString()\n    .padStart(2, '0')}:${currentDate\n    .getUTCSeconds()\n    .toString()\n    .padStart(2, '0')}:${currentDate.getUTCMilliseconds().toString()}`;\n  const randomSuffix = Math.floor(1000 + Math.random() * 9000);\n  sessionId = `${utcString}-${randomSuffix}`;\n  return sessionId;\n};\n", "import { Logger } from '../sdk/types';\n\n/** Request configuration including headers, query params and token */\ntype HttpClientReqConfig = {\n  headers?: HeadersInit;\n  queryParams?: { [key: string]: string };\n  token?: string;\n};\n\nexport type ExtendedResponse = Response & { cookies: Record<string, string> };\n\n/** HTTP methods we use in the client */\nexport enum HTTPMethods {\n  get = 'GET',\n  delete = 'DELETE',\n  post = 'POST',\n  put = 'PUT',\n  patch = 'PATCH',\n}\n\n/** HTTP Client type that implements the HTTP method calls. Descopers can provide their own HTTP client although required only in rare cases. */\nexport type HttpClient = {\n  get: (path: string, config?: HttpClientReqConfig) => Promise<Response>;\n  post: (\n    path: string,\n    body?: any,\n    config?: HttpClientReqConfig,\n  ) => Promise<Response>;\n  patch: (\n    path: string,\n    body?: any,\n    config?: HttpClientReqConfig,\n  ) => Promise<Response>;\n  put: (\n    path: string,\n    body?: any,\n    config?: HttpClientReqConfig,\n  ) => Promise<Response>;\n  delete: (path: string, config?: HttpClientReqConfig) => Promise<Response>;\n  hooks?: Hooks;\n  buildUrl: (path: string, queryParams?: { [key: string]: string }) => string;\n};\n\nexport type Fetch = typeof fetch;\n\n/** Parameters for the HTTP client. Defaults should work for most cases. */\nexport type CreateHttpClientConfig = {\n  baseUrl?: string;\n  projectId: string;\n  baseConfig?: { baseHeaders: HeadersInit };\n  logger?: Logger;\n  hooks?: Hooks;\n  cookiePolicy?: RequestCredentials | null;\n  refreshCookieName?: string;\n  fetch?: Fetch;\n};\n\n/** For before-request hook allows overriding parts of the request */\nexport type RequestConfig = {\n  path: string;\n  headers?: HeadersInit;\n  queryParams?: { [key: string]: string };\n  body?: any;\n  method: HTTPMethods;\n  token?: string;\n};\n\nexport type BeforeRequest = (config: RequestConfig) => RequestConfig;\n\nexport type AfterRequest = (\n  req: RequestConfig,\n  res: Response,\n) => void | Promise<void>;\n\n/** Hooks before and after the request is made */\nexport type Hooks = {\n  beforeRequest?: BeforeRequest;\n  afterRequest?: AfterRequest;\n  transformResponse?: (\n    mutableResponse: ExtendedResponse,\n  ) => Promise<ExtendedResponse>;\n};\n\nexport type MultipleHooks = {\n  beforeRequest?: BeforeRequest | BeforeRequest[];\n  afterRequest?: AfterRequest | AfterRequest[];\n  transformResponse?: (\n    mutableResponse: ExtendedResponse,\n  ) => Promise<ExtendedResponse>;\n};\n", "import { BASE_URL_REGION_PLACEHOLDER } from '../constants';\n\n/** Build URL with given parts */\nexport const urlBuilder = ({\n  path,\n  baseUrl,\n  queryParams,\n  projectId,\n}: {\n  path: string;\n  baseUrl: string;\n  queryParams?: { [key: string]: string };\n  projectId: string;\n}) => {\n  // NOTE: many URL and URLSearchParams functions and fields are NOT SUPPORTED by the react-native runtime.\n  // To add insult to injury - it adds a trailing slash almost no matter what the input is:\n  // https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Blob/URL.js#L144\n  // Do not replace unless testing with all of the core-dependent projects\n  const region = projectId.slice(1, -27);\n  baseUrl = baseUrl.replace(\n    BASE_URL_REGION_PLACEHOLDER,\n    region ? region + '.' : '',\n  );\n  // append path to base\n  let url = path\n    ? `${baseUrl.replace(/\\/$/, '')}/${path?.replace(/^\\//, '')}`\n    : baseUrl;\n\n  // add query params if given\n  if (queryParams) {\n    const keys = Object.keys(queryParams);\n    keys.forEach((key: string, index: number) => {\n      url = `${url}${index === 0 ? '?' : ''}${key}=${encodeURIComponent(\n        queryParams[key],\n      )}${index === keys.length - 1 ? '' : '&'}`;\n    });\n  }\n\n  return url;\n};\n", "/* eslint-disable no-nested-ternary */\n\ntype SdkHeaders = HeadersInit | Record<string, () => string>;\n\nconst getSrcArr = (source: SdkHeaders) => {\n  if (Array.isArray(source)) return source;\n  if (source instanceof Headers) return Array.from(source.entries());\n  if (!source) return [];\n  return Object.entries(source);\n};\n\n/** Merge the given list of headers into a single Headers object */\nexport const mergeHeaders = (...sources: SdkHeaders[]) =>\n  new Headers(\n    sources.reduce<Record<string, string>>(\n      (acc: Record<string, string>, source) => {\n        getSrcArr(source).forEach(([key, value]) => {\n          acc[key] = typeof value === 'function' ? value() : value;\n        });\n\n        return acc;\n      },\n      {},\n    ),\n  );\n\n/** Serialize the body to JSON */\nexport const serializeBody = (body: Record<string, any>) =>\n  body === undefined ? undefined : JSON.stringify(body);\n", "import { DEFAULT_BASE_API_URL } from '../constants';\nimport { getClientSessionId, transformSetCookie } from './helpers';\nimport createFetchLogger from './helpers/createFetchLogger';\nimport {\n  AfterRequest,\n  BeforeRequest,\n  CreateHttpClientConfig,\n  HttpClient,\n  HTTPMethods,\n  MultipleHooks,\n  RequestConfig,\n} from './types';\nimport { urlBuilder } from './urlBuilder';\nimport { mergeHeaders, serializeBody } from './utils';\n\nconst jsonHeaders = {\n  'Content-Type': 'application/json',\n};\n\n/**\n * Create a Bearer authorization header with concatenated projectId and token\n * @param projectId The project id to use in the header\n * @param token Token to be concatenated. Defaults to empty.\n */\nconst createAuthorizationHeader = (\n  projectId: string,\n  token = '',\n): Record<string, string> => {\n  let bearer = projectId;\n  if (token) {\n    bearer = bearer + ':' + token;\n  }\n  return {\n    Authorization: `Bearer ${bearer}`,\n  };\n};\n\ndeclare const BUILD_VERSION: string;\n\n/**\n * Create descope custom headers\n */\nconst createDescopeHeaders = (\n  projectId: string,\n  refreshCookieName?: string,\n) => {\n  const res = {\n    'x-descope-sdk-session-id': getClientSessionId(),\n    'x-descope-sdk-name': 'core-js',\n    'x-descope-sdk-version': BUILD_VERSION,\n    'x-descope-project-id': projectId,\n  };\n\n  if (refreshCookieName) {\n    res['x-descope-refresh-cookie-name'] = refreshCookieName;\n  }\n  return res;\n};\n\nconst isJson = (value?: string) => {\n  try {\n    value = JSON.parse(value);\n  } catch (e) {\n    return false;\n  }\n\n  return typeof value === 'object' && value !== null;\n};\n\n/** Add the ability to pass multiple hooks instead of one when creating an http client */\nconst withMultipleHooks =\n  <T extends object>(createHttpClient: (config: CreateHttpClientConfig) => T) =>\n  (\n    config: Omit<CreateHttpClientConfig, 'hooks'> & { hooks?: MultipleHooks },\n  ) => {\n    const beforeRequest: BeforeRequest = (conf) => {\n      // get the before hooks from the config while function is running\n      // because the hooks might change after sdk creation\n      const beforeRequestHooks = [].concat(config.hooks?.beforeRequest || []);\n      return beforeRequestHooks?.reduce((acc, fn) => fn(acc), conf);\n    };\n\n    const afterRequest: AfterRequest = async (req, res) => {\n      // get the after hooks from the config while function is running\n      // because the hooks might change after sdk creation\n      const afterRequestHooks = [].concat(config.hooks?.afterRequest || []);\n      // do not remove this check - on old versions of react-native it is required\n      if (afterRequestHooks.length == 0) return;\n      const results = await Promise.allSettled(\n        afterRequestHooks?.map((fn) => fn(req, res?.clone())),\n      );\n      // eslint-disable-next-line no-console\n      results.forEach(\n        (result) =>\n          result.status === 'rejected' && config.logger?.error(result.reason),\n      );\n    };\n\n    return createHttpClient({\n      ...config,\n      hooks: {\n        beforeRequest,\n        afterRequest,\n        transformResponse: config.hooks?.transformResponse,\n      },\n    });\n  };\n\n/**\n * Create the HTTP client used to send HTTP requests to the Descope API\n *\n * @param CreateHttpClientConfig Configuration for the client\n */\nconst createHttpClient = ({\n  baseUrl: recBaseUrl,\n  projectId,\n  baseConfig,\n  refreshCookieName,\n  logger,\n  hooks,\n  cookiePolicy,\n  fetch,\n}: CreateHttpClientConfig): HttpClient => {\n  const baseUrl = recBaseUrl || DEFAULT_BASE_API_URL;\n  const fetchWithLogger = createFetchLogger(logger, fetch);\n\n  const sendRequest = async (config: RequestConfig) => {\n    const requestConfig = hooks?.beforeRequest\n      ? hooks.beforeRequest(config)\n      : config;\n\n    const { path, body, headers, queryParams, method, token } = requestConfig;\n\n    const serializedBody = serializeBody(body);\n    const requestInit: RequestInit = {\n      headers: mergeHeaders(\n        createAuthorizationHeader(projectId, token),\n        createDescopeHeaders(projectId, refreshCookieName),\n        baseConfig?.baseHeaders || {},\n        isJson(serializedBody) ? jsonHeaders : {}, // add json content headers if body is json\n        headers,\n      ),\n      method,\n      body: serializedBody,\n    };\n\n    // On edge runtimes like Cloudflare, the fetch implementation does not support credentials\n    // so we allow the caller to omit by specifying null\n    // See https://github.com/cloudflare/workerd/blob/main/src/workerd/api/http.h#L591\n    if (cookiePolicy !== null) {\n      requestInit.credentials = cookiePolicy || 'include';\n    }\n\n    const res = await fetchWithLogger(\n      urlBuilder({ path, baseUrl, queryParams, projectId }),\n      requestInit,\n    );\n\n    if (hooks?.afterRequest) {\n      await hooks.afterRequest(config, res?.clone());\n    }\n\n    if (hooks?.transformResponse) {\n      const json = await res.json();\n      const cookies = transformSetCookie(res.headers?.get('set-cookie') || '');\n      const mutableResponse = {\n        ...res,\n        json: () => Promise.resolve(json),\n        cookies,\n      };\n      // we want to make sure cloning the response will keep the transformed json data\n      mutableResponse.clone = () => mutableResponse;\n      return hooks.transformResponse(mutableResponse);\n    }\n\n    return res;\n  };\n\n  return {\n    get: (path: string, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body: undefined,\n        method: HTTPMethods.get,\n        token,\n      }),\n    post: (path, body, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body,\n        method: HTTPMethods.post,\n        token,\n      }),\n    patch: (path, body, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body,\n        method: HTTPMethods.patch,\n        token,\n      }),\n    put: (path, body, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body,\n        method: HTTPMethods.put,\n        token,\n      }),\n    delete: (path, { headers, queryParams, token } = {}) =>\n      sendRequest({\n        path,\n        headers,\n        queryParams,\n        body: undefined,\n        method: HTTPMethods.delete,\n        token,\n      }),\n    hooks,\n    buildUrl: (path, queryParams) => {\n      return urlBuilder({ projectId, baseUrl, path, queryParams });\n    },\n  };\n};\n\nexport default withMultipleHooks(createHttpClient);\nexport type { HttpClient };\n", "export { default as createFetchLogger } from './createFetchLogger';\nexport { getClientSessionId } from './getClientSessionId';\n\nexport function transformSetCookie(setCookieHeader: string) {\n  // Split the header by semicolons to separate different attributes\n  var cookiesString = setCookieHeader.split(';');\n\n  return cookiesString.reduce((acc, cookie) => {\n    const [key, value] = cookie.split('=');\n    return {\n      ...acc,\n      [key.trim()]: value,\n    };\n  }, {});\n}\n", "export default {\n  TOO_MANY_REQUESTS: 429,\n};\n", "import { jwtDecode, JwtPayload } from 'jwt-decode';\nimport { ResponseData, SdkResponse } from '../types';\nimport HttpStatusCodes from '../../constants/httpStatusCodes';\nimport { DESCOPE_CURRENT_TENANT_CLAIM } from '../../constants';\n\nfunction getJwtAuthorizationItems(\n  token: string,\n  tenant: string,\n  claim: string,\n): string[] {\n  let claims: any = parseJwt(token);\n  if (tenant) {\n    if (!claims?.tenants && claims?.[DESCOPE_CURRENT_TENANT_CLAIM] === tenant) {\n      // The token may have the current tenant in the \"dct\" claim and without the \"tenants\" claim\n      return claims?.[claim] || [];\n    } else {\n      claims = claims?.tenants?.[tenant];\n    }\n  }\n  const items = claims?.[claim];\n  return Array.isArray(items) ? items : [];\n}\n\nfunction parseJwt(token: string): JwtPayload {\n  if (typeof token !== 'string' || !token)\n    throw new Error('Invalid token provided');\n  return jwtDecode(token);\n}\n\n/**\n * Checks if the given JWT is still valid but DOES NOT check for signature\n *\n * @param token JWT token\n */\nexport function isJwtExpired(token: string): boolean {\n  const { exp } = parseJwt(token);\n  const currentTime = new Date().getTime() / 1000;\n  return currentTime > exp;\n}\n\n/**\n * Returns the list of tenants in the given JWT\n *\n * @param token JWT token\n */\nexport function getTenants(token: string): string[] {\n  let claims: any = parseJwt(token);\n  const items = Object.keys(claims?.tenants);\n  return Array.isArray(items) ? items : [];\n}\n\n/**\n * Returns the list of permissions granted in the given JWT but DOES NOT check for signature\n *\n * @param token JWT token\n */\nexport function getJwtPermissions(token: string, tenant?: string): string[] {\n  return getJwtAuthorizationItems(token, tenant, 'permissions');\n}\n\n/**\n * Returns the list of roles specified in the given JWT but DOES NOT check for signature\n *\n * @param token JWT token\n */\nexport function getJwtRoles(token: string, tenant?: string): string[] {\n  return getJwtAuthorizationItems(token, tenant, 'roles');\n}\n\n/** Joins path parts making sure there is only one path separator between parts */\nexport const pathJoin = (...args: string[]) =>\n  args.join('/').replace(/\\/{2,}/g, '/');\n\n/** Transform the Promise Response to our internal SdkResponse implementation\n * @param response The Response promise from fetch\n * @param transform Optionally transform the response JSON to another type\n */\nexport async function transformResponse<\n  T extends ResponseData,\n  S extends ResponseData = T,\n>(\n  response: Promise<Response>,\n  transform?: (data: T) => S,\n): Promise<SdkResponse<S>> {\n  const resp = await response;\n\n  const ret: SdkResponse<S> = {\n    code: resp.status,\n    ok: resp.ok,\n    response: resp,\n  };\n\n  const data = await resp.clone().json();\n\n  if (!resp.ok) {\n    ret.error = data;\n\n    if (resp.status === HttpStatusCodes.TOO_MANY_REQUESTS) {\n      Object.assign(ret.error, {\n        retryAfter: Number.parseInt(resp.headers?.get('retry-after')) || 0,\n      });\n    }\n  } else if (transform) {\n    ret.data = transform(data);\n  } else {\n    ret.data = <S>data;\n  }\n\n  return ret;\n}\n\nexport function getCurrentTenant(token: string): string {\n  return parseJwt(token)?.[DESCOPE_CURRENT_TENANT_CLAIM] || '';\n}\n", "import { Validator, ValidationRule, MakeValidator } from './types';\n\nexport const createValidator =\n  (rule: ValidationRule, defaultMsg?: string): MakeValidator =>\n  (msg = defaultMsg) =>\n  (val) =>\n    !rule(val) ? msg.replace('{val}', val) : false;\n\nexport const createOrValidator =\n  (validators: Validator[], defaultMsg?: string): MakeValidator =>\n  (msg = defaultMsg) =>\n  (val) => {\n    const errors = validators.filter((validator) => validator(val));\n\n    if (errors.length < validators.length) return false;\n\n    return msg ? msg.replace('{val}', val) : errors.join(' OR ');\n  };\n\nexport const createValidation = (...validators: Validator[]) => ({\n  validate: (val: any) => {\n    validators.forEach((validator) => {\n      const errMsg = validator(val);\n      if (errMsg) throw new Error(errMsg);\n    });\n\n    return true;\n  },\n});\n", "import { createOrValidator, createValidation, createValidator } from './core';\nimport { Validator } from './types';\n\nconst regexMatch = (regex: RegExp) => (val: any) => regex.test(val);\n\nconst validateString = (val: any) => typeof val === 'string';\n\nconst validateArray = (val: any) => Array.isArray(val);\n\nconst validateBoolean = (val: any) => typeof val === 'boolean';\n\nconst validateUndefined = (val: any) => val === undefined;\n\nconst validateEmail = regexMatch(\n  /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/,\n);\n\n// A replacement for lodash.get, because it may not integrate well in various runtime environments (Edge).\n// Implementation is based on https://gist.github.com/dfkaye/59263b51cf1e0b633181c5f44ae2066a\nconst get = (object: any, pathName: string, defaultValue?: any) => {\n  // Coerce pathName to a string (even it turns into \"[object Object]\").\n  const path = Array.isArray(pathName) ? pathName.join('.') : String(pathName);\n\n  // Support bracket notation, e.g., \"a[0].b.c\".\n  const match = /\\[\\\\?(\"|')?(\\w|d)+\\\\?(\"|')?\\]/g;\n\n  const parts = path.replace(match, (m, i, v) => '.' + v).split('.');\n\n  const length = parts.length;\n  let i = 0;\n\n  // In case object isn't a real object, set it to undefined.\n  let value = object === Object(object) ? object : undefined;\n\n  while (value != null && i < length) {\n    value = value[parts[i++]];\n  }\n\n  /**\n   * returns the resolved value if\n   * 1. iteration happened (i > 0)\n   * 2. iteration completed (i === length)\n   * 3. the value at the path is found in the data structure (not undefined). Note that if the path is found but the\n   *    value is null, then null is returned.\n   * If any of those checks fails, return the defaultValue param, if provided.\n   */\n  return i && i === length && value !== undefined ? value : defaultValue;\n};\n\nconst validatePhone = regexMatch(/^\\+[1-9]{1}[0-9]{3,14}$/);\nconst validateMinLength = (min: number) => (val: any) => val.length >= min;\n// const validatePlainObject = (val: any) => !!val && Object.getPrototypeOf(val) === Object.prototype;\nconst validatePathValue = (path: string, rules: Validator[]) => (val: any) =>\n  createValidation(...rules).validate(get(val, path));\n\nexport const isEmail = createValidator(\n  validateEmail,\n  '\"{val}\" is not a valid email',\n);\nexport const isPhone = createValidator(\n  validatePhone,\n  '\"{val}\" is not a valid phone number',\n);\nexport const isNotEmpty = createValidator(\n  validateMinLength(1),\n  'Minimum length is 1',\n);\nexport const isString = createValidator(\n  validateString,\n  'Input is not a string',\n);\n\nexport const isArray = createValidator(validateArray, 'Input is not an array');\n\nexport const isBoolean = createValidator(\n  validateBoolean,\n  'Input is not a boolean',\n);\n\nexport const isUndefined = createValidator(\n  validateUndefined,\n  'Input is defined',\n);\n\nexport const isStringOrUndefined = createOrValidator(\n  [isString(), isUndefined()],\n  'Input is not a string or undefined',\n);\n\nexport const isArrayOrBool = createOrValidator(\n  [isArray(), isBoolean()],\n  'Input is not an array or boolean',\n);\n\n// export const isPlainObject = createValidator(validatePlainObject, 'Input is not a plain object');\nexport const hasPathValue = (path: string, rules: Validator[]) =>\n  createValidator(validatePathValue(path, rules))();\n", "import { createValidation } from './core';\nimport { Validator } from './types';\nimport {\n  isEmail,\n  isNotEmpty,\n  isPhone,\n  isString,\n  isStringOrUndefined,\n} from './validators';\n\n/**\n *\n * Validate that all of the validators passes\n * @params each parameter is an array of validators, those validators will be verified against the wrapped function argument which in the same place\n * @throws if any of the validators fails, an error with the relevant message will be thrown\n */\nexport const withValidations =\n  (...argsRules: Validator[][]) =>\n  <T extends Array<any>, U>(fn: (...args: T) => U) =>\n  (...args: T): U => {\n    argsRules.forEach((rulesArr, i) =>\n      createValidation(...rulesArr).validate(args[i]),\n    );\n\n    return fn(...args);\n  };\n\nexport const string = (fieldName: string) => [\n  isString(`\"${fieldName}\" must be a string`),\n];\n\nexport const isStringOrUndefinedValidator = (fieldName: string) => [\n  isStringOrUndefined(`\"${fieldName}\" must be string or undefined`),\n];\n\nexport const stringNonEmpty = (fieldName: string) => [\n  isString(`\"${fieldName}\" must be a string`),\n  isNotEmpty(`\"${fieldName}\" must not be empty`),\n];\nexport const stringEmail = (fieldName: string) => [\n  isString(`\"${fieldName}\" must be a string`),\n  isEmail(),\n];\nexport const stringPhone = (fieldName: string) => [\n  isString(`\"${fieldName}\" must be a string`),\n  isPhone(),\n];\n", "import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport { transformResponse } from './helpers';\nimport {\n  AccessKeyLoginOptions,\n  ExchangeAccessKeyResponse,\n  SdkResponse,\n} from './types';\nimport { stringNonEmpty, withValidations } from './validations';\n\nconst withExchangeValidations = withValidations(stringNonEmpty('accessKey'));\n\nconst withAccessKeys = (httpClient: HttpClient) => ({\n  exchange: withExchangeValidations(\n    (\n      accessKey: string,\n      loginOptions?: AccessKeyLoginOptions,\n    ): Promise<SdkResponse<ExchangeAccessKeyResponse>> =>\n      transformResponse(\n        httpClient.post(\n          apiPaths.accessKey.exchange,\n          { loginOptions },\n          { token: accessKey },\n        ),\n      ),\n  ),\n});\n\nexport default withAccessKeys;\n", "/* eslint-disable import/exports-last */\nimport { ResponseData } from '../../sdk/types';\nimport { SdkFnWrapper, ReplacePaths, SdkFnsPaths } from './types';\n\n/**\n * A wrapper function that allows to wrap multiple Sdk function\n * @param obj: The Sdk instance you want to wrap\n * @param paths: A readonly list of paths of the functions you want to wrap\n * @param wrapper: Your wrapper function, it should gets an Sdk function and return a new Sdk function\n * @returns a mutated instance of the Sdk with updated type definitions based on your wrapper return type\n *\n * Usage example:\n *\n * // Assuming this is our SDK instance\n * const sdk = {\n *    me: (token) => {...}\n *    flow: {\n *       start: (...params) => {...}\n *       next: (...params) => {...}\n *    }\n *    ...\n * }\n *\n * // This is our wrapper\n * const wrapper = (sdkFn) => async (...args) => {\n *    const sdkResponse = await sdkFn(...args)\n *\n *    // Modify return value\n *    return {...sdkResponse, data: {...sdkResponse.data, myCustomAttribute: 'hello'}}\n * }\n *\n * // And those are the paths we want to wrap\n * const paths = ['flow.start', 'flow.next'] as const // You MUST add as const!\n *\n * // We can wrap our SDK functions with the wrapper we created in this way\n * const newlyTypedSdk = wrapWith(sdk, paths, wrapper)\n *\n * Now the 2 wrapped functions will have the updated type based on the wrapper return value\n */\n\nconst wrapWith = <\n  Obj extends object,\n  Paths extends ReadonlyArray<SdkFnsPaths<Obj>>,\n  WrapperData extends ResponseData,\n>(\n  obj: Obj,\n  paths: Paths,\n  wrapper: SdkFnWrapper<WrapperData>,\n): ReplacePaths<Obj, Paths, WrapperData> => {\n  paths.forEach((path) => {\n    const sections = path.split('.');\n    let section = sections.shift();\n    let currentRef: Record<string, any> = obj;\n\n    while (sections.length > 0) {\n      currentRef = currentRef[section];\n\n      if (!section || !currentRef) {\n        throw Error(\n          `Invalid path \"${path}\", \"${section}\" is missing or has no value`,\n        );\n      }\n\n      section = sections.shift();\n    }\n\n    if (typeof currentRef[section] !== 'function') {\n      throw Error(`\"${path}\" is not a function`);\n    }\n    const origFn = currentRef[section];\n    currentRef[section] = wrapper(origFn);\n  });\n\n  return obj as any;\n};\n\nexport default wrapWith;\n", "import { MAX_POLLING_TIMEOUT_MS, MIN_POLLING_INTERVAL_MS } from '../constants';\n\n/** Polling configuration with defaults and normalizing checks */\nexport const normalizeWaitForSessionConfig = ({\n  pollingIntervalMs = MIN_POLLING_INTERVAL_MS,\n  timeoutMs = MAX_POLLING_TIMEOUT_MS,\n} = {}) => ({\n  pollingIntervalMs: Math.max(\n    pollingIntervalMs || MIN_POLLING_INTERVAL_MS,\n    MIN_POLLING_INTERVAL_MS,\n  ),\n  timeoutMs: Math.min(\n    timeoutMs || MAX_POLLING_TIMEOUT_MS,\n    MAX_POLLING_TIMEOUT_MS,\n  ),\n});\n", "type DeviceInfo = {\n  webAuthnSupport?: boolean;\n};\n\ntype LastAuth = {\n  authMethod?: AuthMethod;\n  oauthProvider?: string;\n  name?: string;\n  loginId?: string;\n};\n\ntype RedirectAuth = {\n  callbackUrl: string;\n  codeChallenge: string;\n};\n\n/** Sent in a flow start request when running as a native flow component via a mobile SDK */\ntype NativeOptions = {\n  /** What mobile platform we're running on, used to decide between different behaviors on the backend */\n  platform: 'ios' | 'android';\n\n  /** The name of an OAuth provider that will use native OAuth (Sign in with Apple/Google) instead of web OAuth when running in a mobile app */\n  oauthProvider?: string;\n\n  /** An override for web OAuth that sets the address to redirect to after authentication succeeds at the OAuth provider website */\n  oauthRedirect?: string;\n};\n\ntype AuthMethod =\n  | 'magiclink'\n  | 'enchantedlink'\n  | 'otp'\n  | 'totp'\n  | 'oauth'\n  | 'saml'\n  | 'webauthn';\n\nexport type SdkFn = (...args: any[]) => Promise<SdkResponse<ResponseData>>;\n\nexport type MaskedPhone = {\n  maskedPhone: string;\n};\n\nexport type MaskedEmail = {\n  maskedEmail: string;\n};\n\n/** User base details from Descope API */\nexport type User = {\n  email?: string;\n  name?: string;\n  givenName?: string;\n  middleName?: string;\n  familyName?: string;\n  phone?: string;\n};\n\n/** User extended details from Descope API */\nexport type UserResponse = User & {\n  loginIds: string[];\n  userId: string;\n  verifiedEmail?: boolean;\n  verifiedPhone?: boolean;\n  picture?: string;\n  roleNames?: string[];\n  userTenants?: UserTenant[];\n  createdTime: number;\n  TOTP: boolean;\n  SAML: boolean;\n  SCIM: boolean;\n  password: boolean;\n  OAuth?: Record<string, boolean>;\n  customAttributes?: Record<string, any>;\n  status: string;\n};\n\nexport type Tenant = {\n  id: string;\n  name: string;\n  customAttributes?: Record<string, any>;\n};\n\nexport type TenantsResponse = {\n  tenants: Tenant[];\n};\n\nexport type UserHistoryResponse = {\n  userId: string;\n  loginTime: number;\n  city: string;\n  country: string;\n  ip: string;\n};\n\n/** A tenant association mapping  */\nexport type UserTenant = {\n  tenantId: string;\n  roleNames?: string[];\n  tenantName: string;\n};\n\nexport type TemplateOptions = Record<string, string>; // for providing messaging template options (templates that are being sent via email / text message)\n\n/** Login options to be added to the different authentication methods */\nexport type LoginOptions = {\n  stepup?: boolean;\n  mfa?: boolean;\n  revokeOtherSessions?: boolean;\n  customClaims?: Record<string, any>;\n  templateId?: string;\n  templateOptions?: TemplateOptions;\n};\n\n/** Access key login options to be added to the different authentication methods */\nexport type AccessKeyLoginOptions = {\n  customClaims?: Record<string, any>;\n};\n\n/** Sign Up options to be added to the different authentication methods */\nexport type SignUpOptions = {\n  customClaims?: Record<string, any>;\n  templateId?: string;\n  templateOptions?: TemplateOptions;\n};\n\n/** Authentication info result from the various JWT validations  */\nexport type JWTResponse = {\n  sessionJwt: string;\n  refreshJwt?: string;\n  cookieDomain?: string;\n  cookiePath?: string;\n  cookieMaxAge?: number;\n  cookieExpiration?: number;\n  user?: UserResponse;\n  firstSeen?: boolean;\n  sessionExpiration: number;\n};\n\n/** Authentication info result from exchanging access keys for a session */\nexport type ExchangeAccessKeyResponse = {\n  keyId: string;\n  sessionJwt: string;\n  expiration: number;\n};\n\n/** Options for fine-grained passkey (WebAuthn) control */\nexport type PasskeyOptions = {\n  // attestation only (sign up)\n  authenticatorSelection?: WebauthnAuthenticatorSelectionCriteria;\n  attestation?: 'none' | 'indirect' | 'direct';\n  // assertion only (sign in)\n  userVerification?: 'preferred' | 'required' | 'discouraged';\n  // shared\n  extensionsJSON?: string;\n};\n\n/** Part of the passkey options that apply when performing attestation (sign up) */\nexport type WebauthnAuthenticatorSelectionCriteria = {\n  authenticatorAttachment?: 'any' | 'platform' | 'crossplatform';\n  residentKey?: 'discouraged' | 'preferred' | 'required';\n  userVerification?: 'preferred' | 'required' | 'discouraged';\n};\n\n/** The response returned from the various start webauthn functions */\nexport type WebAuthnStartResponse = {\n  transactionId: string;\n  options: string;\n  create: boolean;\n};\n\n/** Enchanted link response */\nexport type EnchantedLinkResponse = {\n  /** Pending reference URL to poll while waiting for user to click magic link */\n  pendingRef: string;\n  /** Link id, on which link the user should click */\n  linkId: string;\n  /** Email to which the link was sent to */\n  maskedEmail: string;\n};\n\n/** URL response to redirect user in case of OAuth or SSO */\nexport type URLResponse = {\n  url: string;\n};\n\n/** TOTP response with the TOTP details */\nexport type TOTPResponse = {\n  provisioningURL: string;\n  image: string;\n  key: string;\n};\n\n/** Password reset response with details according to response method */\nexport type PasswordResetResponse = {\n  resetMethod: string;\n  pendingRef?: string;\n  linkId?: string;\n  maskedEmail: string;\n};\n\n/** A subset of the password policy that can be checked on the client side for better UX */\nexport type PasswordPolicyResponse = {\n  minLength: number;\n  lowercase: boolean;\n  uppercase: boolean;\n  number: boolean;\n  nonAlphanumeric: boolean;\n};\n\nexport type ClientIdResponse = {\n  clientId: string;\n};\n\nexport type VerifyOneTapIDTokenResponse = {\n  code: string;\n};\n\n/** Phone delivery methods which are currently supported */\nexport enum DeliveryPhone {\n  sms = 'sms',\n  voice = 'voice',\n  whatsapp = 'whatsapp',\n}\n\nexport enum DeliveryEmail {\n  email = 'email',\n}\n\n/** All delivery methods currently supported */\nexport type DeliveryMethods = DeliveryPhone | DeliveryEmail;\n\nexport const DeliveryMethods = {\n  ...DeliveryPhone,\n  ...DeliveryEmail,\n} as const;\n\n/** All flow execution statuses\n *  - waiting - flow execution is waiting for user interaction\n *  - running - flow execution is currently running\n *  - completed - flow execution completed successfully\n *  - failed - flow execution failed\n */\nexport enum FlowStatus {\n  waiting = 'waiting',\n  running = 'running',\n  completed = 'completed',\n  failed = 'failed',\n}\n\n/** All flow response action\n *  - screen - next action is to render  screen\n *  - poll - next action is poll for next after timeout\n *  - redirect - next action is to redirect (redirection details in 'redirect' attribute)\n *  - webauthnCreate/webauthnGet - next action is to prompt webauthn (details in 'webauthn' attribute)\n *  - nativeBridge - the next action needs to be sent via the native bridge to the native layer\n *  - none - no next action\n */\nexport type FlowAction =\n  | 'screen'\n  | 'poll'\n  | 'redirect'\n  | 'webauthnCreate'\n  | 'webauthnGet'\n  | 'nativeBridge'\n  | 'none';\n\nexport type ComponentsConfig = Record<string, any>;\n\n/** Flow response with flow execution details */\nexport type FlowResponse = {\n  // current execution identifier\n  executionId: string;\n  // current step identifier\n  stepId: string;\n  // current step name\n  stepName: string;\n  // flow execution status\n  status: FlowStatus;\n  // the next required action\n  action: FlowAction;\n  // screen data - if action is 'screen'\n  screen?: {\n    // screen identifier\n    id: string;\n    // extra dynamic state required for rendering screen\n    state: Record<string, any>;\n    componentsConfig: ComponentsConfig;\n  };\n  // redirect data - if action is 'redirect'\n  redirect?: {\n    url: string;\n    isPopup?: boolean;\n  };\n  // SAML IDP response (this will be used to build the html form response goes from the IDP through the end user browser to the SP)\n  samlIdpResponse?: {\n    url: string;\n    samlResponse: string;\n    relayState: string;\n  };\n  // a URL to open in a new tab\n  openInNewTabUrl?: string;\n  // webauthn data - if action is one of 'webauthnCreate', 'webauthnGet'\n  webauthn?: {\n    transactionId: string;\n    options: string;\n    create: boolean;\n  };\n  // set if the action is 'nativeBridge'\n  nativeResponse?: {\n    type: 'oauthNative' | 'oauthWeb' | 'webauthnGet' | 'webauthnCreate';\n    payload: Record<string, any>;\n  };\n  // an error that occurred during flow execution, used for debugging / integrating\n  error?: {\n    code: string;\n    description: string;\n    message: string;\n  };\n  // authentication information response, if response is authenticated\n  authInfo?: JWTResponse;\n  lastAuth?: Pick<LastAuth, 'authMethod' | 'oauthProvider'>;\n  runnerLogs?: {\n    title?: string;\n    log: string;\n    level?: 'info' | 'debug' | 'warn' | 'error';\n  }[];\n};\n\nexport type Options = {\n  redirectUrl?: string;\n  location?: string;\n  tenant?: string;\n  deviceInfo?: DeviceInfo;\n  lastAuth?: LastAuth;\n  redirectAuth?: RedirectAuth;\n  oidcIdpStateId?: string;\n  preview?: boolean;\n  samlIdpStateId?: string;\n  samlIdpUsername?: string;\n  ssoAppId?: string;\n  thirdPartyAppId?: string;\n  oidcLoginHint?: string;\n  abTestingKey?: number;\n  startOptionsVersion?: number;\n  client?: Record<string, any>;\n  locale?: string;\n  oidcPrompt?: string;\n  oidcErrorRedirectUri?: string;\n  oidcResource?: string;\n  nativeOptions?: NativeOptions;\n  thirdPartyAppStateId?: string;\n  applicationScopes?: string; // Relevant for sso application and third party application\n  outboundAppId?: string;\n  outboundAppScopes?: string[];\n};\n\nexport type ResponseData = Record<string, any>;\n\n/**\n * Response from our SDK calls which includes the result (ok, code, error).\n * The relevant data is provided in the more specific interfaces extending SdkResponse.\n */\nexport type SdkResponse<T extends ResponseData> = {\n  code?: number;\n  ok: boolean;\n  response?: Response;\n  error?: {\n    errorCode: string;\n    errorDescription: string;\n    errorMessage?: string;\n    retryAfter?: string;\n  };\n  data?: T;\n};\n\n/** Different delivery method */\nexport type Deliveries<T extends Record<DeliveryMethods, SdkFn>> = {\n  [S in DeliveryMethods]: T[S];\n};\n\nexport type DeliveriesPhone<T extends Record<DeliveryPhone, SdkFn> | SdkFn> = {\n  [S in DeliveryPhone]: T extends Record<DeliveryPhone, SdkFn> ? T[S] : T;\n};\n\n/** Map different functions to email vs phone (sms, whatsapp, voice) */\nexport type DeliveriesMap<EmailFn extends SdkFn, PhoneFn extends SdkFn> = {\n  [S in DeliveryMethods]: S extends 'email' ? EmailFn : PhoneFn;\n};\n\n/** Logger type that supports the given levels (debug, log, error) */\nexport type Logger = Pick<Console, 'debug' | 'log' | 'error' | 'warn'>;\n\n/** Polling configuration for session waiting */\nexport type WaitForSessionConfig = {\n  pollingIntervalMs: number;\n  timeoutMs: number;\n};\n\nexport type UpdateOptions<T extends boolean> = {\n  addToLoginIDs?: T;\n  onMergeUseExisting?: T extends true ? boolean : never;\n  templateOptions?: TemplateOptions;\n  templateId?: string;\n  providerId?: string;\n};\n", "import {\n  stringNonEmpty,\n  withValidations,\n  stringPhone,\n  stringEmail,\n} from '../validations';\n\nexport const loginIdValidations = stringNonEmpty('loginId');\nexport const withVerifyValidations = withValidations(stringNonEmpty('token'));\nexport const withSignValidations = withValidations(loginIdValidations);\nexport const withWaitForSessionValidations = withValidations(\n  stringNonEmpty('pendingRef'),\n);\nexport const withUpdatePhoneValidations = withValidations(\n  loginIdValidations,\n  stringPhone('phone'),\n);\nexport const withUpdateEmailValidations = withValidations(\n  loginIdValidations,\n  stringEmail('email'),\n);\n", "import {\n  apiPaths,\n  MAX_POLLING_TIMEOUT_MS,\n  MIN_POLLING_INTERVAL_MS,\n} from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { normalizeWaitForSessionConfig } from '../../utils';\nimport { pathJoin, transformResponse } from '../helpers';\nimport {\n  DeliveryMethods,\n  SdkResponse,\n  JWTResponse,\n  EnchantedLinkResponse,\n  User,\n  LoginOptions,\n  UpdateOptions,\n  SignUpOptions,\n  WaitForSessionConfig,\n} from '../types';\nimport {\n  withWaitForSessionValidations,\n  withSignValidations,\n  withVerifyValidations,\n  withUpdateEmailValidations,\n} from './validations';\n\nconst withEnchantedLink = (httpClient: HttpClient) => ({\n  verify: withVerifyValidations(\n    (token: string): Promise<SdkResponse<never>> =>\n      transformResponse(\n        httpClient.post(apiPaths.enchantedLink.verify, { token }),\n      ),\n  ),\n\n  signIn: withSignValidations(\n    (\n      loginId: string,\n      URI?: string,\n      loginOptions?: LoginOptions,\n      token?: string,\n    ): Promise<SdkResponse<EnchantedLinkResponse>> =>\n      transformResponse(\n        httpClient.post(\n          pathJoin(apiPaths.enchantedLink.signIn, DeliveryMethods.email),\n          {\n            loginId,\n            URI,\n            loginOptions,\n          },\n          { token },\n        ),\n      ),\n  ),\n\n  signUpOrIn: withSignValidations(\n    (\n      loginId: string,\n      URI?: string,\n      signUpOptions?: SignUpOptions,\n    ): Promise<SdkResponse<EnchantedLinkResponse>> =>\n      transformResponse(\n        httpClient.post(\n          pathJoin(apiPaths.enchantedLink.signUpOrIn, DeliveryMethods.email),\n          {\n            loginId,\n            URI,\n            loginOptions: signUpOptions,\n          },\n        ),\n      ),\n  ),\n\n  signUp: withSignValidations(\n    (\n      loginId: string,\n      URI?: string,\n      user?: User,\n      signUpOptions?: SignUpOptions,\n    ): Promise<SdkResponse<EnchantedLinkResponse>> =>\n      transformResponse(\n        httpClient.post(\n          pathJoin(apiPaths.enchantedLink.signUp, DeliveryMethods.email),\n          {\n            loginId,\n            URI,\n            user,\n            loginOptions: signUpOptions,\n          },\n        ),\n      ),\n  ),\n\n  waitForSession: withWaitForSessionValidations(\n    (\n      pendingRef: string,\n      config?: WaitForSessionConfig,\n    ): Promise<SdkResponse<JWTResponse>> =>\n      new Promise((resolve) => {\n        const { pollingIntervalMs, timeoutMs } =\n          normalizeWaitForSessionConfig(config);\n        let timeout: NodeJS.Timeout | undefined;\n        const interval = setInterval(async () => {\n          const resp = await httpClient.post(apiPaths.enchantedLink.session, {\n            pendingRef,\n          });\n          if (resp.ok) {\n            clearInterval(interval);\n            if (timeout) clearTimeout(timeout);\n            resolve(transformResponse(Promise.resolve(resp)));\n          }\n        }, pollingIntervalMs);\n\n        timeout = setTimeout(() => {\n          resolve({\n            error: {\n              errorDescription: `Session polling timeout exceeded: ${timeoutMs}ms`,\n              errorCode: '0',\n            },\n            ok: false,\n          });\n          clearInterval(interval);\n        }, timeoutMs);\n      }),\n  ),\n\n  update: {\n    email: withUpdateEmailValidations(\n      <T extends boolean>(\n        loginId: string,\n        email: string,\n        URI?: string,\n        token?: string,\n        updateOptions?: UpdateOptions<T>,\n      ): Promise<SdkResponse<EnchantedLinkResponse>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.enchantedLink.update.email,\n            { loginId, email, URI, ...updateOptions },\n            { token },\n          ),\n        ),\n    ),\n  },\n});\n\nexport default withEnchantedLink;\n", "import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { transformResponse } from '../helpers';\nimport { FlowResponse, Options, SdkResponse } from '../types';\nimport { stringNonEmpty, withValidations } from '../validations';\nimport { FlowInput } from './types';\n\nconst withStartValidations = withValidations(stringNonEmpty('flowId'));\nconst withNextValidations = withValidations(\n  stringNonEmpty('executionId'),\n  stringNonEmpty('stepId'),\n  stringNonEmpty('interactionId'),\n);\n\nconst withFlow = (httpClient: HttpClient) => ({\n  start: withStartValidations(\n    (\n      flowId: string,\n      options?: Options,\n      conditionInteractionId?: string,\n      interactionId?: string,\n      componentsVersion?: string,\n      flowVersions?: Record<string, number>,\n      input?: FlowInput,\n    ): Promise<SdkResponse<FlowResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.flow.start, {\n          flowId,\n          options,\n          conditionInteractionId,\n          interactionId,\n          componentsVersion,\n          flowVersions,\n          input,\n        }),\n      ),\n  ),\n  next: withNextValidations(\n    (\n      executionId: string,\n      stepId: string,\n      interactionId: string,\n      version?: number,\n      componentsVersion?: string,\n      input?: FlowInput,\n    ): Promise<SdkResponse<FlowResponse>> => {\n      return transformResponse(\n        httpClient.post(apiPaths.flow.next, {\n          executionId,\n          stepId,\n          interactionId,\n          version,\n          componentsVersion,\n          input,\n        }),\n      );\n    },\n  ),\n});\n\nexport default withFlow;\n", "import {\n  stringNonEmpty,\n  withValidations,\n  stringPhone,\n  stringEmail,\n} from '../validations';\n\nexport const loginIdValidations = stringNonEmpty('loginId');\nexport const withVerifyValidations = withValidations(stringNonEmpty('token'));\nexport const withSignValidations = withValidations(loginIdValidations);\nexport const withWaitForSessionValidations = withValidations(\n  stringNonEmpty('pendingRef'),\n);\nexport const withUpdatePhoneValidations = withValidations(\n  loginIdValidations,\n  stringPhone('phone'),\n);\nexport const withUpdateEmailValidations = withValidations(\n  loginIdValidations,\n  stringEmail('email'),\n);\n", "import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { pathJoin, transformResponse } from '../helpers';\nimport {\n  DeliveryMethods,\n  DeliveryPhone,\n  SdkResponse,\n  JWTResponse,\n  User,\n  LoginOptions,\n  MaskedEmail,\n  UpdateOptions,\n  SignUpOptions,\n} from '../types';\nimport { MagicLink, Routes } from './types';\nimport {\n  withSignValidations,\n  withVerifyValidations,\n  withUpdateEmailValidations,\n  withUpdatePhoneValidations,\n} from './validations';\n\nconst deliveryMethods = Object.keys(DeliveryMethods).filter(\n  (d) => d !== DeliveryPhone.voice,\n);\n\nconst withMagicLink = (httpClient: HttpClient) => ({\n  verify: withVerifyValidations(\n    (token: string): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(httpClient.post(apiPaths.magicLink.verify, { token })),\n  ),\n\n  signIn: deliveryMethods.reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (\n          loginId: string,\n          URI?: string,\n          loginOptions?: LoginOptions,\n          token?: string,\n        ) =>\n          transformResponse(\n            httpClient.post(\n              pathJoin(apiPaths.magicLink.signIn, delivery),\n              { loginId, URI, loginOptions },\n              { token },\n            ),\n          ),\n      ),\n    }),\n    {},\n  ) as MagicLink[Routes.signIn],\n\n  signUp: deliveryMethods.reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (\n          loginId: string,\n          URI?: string,\n          user?: User,\n          signUpOptions?: SignUpOptions,\n        ) =>\n          transformResponse(\n            httpClient.post(pathJoin(apiPaths.magicLink.signUp, delivery), {\n              loginId,\n              URI,\n              user,\n              loginOptions: signUpOptions,\n            }),\n          ),\n      ),\n    }),\n    {},\n  ) as MagicLink[Routes.signUp],\n\n  signUpOrIn: deliveryMethods.reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (loginId: string, URI?: string, signUpOptions?: SignUpOptions) =>\n          transformResponse(\n            httpClient.post(pathJoin(apiPaths.magicLink.signUpOrIn, delivery), {\n              loginId,\n              URI,\n              loginOptions: signUpOptions,\n            }),\n          ),\n      ),\n    }),\n    {},\n  ) as MagicLink[Routes.signUpOrIn],\n\n  update: {\n    email: withUpdateEmailValidations(\n      <T extends boolean>(\n        loginId: string,\n        email: string,\n        URI?: string,\n        token?: string,\n        updateOptions?: UpdateOptions<T>,\n      ): Promise<SdkResponse<MaskedEmail>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.magicLink.update.email,\n            { loginId, email, URI, ...updateOptions },\n            { token },\n          ),\n        ),\n    ),\n    phone: Object.keys(DeliveryPhone)\n      .filter((d) => d !== DeliveryPhone.voice)\n      .reduce(\n        (acc, delivery) => ({\n          ...acc,\n          [delivery]: withUpdatePhoneValidations(\n            <T extends boolean>(\n              loginId: string,\n              phone: string,\n              URI?: string,\n              token?: string,\n              updateOptions?: UpdateOptions<T>,\n            ) =>\n              transformResponse(\n                httpClient.post(\n                  pathJoin(apiPaths.magicLink.update.phone, delivery),\n                  { loginId, phone, URI, ...updateOptions },\n                  { token },\n                ),\n              ),\n          ),\n        }),\n        {},\n      ) as MagicLink[Routes.updatePhone],\n  },\n});\n\nexport default withMagicLink;\n", "import { SdkResponse, URLResponse, JWTResponse, LoginOptions } from '../types';\n\nenum OAuthProviders {\n  facebook = 'facebook',\n  github = 'github',\n  google = 'google',\n  microsoft = 'microsoft',\n  gitlab = 'gitlab',\n  apple = 'apple',\n  discord = 'discord',\n  linkedin = 'linkedin',\n  slack = 'slack',\n}\n\ntype VerifyFn = (code: string) => Promise<SdkResponse<JWTResponse>>;\nexport type StartFn = (\n  redirectURL?: string,\n  loginOptions?: LoginOptions,\n  token?: string,\n) => Promise<SdkResponse<URLResponse>>;\n\nexport type Providers<T> = Record<keyof typeof OAuthProviders, T>;\n\nexport type Oauth = {\n  start: Providers<StartFn>;\n  verify: Providers<VerifyFn>;\n};\n\nexport { OAuthProviders };\n", "import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport {\n  SdkResponse,\n  JWTResponse,\n  LoginOptions,\n  ClientIdResponse,\n  VerifyOneTapIDTokenResponse,\n} from '../types';\nimport { transformResponse } from '../helpers';\nimport { Oauth, OAuthProviders } from './types';\nimport { stringNonEmpty, withValidations } from '../validations';\n\nconst withExchangeValidations = withValidations(stringNonEmpty('code'));\nconst withOauth = (httpClient: HttpClient) => ({\n  start: Object.assign(\n    (\n      provider: string,\n      redirectUrl?: string,\n      loginOptions?: LoginOptions,\n      token?: string,\n      loginHint?: string,\n    ) => {\n      return transformResponse(\n        httpClient.post(apiPaths.oauth.start, loginOptions || {}, {\n          queryParams: {\n            provider,\n            ...(redirectUrl && { redirectURL: redirectUrl }),\n            ...(loginHint && { loginHint }),\n          },\n          token,\n        }),\n      );\n    },\n    Object.keys(OAuthProviders).reduce(\n      (acc, provider) => ({\n        ...acc,\n        [provider]: (\n          redirectUrl?: string,\n          loginOptions?: LoginOptions,\n          token?: string,\n          loginHint?: string,\n        ) =>\n          transformResponse(\n            httpClient.post(apiPaths.oauth.start, loginOptions || {}, {\n              queryParams: {\n                provider,\n                ...(redirectUrl && { redirectURL: redirectUrl }),\n                ...(loginHint && { loginHint }),\n              },\n              token,\n            }),\n          ),\n      }),\n      {},\n    ) as Oauth['start'],\n  ),\n  exchange: withExchangeValidations(\n    (code: string): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(httpClient.post(apiPaths.oauth.exchange, { code })),\n  ),\n  startNative: (\n    provider: string,\n    loginOptions?: LoginOptions,\n    implicit?: boolean,\n  ) =>\n    transformResponse(\n      httpClient.post(apiPaths.oauth.startNative, {\n        provider,\n        loginOptions,\n        implicit,\n      }),\n    ),\n  finishNative: (\n    provider: string,\n    stateId: string,\n    user?: string,\n    code?: string,\n    idToken?: string,\n  ) =>\n    transformResponse(\n      httpClient.post(apiPaths.oauth.finishNative, {\n        provider,\n        stateId,\n        user,\n        code,\n        idToken,\n      }),\n    ),\n  getOneTapClientId: (provider: string) =>\n    transformResponse<ClientIdResponse>(\n      httpClient.get(\n        apiPaths.oauth.oneTap.getOneTapClientId.replace('{provider}', provider),\n      ),\n    ),\n  verifyOneTapIDToken: (\n    provider: string,\n    idToken: string,\n    nonce: string,\n    loginOptions?: LoginOptions,\n  ) =>\n    transformResponse<VerifyOneTapIDTokenResponse>(\n      httpClient.post(apiPaths.oauth.oneTap.verifyOneTapIDToken, {\n        provider,\n        idToken,\n        nonce,\n        loginOptions,\n      }),\n    ),\n  exchangeOneTapIDToken: (\n    provider: string,\n    idToken: string,\n    nonce: string,\n    loginOptions?: LoginOptions,\n  ) =>\n    transformResponse<JWTResponse>(\n      httpClient.post(apiPaths.oauth.oneTap.exchangeOneTapIDToken, {\n        provider,\n        idToken,\n        nonce,\n        loginOptions,\n      }),\n    ),\n});\n\nexport default withOauth;\n", "import {\n  isStringOrUndefinedValidator,\n  stringNonEmpty,\n  withValidations,\n} from '../validations';\n\nconst appIdValidation = stringNonEmpty('appId');\nexport const withConnectValidations = withValidations(appIdValidation);\n", "import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { transformResponse } from '../helpers';\nimport { ConnectOptions } from './types';\nimport { SdkResponse, URLResponse } from '../types';\nimport { withConnectValidations } from './validations';\n\nconst withOutbound = (httpClient: HttpClient) => ({\n  connect: withConnectValidations(\n    (\n      appId: string,\n      options?: ConnectOptions,\n      token?: string,\n    ): Promise<SdkResponse<URLResponse>> => {\n      const tenantId = options?.tenantId;\n      const tenantLevel = options?.tenantLevel;\n      delete options?.tenantId;\n      delete options?.tenantLevel;\n      return transformResponse(\n        httpClient.post(\n          apiPaths.outbound.connect,\n          {\n            appId,\n            tenantId,\n            tenantLevel,\n            options,\n          },\n          {\n            token,\n          },\n        ),\n      );\n    },\n  ),\n});\n\nexport default withOutbound;\n", "import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { pathJoin, transformResponse } from '../helpers';\nimport {\n  DeliveryMethods,\n  User,\n  SdkResponse,\n  JWTResponse,\n  DeliveryPhone,\n  LoginOptions,\n  MaskedEmail,\n  UpdateOptions,\n  SignUpOptions,\n} from '../types';\nimport {\n  stringEmail,\n  stringNonEmpty,\n  stringPhone,\n  withValidations,\n} from '../validations';\nimport { Otp, Routes } from './types';\n\nconst loginIdValidations = stringNonEmpty('loginId');\nconst withVerifyValidations = withValidations(\n  loginIdValidations,\n  stringNonEmpty('code'),\n);\nconst withSignValidations = withValidations(loginIdValidations);\nconst withUpdatePhoneValidations = withValidations(\n  loginIdValidations,\n  stringPhone('phone'),\n);\nconst withUpdateEmailValidations = withValidations(\n  loginIdValidations,\n  stringEmail('email'),\n);\n\nconst withOtp = (httpClient: HttpClient) => ({\n  verify: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withVerifyValidations(\n        (loginId: string, code: string): Promise<SdkResponse<JWTResponse>> =>\n          transformResponse(\n            httpClient.post(pathJoin(apiPaths.otp.verify, delivery), {\n              code,\n              loginId,\n            }),\n          ),\n      ),\n    }),\n    {},\n  ) as Otp[Routes.verify],\n\n  signIn: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (loginId: string, loginOptions?: LoginOptions, token?: string) =>\n          transformResponse(\n            httpClient.post(\n              pathJoin(apiPaths.otp.signIn, delivery),\n              { loginId, loginOptions },\n              { token },\n            ),\n          ),\n      ),\n    }),\n    {},\n  ) as Otp[Routes.signIn],\n\n  signUp: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (loginId: string, user?: User, signUpOptions?: SignUpOptions) =>\n          transformResponse(\n            httpClient.post(pathJoin(apiPaths.otp.signUp, delivery), {\n              loginId,\n              user,\n              loginOptions: signUpOptions,\n            }),\n          ),\n      ),\n    }),\n    {},\n  ) as Otp[Routes.signUp],\n\n  signUpOrIn: Object.keys(DeliveryMethods).reduce(\n    (acc, delivery) => ({\n      ...acc,\n      [delivery]: withSignValidations(\n        (loginId: string, signUpOptions?: SignUpOptions) =>\n          transformResponse(\n            httpClient.post(pathJoin(apiPaths.otp.signUpOrIn, delivery), {\n              loginId,\n              loginOptions: signUpOptions,\n            }),\n          ),\n      ),\n    }),\n    {},\n  ) as Otp[Routes.signIn],\n\n  update: {\n    email: withUpdateEmailValidations(\n      <T extends boolean>(\n        loginId: string,\n        email: string,\n        token?: string,\n        updateOptions?: UpdateOptions<T>,\n      ): Promise<SdkResponse<MaskedEmail>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.otp.update.email,\n            { loginId, email, ...updateOptions },\n            { token },\n          ),\n        ),\n    ),\n    phone: Object.keys(DeliveryPhone).reduce(\n      (acc, delivery) => ({\n        ...acc,\n        [delivery]: withUpdatePhoneValidations(\n          <T extends boolean>(\n            loginId: string,\n            phone: string,\n            token?: string,\n            updateOptions?: UpdateOptions<T>,\n          ) =>\n            transformResponse(\n              httpClient.post(\n                pathJoin(apiPaths.otp.update.phone, delivery),\n                { loginId, phone, ...updateOptions },\n                { token },\n              ),\n            ),\n        ),\n      }),\n      {},\n    ) as Otp[Routes.updatePhone],\n  },\n});\n\nexport default withOtp;\n", "import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport { transformResponse } from './helpers';\nimport { SdkResponse, URLResponse, JWTResponse, LoginOptions } from './types';\nimport { stringNonEmpty, withValidations } from './validations';\n\nconst withStartValidations = withValidations(stringNonEmpty('tenant'));\nconst withExchangeValidations = withValidations(stringNonEmpty('code'));\n\nconst withSaml = (httpClient: HttpClient) => ({\n  start: withStartValidations(\n    (\n      tenantIdOrEmail: string,\n      redirectUrl?: string,\n      loginOptions?: LoginOptions,\n      token?: string,\n      ssoId?: string,\n      forceAuthn?: boolean,\n      loginHint?: string,\n    ): Promise<SdkResponse<URLResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.saml.start, loginOptions || {}, {\n          queryParams: {\n            tenant: tenantIdOrEmail,\n            ...(redirectUrl && { redirectURL: redirectUrl }),\n            ...(ssoId && { ssoId }),\n            ...(forceAuthn && { forceAuthn: 'true' }),\n            ...(loginHint && { loginHint }),\n          },\n          ...(token && { token }),\n        }),\n      ),\n  ),\n  exchange: withExchangeValidations(\n    (code: string): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(httpClient.post(apiPaths.saml.exchange, { code })),\n  ),\n});\n\nexport default withSaml;\n", "import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport { transformResponse } from './helpers';\nimport {\n  User,\n  SdkResponse,\n  JWTResponse,\n  TOTPResponse,\n  LoginOptions,\n} from './types';\nimport { stringNonEmpty, withValidations } from './validations';\n\nconst loginIdValidations = stringNonEmpty('loginId');\nconst withVerifyValidations = withValidations(\n  loginIdValidations,\n  stringNonEmpty('code'),\n);\nconst withSignUpValidations = withValidations(loginIdValidations);\nconst withUpdateValidations = withValidations(loginIdValidations);\n\nconst withTotp = (httpClient: HttpClient) => ({\n  signUp: withSignUpValidations(\n    (loginId: string, user?: User): Promise<SdkResponse<TOTPResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.totp.signUp, { loginId, user }),\n      ),\n  ),\n\n  verify: withVerifyValidations(\n    (\n      loginId: string,\n      code: string,\n      loginOptions?: LoginOptions,\n      token?: string,\n    ): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(\n        httpClient.post(\n          apiPaths.totp.verify,\n          { loginId, code, loginOptions },\n          { token },\n        ),\n      ),\n  ),\n\n  update: withUpdateValidations(\n    (loginId: string, token?: string): Promise<SdkResponse<TOTPResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.totp.update, { loginId }, { token }),\n      ),\n  ),\n});\n\nexport default withTotp;\n", "import { stringNonEmpty, withValidations } from '../validations';\n\nconst loginIdValidation = stringNonEmpty('loginId');\nconst newPasswordValidation = stringNonEmpty('newPassword');\nexport const withSignValidations = withValidations(\n  loginIdValidation,\n  stringNonEmpty('password'),\n);\nexport const withSendResetValidations = withValidations(loginIdValidation);\nexport const withUpdateValidation = withValidations(\n  loginIdValidation,\n  newPasswordValidation,\n);\nexport const withReplaceValidation = withValidations(\n  loginIdValidation,\n  stringNonEmpty('oldPassword'),\n  newPasswordValidation,\n);\n", "import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { transformResponse } from '../helpers';\nimport {\n  JWTResponse,\n  LoginOptions,\n  PasswordPolicyResponse,\n  PasswordResetResponse,\n  SdkResponse,\n  SignUpOptions,\n  TemplateOptions,\n  User,\n} from '../types';\nimport {\n  withReplaceValidation,\n  withSendResetValidations,\n  withSignValidations,\n  withUpdateValidation,\n} from './validations';\n\nconst withPassword = (httpClient: HttpClient) => ({\n  signUp: withSignValidations(\n    (\n      loginId: string,\n      password: string,\n      user?: User,\n      signUpOptions?: SignUpOptions,\n    ): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.password.signUp, {\n          loginId,\n          password,\n          user,\n          loginOptions: signUpOptions,\n        }),\n      ),\n  ),\n\n  signIn: withSignValidations(\n    (\n      loginId: string,\n      password: string,\n      loginOptions?: LoginOptions,\n    ): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.password.signIn, {\n          loginId,\n          password,\n          loginOptions,\n        }),\n      ),\n  ),\n\n  sendReset: withSendResetValidations(\n    (\n      loginId: string,\n      redirectUrl?: string,\n      templateOptions?: TemplateOptions,\n    ): Promise<SdkResponse<PasswordResetResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.password.sendReset, {\n          loginId,\n          redirectUrl,\n          templateOptions,\n        }),\n      ),\n  ),\n\n  update: withUpdateValidation(\n    (\n      loginId: string,\n      newPassword: string,\n      token?: string,\n    ): Promise<SdkResponse<never>> =>\n      transformResponse(\n        httpClient.post(\n          apiPaths.password.update,\n          {\n            loginId,\n            newPassword,\n          },\n          { token },\n        ),\n      ),\n  ),\n\n  replace: withReplaceValidation(\n    (\n      loginId: string,\n      oldPassword: string,\n      newPassword: string,\n    ): Promise<SdkResponse<JWTResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.password.replace, {\n          loginId,\n          oldPassword,\n          newPassword,\n        }),\n      ),\n  ),\n\n  policy: (): Promise<SdkResponse<PasswordPolicyResponse>> =>\n    transformResponse(httpClient.get(apiPaths.password.policy)),\n});\n\nexport default withPassword;\n", "import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport { transformResponse } from './helpers';\nimport {\n  SdkResponse,\n  ResponseData,\n  LoginOptions,\n  JWTResponse,\n  PasskeyOptions,\n  WebAuthnStartResponse,\n} from './types';\nimport {\n  isStringOrUndefinedValidator,\n  string,\n  stringNonEmpty,\n  withValidations,\n} from './validations';\n\nconst loginIdStringValidations = string('loginId');\nconst loginIdNonEmptyValidations = stringNonEmpty('loginId');\nconst originValidations = stringNonEmpty('origin');\n\nconst withSignUpStartValidations = withValidations(\n  loginIdNonEmptyValidations,\n  originValidations,\n  stringNonEmpty('name'),\n);\nconst withSignUpOrInStartValidations = withValidations(\n  loginIdNonEmptyValidations,\n  originValidations,\n);\nconst withSignInStartValidations = withValidations(\n  loginIdStringValidations,\n  originValidations,\n);\nconst withUpdateStartValidations = withValidations(\n  loginIdNonEmptyValidations,\n  originValidations,\n  isStringOrUndefinedValidator('token'),\n);\nconst withFinishValidations = withValidations(\n  stringNonEmpty('transactionId'),\n  stringNonEmpty('response'),\n);\n\nconst withWebauthn = (httpClient: HttpClient) => ({\n  signUp: {\n    start: withSignUpStartValidations(\n      (\n        loginId: string,\n        origin: string,\n        name: string,\n        passkeyOptions?: PasskeyOptions,\n      ): Promise<SdkResponse<WebAuthnStartResponse>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.signUp.start, {\n            user: {\n              loginId,\n              name,\n            },\n            origin,\n            passkeyOptions,\n          }),\n        ),\n    ),\n\n    finish: withFinishValidations(\n      (\n        transactionId: string,\n        response: string,\n      ): Promise<SdkResponse<JWTResponse>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.signUp.finish, {\n            transactionId,\n            response,\n          }),\n        ),\n    ),\n  },\n\n  signIn: {\n    start: withSignInStartValidations(\n      (\n        loginId: string,\n        origin: string,\n        loginOptions?: LoginOptions,\n        token?: string,\n        passkeyOptions?: PasskeyOptions,\n      ): Promise<SdkResponse<WebAuthnStartResponse>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.webauthn.signIn.start,\n            { loginId, origin, loginOptions, passkeyOptions },\n            { token },\n          ),\n        ),\n    ),\n\n    finish: withFinishValidations(\n      (\n        transactionId: string,\n        response: string,\n      ): Promise<SdkResponse<JWTResponse>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.signIn.finish, {\n            transactionId,\n            response,\n          }),\n        ),\n    ),\n  },\n\n  signUpOrIn: {\n    start: withSignUpOrInStartValidations(\n      (\n        loginId: string,\n        origin: string,\n        passkeyOptions?: PasskeyOptions,\n      ): Promise<SdkResponse<WebAuthnStartResponse>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.signUpOrIn.start, {\n            loginId,\n            origin,\n            passkeyOptions,\n          }),\n        ),\n    ),\n  },\n\n  update: {\n    start: withUpdateStartValidations(\n      (\n        loginId: string,\n        origin: string,\n        token?: string,\n        passkeyOptions?: PasskeyOptions,\n      ): Promise<SdkResponse<WebAuthnStartResponse>> =>\n        transformResponse(\n          httpClient.post(\n            apiPaths.webauthn.update.start,\n            { loginId, origin, passkeyOptions },\n            { token },\n          ),\n        ),\n    ),\n\n    finish: withFinishValidations(\n      (\n        transactionId: string,\n        response: string,\n      ): Promise<SdkResponse<ResponseData>> =>\n        transformResponse(\n          httpClient.post(apiPaths.webauthn.update.finish, {\n            transactionId,\n            response,\n          }),\n        ),\n    ),\n  },\n});\n\nexport default withWebauthn;\n", "import { apiPaths } from '../../constants';\nimport { HttpClient } from '../../httpClient';\nimport { normalizeWaitForSessionConfig } from '../../utils';\nimport { transformResponse } from '../helpers';\nimport {\n  JWTResponse,\n  LoginOptions,\n  SdkResponse,\n  SignUpOptions,\n  User,\n  WaitForSessionConfig,\n} from '../types';\nimport { stringNonEmpty, string, withValidations } from '../validations';\nimport { NOTPResponse } from './types';\n\nconst loginIdValidations = string('loginId');\n\nconst withSignValidations = withValidations(loginIdValidations);\n\nconst withWaitForSessionValidations = withValidations(\n  stringNonEmpty('pendingRef'),\n);\n\nconst withNotp = (httpClient: HttpClient) => ({\n  signUpOrIn: withSignValidations(\n    (\n      loginId?: string,\n      signUpOptions?: SignUpOptions,\n    ): Promise<SdkResponse<NOTPResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.notp.signUpOrIn, {\n          loginId,\n          loginOptions: signUpOptions,\n        }),\n      ),\n  ),\n  signUp: withSignValidations(\n    (\n      loginId?: string,\n      user?: User,\n      signUpOptions?: SignUpOptions,\n    ): Promise<SdkResponse<NOTPResponse>> =>\n      transformResponse(\n        httpClient.post(apiPaths.notp.signUp, {\n          loginId,\n          user,\n          loginOptions: signUpOptions,\n        }),\n      ),\n  ),\n  signIn: withSignValidations(\n    (\n      loginId?: string,\n      loginOptions?: LoginOptions,\n      token?: string,\n    ): Promise<SdkResponse<NOTPResponse>> =>\n      transformResponse(\n        httpClient.post(\n          apiPaths.notp.signIn,\n          { loginId, loginOptions },\n          { token },\n        ),\n      ),\n  ),\n  waitForSession: withWaitForSessionValidations(\n    (\n      pendingRef: string,\n      config?: WaitForSessionConfig,\n    ): Promise<SdkResponse<JWTResponse>> =>\n      new Promise((resolve) => {\n        const { pollingIntervalMs, timeoutMs } =\n          normalizeWaitForSessionConfig(config);\n        let timeout: NodeJS.Timeout | undefined;\n        const interval = setInterval(async () => {\n          const resp = await httpClient.post(apiPaths.notp.session, {\n            pendingRef,\n          });\n          if (resp.ok) {\n            clearInterval(interval);\n            if (timeout) clearTimeout(timeout);\n            resolve(transformResponse(Promise.resolve(resp)));\n          }\n        }, pollingIntervalMs);\n\n        timeout = setTimeout(() => {\n          resolve({\n            error: {\n              errorDescription: `Session polling timeout exceeded: ${timeoutMs}ms`,\n              errorCode: '0',\n            },\n            ok: false,\n          });\n          clearInterval(interval);\n        }, timeoutMs);\n      }),\n  ),\n});\n\nexport default withNotp;\n", "import { apiPaths } from '../constants';\nimport { HttpClient } from '../httpClient';\nimport withAccessKeys from './accesskey';\nimport withEnchantedLink from './enchantedLink';\nimport withFlow from './flow';\nimport {\n  getTenants,\n  getJwtPermissions,\n  getJwtRoles,\n  getCurrentTenant,\n  isJwtExpired,\n  transformResponse,\n} from './helpers';\nimport withMagicLink from './magicLink';\nimport withOauth from './oauth';\nimport withOutbound from './outbound';\nimport withOtp from './otp';\nimport withSaml from './saml';\nimport withTotp from './totp';\nimport withPassword from './password';\nimport {\n  JWTResponse,\n  TenantsResponse,\n  UserHistoryResponse,\n  UserResponse,\n} from './types';\nimport {\n  stringNonEmpty,\n  withValidations,\n  isStringOrUndefinedValidator,\n} from './validations';\nimport withWebauthn from './webauthn';\nimport {\n  isArrayOrBool,\n  isString,\n  isStringOrUndefined,\n} from './validations/validators';\nimport withNotp from './notp';\n\nconst withJwtValidations = withValidations(stringNonEmpty('token'));\nconst withOptionalTokenValidations = withValidations(\n  isStringOrUndefinedValidator('token'),\n);\n\n/** Returns Descope SDK with all available operations */\nexport default (httpClient: HttpClient) => ({\n  accessKey: withAccessKeys(httpClient),\n  otp: withOtp(httpClient),\n  magicLink: withMagicLink(httpClient),\n  enchantedLink: withEnchantedLink(httpClient),\n  oauth: withOauth(httpClient),\n  outbound: withOutbound(httpClient),\n  saml: withSaml(httpClient),\n  totp: withTotp(httpClient),\n  notp: withNotp(httpClient),\n  webauthn: withWebauthn(httpClient),\n  password: withPassword(httpClient),\n  flow: withFlow(httpClient),\n  /**\n   * Refreshes a session token\n   * Should be called when a session has expired (failed validation) to renew it\n   * @param token A valid refresh token\n   * @param queryParams Additional query parameters to send with the request.\n   * @param externalToken An external token to exchange for a new session token\n   * @param tryRefresh If true, will use the tryRefresh endpoint, which will not fail if token is missing, invalid or expired.\n   *    NOTE - queryParams is used internally and should NOT be used by other consumers, this is subject to change and may be removed in the near future.\n   * @returns The updated authentication info (JWTs)\n   */\n  refresh: withOptionalTokenValidations(\n    (\n      token?: string,\n      queryParams?: { [key: string]: string },\n      externalToken?: string,\n      tryRefresh?: boolean,\n    ) => {\n      const body = {};\n      if (externalToken) {\n        body['externalToken'] = externalToken;\n      }\n      const path = tryRefresh ? apiPaths.tryRefresh : apiPaths.refresh;\n      return transformResponse<JWTResponse>(\n        httpClient.post(path, body, { token, queryParams }),\n      );\n    },\n  ),\n  /**\n   * Selects a tenant for the current session\n   * @param tenantId The tenant to select\n   * @param token A valid refresh token\n   * @returns The updated authentication info (JWTs). The session token will be updated with the selected tenant under the \"dct\" claim\n   */\n  selectTenant: withValidations(\n    [isString('tenantId')],\n    [isStringOrUndefined('\"token\" must be string or undefined')],\n  )((tenantId: string, token?: string) =>\n    transformResponse<JWTResponse>(\n      httpClient.post(apiPaths.selectTenant, { tenant: tenantId }, { token }),\n    ),\n  ),\n  /**\n   * Logs out the current session\n   * @param token A valid refresh token\n   */\n  logout: withOptionalTokenValidations((token?: string) =>\n    transformResponse<never>(httpClient.post(apiPaths.logout, {}, { token })),\n  ),\n  /**\n   * Logs out all sessions for the current user\n   * @param token A valid refresh token\n   */\n  logoutAll: withOptionalTokenValidations((token?: string) =>\n    transformResponse<never>(\n      httpClient.post(apiPaths.logoutAll, {}, { token }),\n    ),\n  ),\n  /**\n   * Returns the current user details\n   * @param token A valid refresh token\n   * @returns The current user details\n   */\n  me: withOptionalTokenValidations((token?: string) =>\n    transformResponse<UserResponse>(httpClient.get(apiPaths.me, { token })),\n  ),\n  /**\n   * Returns the current user details\n   * @param tenants set to true IFF the response should include only the selected tenant from JWT, or list of tenant ids\n   * @param token A valid refresh token\n   * @returns The current user details\n   */\n  myTenants: withValidations(\n    [isArrayOrBool('\"tenants\" must a string array or a boolean')],\n    [isStringOrUndefined('\"token\" must be string or undefined')],\n  )((tenants: true | string[], token?: string) => {\n    const body = {};\n    if (typeof tenants === 'boolean') {\n      body['dct'] = tenants;\n    } else {\n      body['ids'] = tenants;\n    }\n    return transformResponse<TenantsResponse>(\n      httpClient.post(apiPaths.myTenants, body, { token }),\n    );\n  }),\n  /**\n   * Returns the current user authentication history\n   * @param token A valid refresh token\n   * @returns The current user authentication history\n   */\n  history: withOptionalTokenValidations((token?: string) =>\n    transformResponse<UserHistoryResponse>(\n      httpClient.get(apiPaths.history, { token }),\n    ),\n  ),\n  /**\n   * Checks if the given JWT is still valid but DOES NOT check for signature\n   * @param token A valid token\n   * @returns true if the JWT is expired, false otherwise\n   */\n  isJwtExpired: withJwtValidations(isJwtExpired),\n  /**\n   * Returns the list of tenants in the given JWT but DOES NOT check for signature\n   * @param token A valid token\n   * @returns The list of tenants in the given JWT\n   */\n  getTenants: withJwtValidations(getTenants),\n  /**\n   * Returns the list of permissions granted in the given JWT but DOES NOT check for signature\n   * @param token A valid token\n   * @param tenant The tenant to check permissions for. If not provided, the permissions for the current tenant will be returned\n   * @returns The list of permissions granted in the given JWT\n   */\n  getJwtPermissions: withJwtValidations(getJwtPermissions),\n  /**\n   * Returns the list of roles specified in the given JWT but DOES NOT check for signature\n   * @param token A valid token\n   * @param tenant The tenant to check roles for. If not provided, the roles for the current tenant will be returned\n   * @returns The list of roles specified in the given JWT\n   */\n  getJwtRoles: withJwtValidations(getJwtRoles),\n  /**\n   * Returns Descope current tenant from the given JWT but DOES NOT check for signature\n   * @param token A valid token\n   * @returns The current tenant from the given JWT\n   */\n  getCurrentTenant: withJwtValidations(getCurrentTenant),\n  /**\n   * Parses the given JWT token but DOES NOT check for signature\n   * @param token A valid token\n   * @returns The parsed JWT token\n   */\n  httpClient,\n});\n", "import createHttpClient from './httpClient';\nimport { Fetch, MultipleHooks } from './httpClient/types';\nimport createSdk from './sdk';\nimport { Logger } from './sdk/types';\nimport { stringNonEmpty, withValidations } from './sdk/validations';\nimport { hasPathValue } from './sdk/validations/validators';\n\ntype SdkConfig = {\n  projectId: string;\n  logger?: Logger;\n  baseUrl?: string;\n  hooks?: MultipleHooks;\n  cookiePolicy?: RequestCredentials | null;\n  baseHeaders?: HeadersInit;\n  refreshCookieName?: string;\n  fetch?: Fetch;\n};\n\n/** Validate we have non-empty project id */\nconst withSdkConfigValidations = withValidations([\n  hasPathValue('projectId', stringNonEmpty('projectId')),\n]);\n\n/** Descope SDK client */\nexport default withSdkConfigValidations((config: SdkConfig) => {\n  const {\n    projectId,\n    logger,\n    baseUrl,\n    cookiePolicy,\n    baseHeaders = {},\n    refreshCookieName,\n    fetch,\n  } = config;\n\n  return createSdk(\n    createHttpClient({\n      baseUrl,\n      projectId,\n      logger,\n      hooks: {\n        get beforeRequest() {\n          return config.hooks?.beforeRequest;\n        },\n        get afterRequest() {\n          return config.hooks?.afterRequest;\n        },\n        get transformResponse() {\n          return config.hooks?.transformResponse;\n        },\n      },\n      cookiePolicy,\n      baseConfig: { baseHeaders },\n      refreshCookieName,\n      fetch,\n    }),\n  );\n});\n", "import createSdk from './createSdk';\nimport {\n  CreateHttpClientConfig,\n  ExtendedResponse,\n  HttpClient,\n  HTTPMethods,\n  RequestConfig,\n} from './httpClient/types';\nimport { OAuthProviders } from './sdk/oauth/types';\nimport { DeliveryMethods } from './sdk/types';\n\n/** Descope SDK client with delivery methods enum.\n *\n * Please see full documentation at {@link https://docs.descope.com/guides Descope Docs}\n * @example Usage\n *\n * ```js\n * import descopeSdk from '@descope/core-js-sdk';\n *\n * const myProjectId = 'xxx';\n * const sdk = descopeSdk({ projectId: myProjectId });\n *\n * const userLoginId = 'loginId';\n * sdk.otp.signIn.email(userLoginId);\n * const jwtResponse = sdk.otp.verify.email(userIdentifier, codeFromEmail);\n * ```\n */\nexport default Object.assign(createSdk, { DeliveryMethods });\n\nexport { default as HttpStatusCodes } from './constants/httpStatusCodes';\nexport { default as createHttpClient } from './httpClient';\nexport { transformResponse } from './sdk/helpers';\nexport type {\n  AccessKeyLoginOptions,\n  EnchantedLinkResponse,\n  ExchangeAccessKeyResponse,\n  FlowAction,\n  FlowResponse,\n  FlowStatus,\n  JWTResponse,\n  LoginOptions,\n  PasskeyOptions,\n  ResponseData,\n  SdkResponse,\n  TOTPResponse,\n  URLResponse,\n  UserHistoryResponse,\n  UserResponse,\n} from './sdk/types';\nexport * from './utils';\nexport type { SdkFnWrapper } from './utils';\nexport type {\n  CreateHttpClientConfig,\n  ExtendedResponse,\n  HttpClient,\n  HTTPMethods,\n  RequestConfig,\n};\n\n/** Type to restrict to valid delivery methods */\nexport type DeliveryMethod = keyof typeof DeliveryMethods;\n/** Type to restrict to valid OAuth providers */\nexport type OAuthProvider = keyof typeof OAuthProviders;\n", "/*! js-cookie v3.0.5 | MIT */\n/* eslint-disable no-var */\nfunction assign (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      target[key] = source[key];\n    }\n  }\n  return target\n}\n/* eslint-enable no-var */\n\n/* eslint-disable no-var */\nvar defaultConverter = {\n  read: function (value) {\n    if (value[0] === '\"') {\n      value = value.slice(1, -1);\n    }\n    return value.replace(/(%[\\dA-F]{2})+/gi, decodeURIComponent)\n  },\n  write: function (value) {\n    return encodeURIComponent(value).replace(\n      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,\n      decodeURIComponent\n    )\n  }\n};\n/* eslint-enable no-var */\n\n/* eslint-disable no-var */\n\nfunction init (converter, defaultAttributes) {\n  function set (name, value, attributes) {\n    if (typeof document === 'undefined') {\n      return\n    }\n\n    attributes = assign({}, defaultAttributes, attributes);\n\n    if (typeof attributes.expires === 'number') {\n      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);\n    }\n    if (attributes.expires) {\n      attributes.expires = attributes.expires.toUTCString();\n    }\n\n    name = encodeURIComponent(name)\n      .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)\n      .replace(/[()]/g, escape);\n\n    var stringifiedAttributes = '';\n    for (var attributeName in attributes) {\n      if (!attributes[attributeName]) {\n        continue\n      }\n\n      stringifiedAttributes += '; ' + attributeName;\n\n      if (attributes[attributeName] === true) {\n        continue\n      }\n\n      // Considers RFC 6265 section 5.2:\n      // ...\n      // 3.  If the remaining unparsed-attributes contains a %x3B (\";\")\n      //     character:\n      // Consume the characters of the unparsed-attributes up to,\n      // not including, the first %x3B (\";\") character.\n      // ...\n      stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];\n    }\n\n    return (document.cookie =\n      name + '=' + converter.write(value, name) + stringifiedAttributes)\n  }\n\n  function get (name) {\n    if (typeof document === 'undefined' || (arguments.length && !name)) {\n      return\n    }\n\n    // To prevent the for loop in the first place assign an empty array\n    // in case there are no cookies at all.\n    var cookies = document.cookie ? document.cookie.split('; ') : [];\n    var jar = {};\n    for (var i = 0; i < cookies.length; i++) {\n      var parts = cookies[i].split('=');\n      var value = parts.slice(1).join('=');\n\n      try {\n        var found = decodeURIComponent(parts[0]);\n        jar[found] = converter.read(value, found);\n\n        if (name === found) {\n          break\n        }\n      } catch (e) {}\n    }\n\n    return name ? jar[name] : jar\n  }\n\n  return Object.create(\n    {\n      set,\n      get,\n      remove: function (name, attributes) {\n        set(\n          name,\n          '',\n          assign({}, attributes, {\n            expires: -1\n          })\n        );\n      },\n      withAttributes: function (attributes) {\n        return init(this.converter, assign({}, this.attributes, attributes))\n      },\n      withConverter: function (converter) {\n        return init(assign({}, this.converter, converter), this.attributes)\n      }\n    },\n    {\n      attributes: { value: Object.freeze(defaultAttributes) },\n      converter: { value: Object.freeze(converter) }\n    }\n  )\n}\n\nvar api = init(defaultConverter, { path: '/' });\n/* eslint-enable no-var */\n\nexport { api as default };\n", "/**\n * Fingerprint Pro v3.11.6 - Copyright (c) FingerprintJS, Inc, 2025 (https://fingerprint.com)\n */\n\nimport{__spreadArray as e,__rest as t,__assign as n}from\"tslib\";function r(e,t){return function(e,t){return Object.prototype.hasOwnProperty.call(e,t)}(e,t)?e[t]:void 0}function o(e,t,n,r){var o,i=document,a=\"securitypolicyviolation\",u=function(t){var n=new URL(e,location.href),r=t.blockedURI;r!==n.href&&r!==n.protocol.slice(0,-1)&&r!==n.origin||(o=t,R())};i.addEventListener(a,u);var R=function(){return i.removeEventListener(a,u)};return null==r||r.then(R,R),Promise.resolve().then(t).then((function(e){return R(),e}),(function(e){return new Promise((function(e){var t=new MessageChannel;t.port1.onmessage=function(){return e()},t.port2.postMessage(null)})).then((function(){if(R(),o)return n(o);throw e}))}))}var i={default:\"endpoint\"},a={default:\"tlsEndpoint\"},u=\"Client timeout\",R=\"Network connection error\",c=\"Network request aborted\",s=\"Response cannot be parsed\",f=\"Blocked by CSP\",l=\"The endpoint parameter is not a valid URL\";function E(e){for(var t=\"\",n=0;n<e.length;++n)if(n>0){var r=e[n].toLowerCase();r!==e[n]?t+=\" \".concat(r):t+=e[n]}else t+=e[n].toUpperCase();return t}var d=/*#__PURE__*/E(\"WrongRegion\"),p=/*#__PURE__*/E(\"SubscriptionNotActive\"),v=/*#__PURE__*/E(\"UnsupportedVersion\"),_=/*#__PURE__*/E(\"InstallationMethodRestricted\"),O=/*#__PURE__*/E(\"HostnameRestricted\"),h=/*#__PURE__*/E(\"IntegrationFailed\"),I=\"API key required\",N=\"API key not found\",T=\"API key expired\",m=\"Request cannot be parsed\",w=\"Request failed\",A=\"Request failed to process\",P=\"Too many requests, rate limit exceeded\",y=\"Not available for this origin\",D=\"Not available with restricted header\",S=I,g=N,L=T,U=\"3.11.6\",b=\"Failed to load the JS script of the agent\",C=\"9319\";function M(t,n){var r,o,i,a,u,R,c,s=[],E=(r=function(t){var n=e([],t,!0);return{current:function(){return n[0]},postpone:function(){var e=n.shift();void 0!==e&&n.push(e)},exclude:function(){n.shift()}}}(t),a=100,u=3e3,R=0,o=function(){return Math.random()*Math.min(u,a*Math.pow(2,R++))},i=new Set,[r.current(),function(e,t){var n,a=t instanceof Error?t.message:\"\";if(a===f||a===l)r.exclude(),n=0;else if(a===C)r.exclude();else if(a===b){var u=Date.now()-e.getTime()<50,R=r.current();R&&u&&!i.has(R)&&(i.add(R),n=0),r.postpone()}else r.postpone();var c=r.current();return void 0===c?void 0:[c,null!=n?n:e.getTime()+o()-Date.now()]}]),d=E[0],p=E[1];if(void 0===d)return Promise.reject(new TypeError(\"The list of script URL patterns is empty\"));var v=function(e){var t=new Date,r=function(n){return s.push({url:e,startedAt:t,finishedAt:new Date,error:n})},o=n(e);return o.then((function(){return r()}),r),o.catch((function(e){if(null!=c||(c=e),s.length>=5)throw c;var n=p(t,e);if(!n)throw c;var r,o=n[0],i=n[1];return(r=i,new Promise((function(e){return setTimeout(e,r)}))).then((function(){return v(o)}))}))};return v(d).then((function(e){return[e,s]}))}var K=\"https://fpnpmcdn.net/v<version>/<apiKey>/loader_v<loaderVersion>.js\",B=K;function F(e){var o;e.scriptUrlPattern;var i=e.token,a=e.apiKey,u=void 0===a?i:a,R=t(e,[\"scriptUrlPattern\",\"token\",\"apiKey\"]),c=null!==(o=r(e,\"scriptUrlPattern\"))&&void 0!==o?o:K,s=function(){var e=[],t=function(){e.push({time:new Date,state:document.visibilityState})},n=function(e,t,n,r){return e.addEventListener(t,n,r),function(){return e.removeEventListener(t,n,r)}}(document,\"visibilitychange\",t);return t(),[e,n]}(),f=s[0],l=s[1];return Promise.resolve().then((function(){if(!u||\"string\"!=typeof u)throw new Error(I);var e=function(e,t){return(Array.isArray(e)?e:[e]).map((function(e){return function(e,t){var n=encodeURIComponent;return e.replace(/<[^<>]+>/g,(function(e){return\"<version>\"===e?\"3\":\"<apiKey>\"===e?n(t):\"<loaderVersion>\"===e?n(U):e}))}(String(e),t)}))}(c,u);return M(e,V)})).catch((function(e){throw l(),function(e){if(e instanceof Error&&e.message===C)return new Error(b);return e}(e)})).then((function(e){var t=e[0],r=e[1];return l(),t.load(n(n({},R),{ldi:{attempts:r,visibilityStates:f}}))}))}function V(e){return o(e,(function(){return function(e){return new Promise((function(t,n){if(function(e){if(URL.prototype)try{return new URL(e,location.href),!1}catch(t){if(t instanceof Error&&\"TypeError\"===t.name)return!0;throw t}}(e))throw new Error(l);var r=document.createElement(\"script\"),o=function(){var e;return null===(e=r.parentNode)||void 0===e?void 0:e.removeChild(r)},i=document.head||document.getElementsByTagName(\"head\")[0];r.onload=function(){o(),t()},r.onerror=function(){o(),n(new Error(b))},r.async=!0,r.src=e,i.appendChild(r)}))}(e)}),(function(){throw new Error(f)})).then(k)}function k(){var e=window,t=\"__fpjs_p_l_b\",n=e[t];if(function(e,t){var n,r=null===(n=Object.getOwnPropertyDescriptor)||void 0===n?void 0:n.call(Object,e,t);(null==r?void 0:r.configurable)?delete e[t]:r&&!r.writable||(e[t]=void 0)}(e,t),\"function\"!=typeof(null==n?void 0:n.load))throw new Error(C);return n}var G={load:F,defaultScriptUrlPattern:B,ERROR_SCRIPT_LOAD_FAIL:b,ERROR_API_KEY_EXPIRED:T,ERROR_API_KEY_INVALID:N,ERROR_API_KEY_MISSING:I,ERROR_BAD_REQUEST_FORMAT:m,ERROR_BAD_RESPONSE_FORMAT:s,ERROR_CLIENT_TIMEOUT:u,ERROR_CSP_BLOCK:f,ERROR_FORBIDDEN_ENDPOINT:O,ERROR_FORBIDDEN_HEADER:D,ERROR_FORBIDDEN_ORIGIN:y,ERROR_GENERAL_SERVER_FAILURE:w,ERROR_INSTALLATION_METHOD_RESTRICTED:_,ERROR_INTEGRATION_FAILURE:h,ERROR_INVALID_ENDPOINT:l,ERROR_NETWORK_ABORT:c,ERROR_NETWORK_CONNECTION:R,ERROR_RATE_LIMIT:P,ERROR_SERVER_TIMEOUT:A,ERROR_SUBSCRIPTION_NOT_ACTIVE:p,ERROR_TOKEN_EXPIRED:L,ERROR_TOKEN_INVALID:g,ERROR_TOKEN_MISSING:S,ERROR_UNSUPPORTED_VERSION:v,ERROR_WRONG_REGION:d,defaultEndpoint:i,defaultTlsEndpoint:a};export{T as ERROR_API_KEY_EXPIRED,N as ERROR_API_KEY_INVALID,I as ERROR_API_KEY_MISSING,m as ERROR_BAD_REQUEST_FORMAT,s as ERROR_BAD_RESPONSE_FORMAT,u as ERROR_CLIENT_TIMEOUT,f as ERROR_CSP_BLOCK,O as ERROR_FORBIDDEN_ENDPOINT,D as ERROR_FORBIDDEN_HEADER,y as ERROR_FORBIDDEN_ORIGIN,w as ERROR_GENERAL_SERVER_FAILURE,_ as ERROR_INSTALLATION_METHOD_RESTRICTED,h as ERROR_INTEGRATION_FAILURE,l as ERROR_INVALID_ENDPOINT,c as ERROR_NETWORK_ABORT,R as ERROR_NETWORK_CONNECTION,P as ERROR_RATE_LIMIT,b as ERROR_SCRIPT_LOAD_FAIL,A as ERROR_SERVER_TIMEOUT,p as ERROR_SUBSCRIPTION_NOT_ACTIVE,L as ERROR_TOKEN_EXPIRED,g as ERROR_TOKEN_INVALID,S as ERROR_TOKEN_MISSING,v as ERROR_UNSUPPORTED_VERSION,d as ERROR_WRONG_REGION,G as default,i as defaultEndpoint,B as defaultScriptUrlPattern,a as defaultTlsEndpoint,F as load};\n", "import { JWTResponse, UserResponse } from '@descope/core-js-sdk';\nimport { CoreSdkConfig, WebJWTResponse, WebSigninResponse } from '../../types';\nimport { jwtDecode, JwtPayload } from 'jwt-decode';\n\nconst getExpirationFromToken = (token: string) => {\n  try {\n    const claims = jwtDecode<JwtPayload>(token);\n    return claims.exp;\n  } catch (e) {\n    return null;\n  }\n};\n\nconst oidcRefreshTokenExpiration = (response: WebSigninResponse) => {\n  const { refresh_expire_in, refresh_token } = response;\n  if (refresh_expire_in) {\n    return Math.floor(Date.now() / 1000) + refresh_expire_in;\n  }\n  return getExpirationFromToken(refresh_token);\n};\n\nconst oidcAccessTokenExpiration = (response: WebSigninResponse) => {\n  // oidc-client-ts may return the expiration time in\n  // - the expires_at (timestamp in seconds)\n  // - the expires_in (ttl in seconds)\n  // - we also fallback to the token itself\n  const { expires_in, expires_at, access_token } = response;\n  if (expires_at) {\n    return expires_at;\n  }\n  if (expires_in) {\n    // get expiration time from the expires_in in seconds\n    return Math.floor(Date.now() / 1000) + expires_in;\n  }\n  if (access_token) {\n    // get expiration time from the token itself\n    return getExpirationFromToken(access_token);\n  }\n  return undefined;\n};\n\nconst normalizeWebJWTResponseToJWTResponse = (\n  response: WebSigninResponse,\n): WebJWTResponse => {\n  const { access_token, id_token, refresh_token, refresh_expire_in, ...rest } =\n    response;\n  return {\n    sessionJwt: response.sessionJwt || access_token,\n    idToken: id_token,\n    refreshJwt: response.refreshJwt || refresh_token,\n    sessionExpiration:\n      response.sessionExpiration || oidcAccessTokenExpiration(response),\n    cookieExpiration:\n      response.cookieExpiration ||\n      (oidcRefreshTokenExpiration(response) as number),\n    ...rest,\n  };\n};\n\n/**\n * Add hooks to an existing core-sdk config\n */\nexport const addHooks = <Config extends CoreSdkConfig>(\n  config: Config,\n  hooks: Config['hooks'],\n): Config => {\n  ['beforeRequest', 'afterRequest'].reduce(\n    (acc, key) => {\n      acc[key] = []\n        .concat(config.hooks?.[key] || [])\n        .concat(hooks?.[key] || []);\n\n      return acc;\n    },\n    (config.hooks ??= {}),\n  );\n\n  return config;\n};\n\nexport { compose } from './compose';\n\n/**\n * Extract auth info (JWT response) from fetch response\n * We assume that the auth info is under a \"authInfo\" attribute (flow response)\n * Or the body itself (other auth methods response)\n */\nexport const getAuthInfoFromResponse = async (\n  res: Response,\n): Promise<Partial<WebJWTResponse>> => {\n  if (!res?.ok) return {};\n  const body = await res?.clone().json();\n  const authInfo = body?.authInfo || body || ({} as Partial<WebJWTResponse>);\n  return normalizeWebJWTResponseToJWTResponse(authInfo);\n};\n\n/**\n * Extract user from fetch response\n * User my exist under \"user\" attribute (auth methods response)\n * Or the body itself (when calling \"me\")\n */\nexport const getUserFromResponse = async (\n  res: Response,\n): Promise<UserResponse> | undefined => {\n  const authInfo = await getAuthInfoFromResponse(res);\n\n  return (\n    authInfo?.user ||\n    (authInfo?.hasOwnProperty('userId')\n      ? (authInfo as UserResponse)\n      : undefined)\n  );\n};\n\n// This window flag is set by mobile frameworks\nexport const isDescopeBridge = () =>\n  typeof window !== 'undefined' && !!window['descopeBridge'];\n\nexport const isLocalStorage = typeof localStorage !== 'undefined';\n\nexport const setLocalStorage = (key: string, value: string) =>\n  isLocalStorage && localStorage?.setItem(key, value);\nexport const getLocalStorage = (key: string) =>\n  isLocalStorage && localStorage?.getItem(key);\nexport const removeLocalStorage = (key: string) =>\n  isLocalStorage && localStorage?.removeItem(key);\n", "const logger = {\n  debug: (...args: any[]) => {\n    // eslint-disable-next-line no-console\n    console.debug(...args);\n  },\n};\n\nexport default logger;\n", "const OIDC_CLIENT_TS_VERSION = '3.2.0';\n\n// This sdk can be used in SSR apps\nexport const IS_BROWSER = typeof window !== 'undefined';\n\n// Maximum timeout value for setTimeout\n// For more information, refer to https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value\nexport const MAX_TIMEOUT = Math.pow(2, 31) - 1;\n\n// The amount of time (ms) to trigger the refresh before session expires\nexport const REFRESH_THRESHOLD = 20 * 1000; // 20 sec\n\nexport const OIDC_CLIENT_TS_DESCOPE_CDN_URL = `https://descopecdn.com/npm/oidc-client-ts@${OIDC_CLIENT_TS_VERSION}/dist/browser/oidc-client-ts.min.js`;\nexport const OIDC_CLIENT_TS_JSDELIVR_CDN_URL = `https://cdn.jsdelivr.net/npm/oidc-client-ts@${OIDC_CLIENT_TS_VERSION}/dist/browser/oidc-client-ts.min.js`;\n\nexport const OIDC_LOGOUT_ERROR_CODE = 'J161000';\nexport const OIDC_REFRESH_ERROR_CODE = 'J161001';\n", "import { jwtDecode, JwtPayload } from 'jwt-decode';\nimport logger from '../helpers/logger';\nimport { MAX_TIMEOUT, REFRESH_THRESHOLD } from '../../constants';\n\n/**\n * Get the JWT expiration WITHOUT VALIDATING the JWT\n * @param token The JWT to extract expiration from\n * @returns The Date for when the JWT expires or null if there is an issue\n */\nexport const getTokenExpiration = (\n  token: string,\n  sessionExpiration: number,\n) => {\n  if (sessionExpiration) {\n    return new Date(sessionExpiration * 1000);\n  }\n\n  logger.debug(\n    'Could not extract expiration time from session token, trying to decode the token',\n  );\n  try {\n    const claims = jwtDecode<JwtPayload>(token);\n    if (claims.exp) {\n      return new Date(claims.exp * 1000);\n    }\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const millisecondsUntilDate = (date: Date) =>\n  date ? date.getTime() - new Date().getTime() : 0;\n\nexport const createTimerFunctions = () => {\n  const timerIds: NodeJS.Timeout[] = [];\n\n  const clearAllTimers = () => {\n    while (timerIds.length) {\n      clearTimeout(timerIds.pop());\n    }\n  };\n\n  const setTimer = (cb: () => void, timeout: number) => {\n    timerIds.push(setTimeout(cb, timeout));\n  };\n\n  return { clearAllTimers, setTimer };\n};\n\nexport const getAutoRefreshTimeout = (sessionExpiration: Date) => {\n  let timeout = millisecondsUntilDate(sessionExpiration) - REFRESH_THRESHOLD;\n\n  if (timeout > MAX_TIMEOUT) {\n    logger.debug(\n      `Timeout is too large (${timeout}ms), setting it to ${MAX_TIMEOUT}ms`,\n    );\n    timeout = MAX_TIMEOUT;\n  }\n\n  return timeout;\n};\n", "/** Default name for the session cookie name / local storage key */\nexport const SESSION_TOKEN_KEY = 'DS';\n/** Default name for the refresh local storage key */\nexport const REFRESH_TOKEN_KEY = 'DSR';\n/* Default name for the id token local storage key */\nexport const ID_TOKEN_KEY = 'DSI';\n", "import { JWTResponse } from '@descope/core-js-sdk';\nimport Cookies from 'js-cookie';\nimport { BeforeRequestHook, WebJWTResponse } from '../../types';\nimport {\n  ID_TOKEN_KEY,\n  REFRESH_TOKEN_KEY,\n  SESSION_TOKEN_KEY,\n} from './constants';\nimport {\n  getLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\nimport { CookieConfig, SameSite } from './types';\n\n/**\n * Store the session JWT as a cookie on the given domain and path with the given expiration.\n * This is useful so that the application backend will automatically get the cookie for the session\n * @param name cookie name\n * @param value The JWT to store as a cookie\n * @param cookieParams configuration that is usually returned from the JWT\n */\nfunction setJwtTokenCookie(\n  name: string,\n  value: string,\n  authInfo: Partial<\n    WebJWTResponse & { cookieSameSite: SameSite; cookieSecure: boolean }\n  >,\n) {\n  if (value) {\n    const {\n      cookieDomain,\n      cookiePath,\n      cookieSameSite,\n      cookieExpiration,\n      cookieSecure,\n    } = authInfo;\n    const expires = new Date(cookieExpiration * 1000); // we are getting response from the server in seconds instead of ms\n    // Since its a JS cookie, we don't set the domain because we want the cookie to be on the same domain as the application\n    const domainMatches = isCurrentDomainOrParentDomain(cookieDomain);\n    Cookies.set(name, value, {\n      path: cookiePath,\n      domain: domainMatches ? cookieDomain : undefined,\n      expires,\n      sameSite: cookieSameSite,\n      secure: cookieSecure,\n    });\n  }\n}\n\n/*\n * Check if the cookie domain is the same as the current domain or the parent domain\n * Examples:\n * 1. cookie domain: 'example.com', current domain: 'example.com' => true\n * 2. cookie domain: 'example.com', current domain: 'sub.example.com' => true\n * 3. cookie domain: 'example.com', current domain: 'sub.sub.example.com' => true\n * 4. cookie domain: 'example.com', current domain: 'another.com' => false\n * 5. cookie domain: 'example.com', current domain: 'example.co.il' => false\n */\nfunction isCurrentDomainOrParentDomain(cookieDomain: string): boolean {\n  const currentDomain = window.location.hostname;\n  const currentDomainParts = currentDomain.split('.');\n  const cookieDomainParts = cookieDomain.split('.');\n\n  // check if the cookie domain items are the last items in the current domain\n  const currentDomainSuffix = currentDomainParts\n    .slice(-cookieDomainParts.length)\n    .join('.');\n  return currentDomainSuffix === cookieDomain;\n}\n\nexport const persistTokens = (\n  authInfo = {} as Partial<WebJWTResponse>,\n  sessionTokenViaCookie: boolean | CookieConfig = false,\n  storagePrefix = '',\n) => {\n  // persist refresh token\n  const { sessionJwt, refreshJwt } = authInfo;\n  refreshJwt &&\n    setLocalStorage(`${storagePrefix}${REFRESH_TOKEN_KEY}`, refreshJwt);\n\n  // persist session token\n  if (sessionJwt) {\n    if (sessionTokenViaCookie) {\n      // Cookie configs will fallback to default values in both cases\n      // 1. sessionTokenViaCookie is a boolean\n      // 2. sessionTokenViaCookie is an object without the property\n      const cookieSameSite = sessionTokenViaCookie['sameSite'] || 'Strict';\n      const cookieSecure = sessionTokenViaCookie['secure'] ?? true;\n      setJwtTokenCookie(SESSION_TOKEN_KEY, sessionJwt, {\n        ...(authInfo as Partial<JWTResponse>),\n        cookieSameSite,\n        cookieSecure,\n      });\n    } else {\n      setLocalStorage(`${storagePrefix}${SESSION_TOKEN_KEY}`, sessionJwt);\n    }\n  }\n\n  if (authInfo.idToken) {\n    setLocalStorage(`${storagePrefix}${ID_TOKEN_KEY}`, authInfo.idToken);\n  }\n};\n\n/** Return the refresh token from the localStorage. Not for production usage because refresh token will not be saved in localStorage. */\nexport function getRefreshToken(prefix: string = '') {\n  return getLocalStorage(`${prefix}${REFRESH_TOKEN_KEY}`) || '';\n}\n\n/**\n * Return the session token. first try to get from cookie, and fallback to local storage\n * See sessionTokenViaCookie option for more details about session token location\n */\nexport function getSessionToken(prefix: string = ''): string {\n  return (\n    Cookies.get(SESSION_TOKEN_KEY) ||\n    getLocalStorage(`${prefix}${SESSION_TOKEN_KEY}`) ||\n    ''\n  );\n}\n\nexport function getIdToken(prefix: string = ''): string {\n  return getLocalStorage(`${prefix}${ID_TOKEN_KEY}`) || '';\n}\n\n/** Remove both the localStorage refresh JWT and the session cookie */\nexport function clearTokens(prefix: string = '') {\n  removeLocalStorage(`${prefix}${REFRESH_TOKEN_KEY}`);\n  removeLocalStorage(`${prefix}${SESSION_TOKEN_KEY}`);\n  removeLocalStorage(`${prefix}${ID_TOKEN_KEY}`);\n  Cookies.remove(SESSION_TOKEN_KEY);\n}\n\nexport const beforeRequest =\n  (prefix?: string): BeforeRequestHook =>\n  (config) => {\n    return Object.assign(config, {\n      token: config.token || getRefreshToken(prefix),\n    });\n  };\n", "import { IS_BROWSER } from '../../constants';\n\nconst FINGERPRINT_PUBLIC_KEY = 'fingerprint.public.key';\nconst FINGERPRINT_ENDPOINT_URL = 'fingerprint.endpoint.url';\n\n/** Fingerprint.js cloudflare integration */\nexport const FP_EP_URL =\n  (IS_BROWSER && localStorage?.getItem(FINGERPRINT_ENDPOINT_URL)) ||\n  'https://api.descope.com';\nexport const FP_CF_ENDPOINT_PATH = '/fXj8gt3x8VulJBna/x96Emn69oZwcd7I6';\nexport const FP_CF_SCRIPT_PATH = '/fXj8gt3x8VulJBna/w78aRZnnDZ3Aqw0I';\n/** Fingerprint visitor data */\nexport const FP_BODY_DATA = 'fpData';\n/** Session ID for visitor */\nexport const VISITOR_SESSION_ID_PARAM = 'vsid';\n/** Request ID for visitor */\nexport const VISITOR_REQUEST_ID_PARAM = 'vrid';\n/** FP storage key */\nexport const FP_STORAGE_KEY = 'fp';\n// Storage FP Keys TTL is 24 hours\nexport const STORAGE_TTL_MS = 24 * 60 * 60 * 1000;\n", "import {\n  load,\n  defaultEndpoint,\n  defaultScriptUrlPattern,\n} from '@fingerprintjs/fingerprintjs-pro';\nimport {\n  FP_EP_URL,\n  FP_CF_ENDPOINT_PATH,\n  FP_CF_SCRIPT_PATH,\n  FP_STORAGE_KEY,\n  STORAGE_TTL_MS,\n  VISITOR_REQUEST_ID_PARAM,\n  VISITOR_SESSION_ID_PARAM,\n} from './constants';\nimport { FingerprintObject } from './types';\n\nconst createFingerprintObject = (\n  sessionId: string,\n  requestId: string,\n): FingerprintObject => ({\n  [VISITOR_SESSION_ID_PARAM]: sessionId,\n  [VISITOR_REQUEST_ID_PARAM]: requestId,\n});\n\n/** Generate UUID based on current time and some randomness */\nconst generateUUID = () => {\n  // return alphanumeric, sortable uuid of 27 characters\n  return (\n    Date.now().toString(36) +\n    Math.random().toString(36).substring(2) + // removing '0.' prefix\n    Math.random().toString(36).substring(2)\n  ).substring(0, 27);\n};\n\n// Set FP data to storage with expiration\n// We set the request id and session id together so they will have the same TTL\n// This implementation is based on https://www.sohamkamani.com/javascript/localstorage-with-ttl-expiry/\nconst setFPToStorage = (value: FingerprintObject) => {\n  const now = new Date();\n  // `item` is an object which contains the value\n  // as well as the time when it's supposed to expire\n  const item = {\n    value,\n    expiry: now.getTime() + STORAGE_TTL_MS,\n  };\n  localStorage.setItem(FP_STORAGE_KEY, JSON.stringify(item));\n};\n\n// Get Fingerprint from storage, will return null if not exists, or if expired\nconst getFPFromStorage = (returnExpired = false): FingerprintObject => {\n  const itemStr = localStorage.getItem(FP_STORAGE_KEY);\n  // if the item doesn't exist, return null\n  if (!itemStr) {\n    return null;\n  }\n  const item = JSON.parse(itemStr);\n  const now = new Date();\n  // compare the expiry time of the item with the current time\n  // return null if needed\n  if (now.getTime() > item.expiry && !returnExpired) {\n    return null;\n  }\n  return item.value;\n};\n\n/**\n * Ensure fingerprint ids (request id, session id) exist.\n * If not, It will generate and load them into to browser storage.\n * NOTE: Using fingerprintJS data has cost, use considerably.\n * @param fpKey FingerprintJS API key\n */\nexport const ensureFingerprintIds = async (\n  fpKey: string,\n  baseUrl = FP_EP_URL,\n) => {\n  try {\n    if (getFPFromStorage()) {\n      // FP is already in storage, no need to\n      return;\n    }\n\n    const sessionId = generateUUID();\n\n    const endpointUrl = new URL(baseUrl);\n    endpointUrl.pathname = FP_CF_ENDPOINT_PATH;\n\n    const patterUrl = new URL(baseUrl);\n    patterUrl.pathname = FP_CF_SCRIPT_PATH;\n    const scriptUrlPattern =\n      patterUrl.toString() +\n      '?apiKey=<apiKey>&version=<version>&loaderVersion=<loaderVersion>';\n\n    // load from FingerprintJS\n    const agentP = load({\n      apiKey: fpKey,\n      endpoint: [\n        endpointUrl.toString(),\n        defaultEndpoint, // Fallback to default endpoint in case of error\n      ],\n      scriptUrlPattern: [\n        scriptUrlPattern,\n        defaultScriptUrlPattern, // Fallback to default CDN in case of error\n      ],\n    });\n\n    const agent = await agentP;\n    const { requestId } = await agent.get({ linkedId: sessionId });\n    const fpData = createFingerprintObject(sessionId, requestId);\n    setFPToStorage(fpData);\n  } catch (ex) {\n    // eslint-disable-next-line no-console\n    console.warn('Could not load fingerprint', ex);\n  }\n};\n\n/**\n * Get Fingerprint data (request ids) from storage, or create empty object\n * If data is expired, return it anyway\n */\nexport const getFingerprintData = (): FingerprintObject | null => {\n  // get from storage if exists\n  return getFPFromStorage(true);\n};\n\n/** Clear Fingerprint data from storage */\nexport const clearFingerprintData = () => {\n  localStorage.removeItem(FP_STORAGE_KEY);\n};\n", "import { IS_BROWSER } from '../../constants';\nimport { CreateWebSdk } from '../../sdk';\nimport { BeforeRequestHook } from '../../types';\nimport { addHooks } from '../helpers';\nimport { FP_BODY_DATA } from './constants';\nimport { ensureFingerprintIds, getFingerprintData } from './helpers';\nimport { FingerprintOptions } from './types';\n\nconst beforeRequest: BeforeRequestHook = (config) => {\n  const data = getFingerprintData();\n  if (data && config.body) {\n    config.body[FP_BODY_DATA] = data;\n  }\n\n  return config;\n};\n\n/**\n * Add fingerprint data to outgoing requests\n */\nexport const withFingerprint =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({ fpKey, fpLoad, ...config }: Parameters<T>[0] & FingerprintOptions) => {\n    if (!IS_BROWSER) {\n      // Fingerprint is a client side only capability and will not work when running in the server (SSR)\n      return createSdk(config);\n    }\n\n    // load fingerprint now if needed\n    if (fpKey && fpLoad) {\n      ensureFingerprintIds(fpKey).catch(\n        // istanbul ignore next\n        () => null,\n      );\n    }\n\n    // Hook added always because fingerprint can be dynamic using flows\n    return createSdk(addHooks(config, { beforeRequest }));\n  };\n", "export const FLOW_NONCE_PREFIX = 'descopeFlowNonce';\nexport const FLOW_NONCE_HEADER = 'X-Descope-Flow-Nonce';\n\nexport const FLOW_START_PATH = '/v1/flow/start';\nexport const FLOW_NEXT_PATH = '/v1/flow/next';\n\nexport const FLOW_NEXT_TTL = 3 * 60 * 60; // 3 hours in seconds\nexport const FLOW_START_TTL = 2 * 24 * 60 * 60; // 2 days in seconds\n", "import { RequestConfig } from '@descope/core-js-sdk';\nimport {\n  getLocalStorage,\n  isLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\nimport {\n  FLOW_NEXT_PATH,\n  FLOW_NEXT_TTL,\n  FLOW_NONCE_HEADER,\n  FLOW_NONCE_PREFIX,\n  FLOW_START_TTL,\n} from './constants';\nimport { StorageItem } from './types';\n\n// Helper to create storage key from execution ID\nconst getNonceKeyForExecution = (\n  executionId: string,\n  prefix: string = FLOW_NONCE_PREFIX,\n): string => {\n  return `${prefix}${executionId}`;\n};\n\n// Get nonce from storage with expiration check\nconst getFlowNonce = (\n  executionId: string,\n  prefix: string = FLOW_NONCE_PREFIX,\n): string | null => {\n  try {\n    const key = getNonceKeyForExecution(executionId, prefix);\n    const itemStr = getLocalStorage(key);\n\n    if (!itemStr) {\n      return null;\n    }\n\n    const item: StorageItem = JSON.parse(itemStr);\n\n    if (item.expiry < Date.now()) {\n      removeFlowNonce(executionId, prefix);\n      return null;\n    }\n\n    return item.value;\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error('Error getting flow nonce:', e);\n    return null;\n  }\n};\n\n// Store nonce with appropriate TTL\nconst setFlowNonce = (\n  executionId: string,\n  nonce: string,\n  isStart: boolean,\n  prefix: string = FLOW_NONCE_PREFIX,\n): void => {\n  try {\n    const key = getNonceKeyForExecution(executionId, prefix);\n    const ttlSeconds = isStart ? FLOW_START_TTL : FLOW_NEXT_TTL;\n\n    const item: StorageItem = {\n      value: nonce,\n      expiry: Date.now() + ttlSeconds * 1000,\n      isStart,\n    };\n\n    setLocalStorage(key, JSON.stringify(item));\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error('Error setting flow nonce:', e);\n  }\n};\n\n// Remove nonce from storage\nconst removeFlowNonce = (\n  executionId: string,\n  prefix: string = FLOW_NONCE_PREFIX,\n): void => {\n  try {\n    const key = getNonceKeyForExecution(executionId, prefix);\n    removeLocalStorage(key);\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error('Error removing flow nonce:', e);\n  }\n};\n\n// Extract execution ID from special format\nconst extractExecId = (executionId: string): string | null => {\n  const regex = /.*\\|#\\|(.*)/;\n  return regex.exec(executionId)?.[1] || null;\n};\n\n// Extract nonce and execution ID from response\nconst extractFlowNonce = async (\n  req: RequestConfig,\n  response: Response,\n): Promise<{ nonce: string | null; executionId: string | null }> => {\n  try {\n    const nonce = response.headers.get(FLOW_NONCE_HEADER);\n\n    // Clone the response to prevent body consumption\n    let executionId = await response\n      .clone()\n      .json()\n      .then((data) => data?.executionId || null)\n      .catch(() => null);\n\n    if (!executionId) {\n      // Fallback to request\n      executionId = getExecutionIdFromRequest(req);\n    }\n\n    return {\n      nonce,\n      executionId: extractExecId(executionId),\n    };\n  } catch (e) {\n    return { nonce: null, executionId: null };\n  }\n};\n\n// Get execution ID from request object\nconst getExecutionIdFromRequest = (req: RequestConfig): string | null => {\n  if (req.path === FLOW_NEXT_PATH && req.body?.executionId) {\n    return extractExecId(req.body.executionId);\n  }\n\n  return null;\n};\n\n// Remove expired nonces from storage\nconst cleanupExpiredNonces = (prefix: string = FLOW_NONCE_PREFIX): void => {\n  try {\n    if (!isLocalStorage) {\n      return;\n    }\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n\n      if (key && key.startsWith(prefix)) {\n        const itemStr = getLocalStorage(key);\n\n        if (itemStr) {\n          try {\n            const item: StorageItem = JSON.parse(itemStr);\n\n            if (item.expiry < Date.now()) {\n              removeLocalStorage(key);\n            }\n          } catch (parseError) {\n            removeLocalStorage(key);\n          }\n        }\n      }\n    }\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error('Error cleaning up expired nonces:', e);\n  }\n};\n\nexport {\n  cleanupExpiredNonces,\n  extractFlowNonce,\n  getExecutionIdFromRequest,\n  getFlowNonce,\n  getNonceKeyForExecution,\n  removeFlowNonce,\n  setFlowNonce,\n};\n", "/** Login Id of the last user logged in */\nexport const LOCAL_STORAGE_LAST_USER_LOGIN_ID = 'dls_last_user_login_id';\n\n/** Display name of the last user logged in */\nexport const LOCAL_STORAGE_LAST_USER_DISPLAY_NAME =\n  'dls_last_user_display_name';\n", "import {\n  getLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\nimport {\n  LOCAL_STORAGE_LAST_USER_LOGIN_ID,\n  LOCAL_STORAGE_LAST_USER_DISPLAY_NAME,\n} from './constants';\n\nexport const setLastUserLoginId = (loginId: string) => {\n  return setLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID, loginId);\n};\n\nexport const getLastUserLoginId = () => {\n  return getLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID);\n};\n\nexport const removeLastUserLoginId = () => {\n  return removeLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID);\n};\n\nexport const setLastUserDisplayName = (displayName: string) => {\n  return setLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME, displayName);\n};\n\nexport const getLastUserDisplayName = () => {\n  return getLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME);\n};\n\nexport const removeLastUserDisplayName = () => {\n  return removeLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME);\n};\n", "import { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook, CoreSdk } from '../../types';\nimport { addHooks, getUserFromResponse } from '../helpers';\nimport {\n  getLastUserLoginId,\n  removeLastUserLoginId,\n  setLastUserLoginId,\n  getLastUserDisplayName,\n  removeLastUserDisplayName,\n  setLastUserDisplayName,\n} from './helpers';\nimport { LastLoggedInUserOptions } from './types';\n\n/**\n * Adds last logged in user to flow start request\n */\n// eslint-disable-next-line import/exports-last\nexport const withLastLoggedInUser =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({\n    storeLastAuthenticatedUser = true,\n    keepLastAuthenticatedUserAfterLogout = false,\n    ...config\n  }: Parameters<T>[0] & LastLoggedInUserOptions): ReturnType<T> & {\n    getLastUserLoginId: typeof getLastUserLoginId;\n    getLastUserDisplayName: typeof getLastUserDisplayName;\n  } => {\n    if (!storeLastAuthenticatedUser) {\n      // We assign getLastUserLoginId and getLastUserDisplayName to the sdk\n      // To keep the return type consistent\n      return Object.assign(createSdk(config), {\n        getLastUserLoginId,\n        getLastUserDisplayName,\n      }) as any;\n    }\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      const userDetails = await getUserFromResponse(res);\n      const loginId = userDetails?.loginIds?.[0];\n      const displayName = userDetails?.name;\n      if (loginId) {\n        setLastUserLoginId(loginId);\n        setLastUserDisplayName(displayName);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    let wrappedSdk = wrapWith(sdk, ['flow.start'], startWrapper);\n    wrappedSdk = wrapWith(\n      wrappedSdk,\n      ['logout', 'logoutAll'],\n      logoutWrapper(keepLastAuthenticatedUserAfterLogout),\n    );\n    return Object.assign(wrappedSdk, {\n      getLastUserLoginId,\n      getLastUserDisplayName,\n    }) as any;\n  };\n\nconst startWrapper: SdkFnWrapper<{}> =\n  (fn) =>\n  async (...args) => {\n    args[1] = args[1] || {};\n    const [, options = {}] = args as unknown as Parameters<\n      CoreSdk['flow']['start']\n    >;\n    const loginId = getLastUserLoginId();\n    const displayName = getLastUserDisplayName();\n\n    if (loginId) {\n      options.lastAuth ??= {};\n      options.lastAuth.loginId = loginId;\n      options.lastAuth.name = displayName;\n    }\n\n    const resp = await fn(...args);\n\n    return resp;\n  };\n\nconst logoutWrapper =\n  (keepOnLogout?: boolean): SdkFnWrapper<{}> =>\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n    if (keepOnLogout) {\n      return resp;\n    }\n\n    removeLastUserLoginId();\n    removeLastUserDisplayName();\n\n    return resp;\n  };\n", "// create publisher/subscriber instances\nexport function createPubSub<T extends any>() {\n  const cbs = [];\n\n  const sub = (cb: (data: T) => void) => {\n    const idx = cbs.push(cb) - 1;\n    return () => cbs.splice(idx, 1);\n  };\n\n  const pub = (data: T) => {\n    cbs.forEach((cb) => cb(data));\n  };\n\n  return { pub, sub };\n}\n", "import { SdkFnWrapper, UserResponse, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk, WebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport {\n  addHooks,\n  getAuthInfoFromResponse,\n  getUserFromResponse,\n} from '../helpers';\nimport { createPubSub } from './helpers';\n\n/**\n * Adds 3 event functions to the sdk,\n * onSessionTokenChange: Gets a callback and call it whenever there is a change in session token\n * onIsAuthenticatedChange: Gets a callback and call it whenever there is a change in authentication status\n * onUserChange: Gets a callback and call it whenever there is a change in current logged in user\n */\nexport const withNotifications =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0]) => {\n    const sessionExpirationPS = createPubSub<number | null>();\n    const sessionPS = createPubSub<string | null>();\n    const userPS = createPubSub<UserResponse | null>();\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      if (res?.status === 401) {\n        sessionPS.pub(null);\n        userPS.pub(null);\n        sessionExpirationPS.pub(null);\n      } else {\n        const userDetails = await getUserFromResponse(res);\n        if (userDetails) userPS.pub(userDetails);\n\n        const { sessionJwt, sessionExpiration } =\n          await getAuthInfoFromResponse(res);\n\n        if (sessionJwt) sessionPS.pub(sessionJwt);\n\n        if (sessionExpiration || sessionJwt) {\n          // We also publish the session expiration if there is a session jwt\n          // as a temporary fix for the issue where the session expiration is not\n          // being sent in the response in Flows (42 is a magic number)\n          sessionExpirationPS.pub(sessionExpiration || 42);\n        }\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    const wrapper: SdkFnWrapper<{}> =\n      (fn) =>\n      async (...args) => {\n        const resp = await fn(...args);\n\n        sessionPS.pub(null);\n        userPS.pub(null);\n        sessionExpirationPS.pub(null);\n\n        return resp;\n      };\n\n    const wrappedSdk = wrapWith(\n      sdk,\n      ['logout', 'logoutAll', 'oidc.logout'],\n      wrapper,\n    );\n\n    return Object.assign(wrappedSdk, {\n      onSessionTokenChange: sessionPS.sub,\n      onUserChange: userPS.sub,\n      onIsAuthenticatedChange: (cb: (isAuthenticated: boolean) => void) => {\n        // If and only if there is a session expiration, then the user is authenticated\n        return sessionExpirationPS.sub((exp) => {\n          cb(!!exp);\n        });\n      },\n    });\n  };\n", "/* eslint-disable import/exports-last */\nimport { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { IS_BROWSER } from '../../constants';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport { addHooks, getAuthInfoFromResponse } from '../helpers';\nimport {\n  beforeRequest,\n  clearTokens,\n  getRefreshToken,\n  getSessionToken,\n  persistTokens,\n  getIdToken,\n} from './helpers';\nimport { CookieConfig, PersistTokensOptions } from './types';\n\n/**\n * Persist authentication tokens in cookie/storage\n */\nexport const withPersistTokens =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  <A extends CookieConfig>({\n    persistTokens: isPersistTokens,\n    sessionTokenViaCookie,\n    storagePrefix,\n    ...config\n  }: Parameters<T>[0] & PersistTokensOptions<A>): A extends false\n    ? ReturnType<T>\n    : ReturnType<T> & {\n        getRefreshToken: () => string;\n        getSessionToken: () => string;\n        getIdToken: () => string;\n      } => {\n    if (!isPersistTokens || !IS_BROWSER) {\n      if (isPersistTokens) {\n        // Storing auth tokens in local storage and cookies are a client side only capabilities\n        // and will not be done when running in the server\n      }\n      return createSdk(config) as any;\n    }\n\n    const afterRequest: AfterRequestHook = async (req, res) => {\n      const isManagementApi = /^\\/v\\d+\\/mgmt\\//.test(req.path);\n\n      if (res?.status === 401) {\n        if (!isManagementApi) {\n          clearTokens(storagePrefix);\n        }\n      } else {\n        persistTokens(\n          await getAuthInfoFromResponse(res),\n          sessionTokenViaCookie,\n          storagePrefix,\n        );\n      }\n    };\n\n    const sdk = createSdk(\n      addHooks(config, {\n        beforeRequest: beforeRequest(storagePrefix),\n        afterRequest,\n      }),\n    );\n\n    const wrappedSdk = wrapWith(\n      sdk,\n      ['logout', 'logoutAll', 'oidc.logout'],\n      wrapper(storagePrefix),\n    );\n\n    const refreshToken = () => getRefreshToken(storagePrefix);\n    const sessionToken = () => getSessionToken(storagePrefix);\n    const idToken = () => getIdToken(storagePrefix);\n\n    return Object.assign(wrappedSdk, {\n      getRefreshToken: refreshToken,\n      getSessionToken: sessionToken,\n      getIdToken: idToken,\n    }) as any;\n  };\n\nconst wrapper =\n  (prefix?: string): SdkFnWrapper<{}> =>\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n\n    clearTokens(prefix);\n\n    return resp;\n  };\n\nexport default withPersistTokens;\n", "import { JWTResponse, SdkResponse, ResponseData } from '@descope/core-js-sdk';\nimport { IS_BROWSER } from '../constants';\nimport { CoreSdk, PasskeyOptions } from '../types';\n\ntype CreateWebauthn = typeof createWebAuthn;\n\nconst withCoreFns =\n  <I extends Parameters<CreateWebauthn>, O extends ReturnType<CreateWebauthn>>(\n    creator: (...args: I) => O,\n  ) =>\n  (...args: I) => {\n    const obj = creator(...args);\n\n    Object.assign(obj.signUp, args[0].webauthn.signUp);\n    Object.assign(obj.signIn, args[0].webauthn.signIn);\n    Object.assign(obj.signUpOrIn, args[0].webauthn.signUpOrIn);\n    Object.assign(obj.update, args[0].webauthn.update);\n\n    return obj as {\n      [K in keyof O]: K extends keyof I[0]['webauthn']\n        ? O[K] & I[0]['webauthn'][K]\n        : O[K];\n    };\n  };\n\n/** Constructs a higher level WebAuthn API that wraps the functions from code-js-sdk */\nconst createWebAuthn = (sdk: CoreSdk) => ({\n  async signUp(\n    identifier: string,\n    name: string,\n    passkeyOptions?: PasskeyOptions,\n  ) {\n    const startResponse = await sdk.webauthn.signUp.start(\n      identifier,\n      window.location.origin,\n      name,\n      passkeyOptions,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    const createResponse = await create(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.signUp.finish(\n      startResponse.data.transactionId,\n      createResponse,\n    );\n    return finishResponse;\n  },\n\n  async signIn(identifier: string, passkeyOptions?: PasskeyOptions) {\n    const startResponse = await sdk.webauthn.signIn.start(\n      identifier,\n      window.location.origin,\n      undefined,\n      undefined,\n      passkeyOptions,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    const getResponse = await get(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.signIn.finish(\n      startResponse.data.transactionId,\n      getResponse,\n    );\n    return finishResponse;\n  },\n\n  async signUpOrIn(identifier: string, passkeyOptions?: PasskeyOptions) {\n    const startResponse = await sdk.webauthn.signUpOrIn.start(\n      identifier,\n      window.location.origin,\n      passkeyOptions,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    if (startResponse.data?.create) {\n      const createResponse = await create(startResponse.data.options);\n      const finishResponse = await sdk.webauthn.signUp.finish(\n        startResponse.data.transactionId,\n        createResponse,\n      );\n      return finishResponse;\n    } else {\n      const getResponse = await get(startResponse.data.options);\n      const finishResponse = await sdk.webauthn.signIn.finish(\n        startResponse.data.transactionId,\n        getResponse,\n      );\n      return finishResponse;\n    }\n  },\n\n  async update(\n    identifier: string,\n    token?: string,\n    passkeyOptions?: PasskeyOptions,\n  ) {\n    const startResponse = await sdk.webauthn.update.start(\n      identifier,\n      window.location.origin,\n      token,\n      passkeyOptions,\n    );\n    if (!startResponse.ok) {\n      return startResponse as SdkResponse<ResponseData>;\n    }\n    const createResponse = await create(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.update.finish(\n      startResponse.data.transactionId,\n      createResponse,\n    );\n    return finishResponse;\n  },\n\n  /** Helper functions for working with WebAuthn browser APIs using JSON data */\n  helpers: {\n    /** Wraps the navigation.credentials.create call to translate JSON inputs and outputs */\n    create,\n    /** Wraps the navigation.credentials.get call to translate JSON inputs and outputs */\n    get,\n    /** Checks if the browser supports WebAuthn, and can optionally require in\n     * addition that the browser supports WebAuthn with built-in biometrics */\n    isSupported,\n    conditional,\n  },\n});\n\n// Helpers functions\n\nasync function create(options: string): Promise<string> {\n  const createOptions = decodeCreateOptions(options);\n  const createResponse = (await navigator.credentials.create(\n    createOptions,\n  )) as AttestationPublicKeyCredential;\n  return encodeCreateResponse(createResponse);\n}\n\nasync function get(options: string): Promise<string> {\n  const getOptions = decodeGetOptions(options);\n  const getResponse = (await navigator.credentials.get(\n    getOptions,\n  )) as AssertionPublicKeyCredential;\n  return encodeGetResponse(getResponse);\n}\n\n/**\n * This function should be used in passkeys autofill (conditional UI)\n * It handles the call to \"navigator.credentials.get\" and adds the required options\n * @param options webauthn start options\n * @param abort: AbortController instance\n * @returns encoded \"navigator.credentials.get\" response\n */\nasync function conditional(\n  options: string,\n  abort: AbortController,\n): Promise<string> {\n  const getOptions = decodeGetOptions(options);\n  getOptions.signal = abort.signal;\n  getOptions.mediation = 'conditional' as any;\n  const getResponse = (await navigator.credentials.get(\n    getOptions,\n  )) as AssertionPublicKeyCredential;\n  return encodeGetResponse(getResponse);\n}\n\n// eslint-disable-next-line import/exports-last\nexport async function isSupported(\n  requirePlatformAuthenticator: boolean = false,\n): Promise<boolean> {\n  if (!IS_BROWSER) {\n    return Promise.resolve(false);\n  }\n  const supported = !!(\n    window.PublicKeyCredential &&\n    navigator.credentials &&\n    navigator.credentials.create &&\n    navigator.credentials.get\n  );\n  if (\n    supported &&\n    requirePlatformAuthenticator &&\n    PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable\n  ) {\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n  }\n  return supported;\n}\n\n// Conversion of data structures for Create/Attestation/Register ceremony\n\ntype AttestationPublicKeyCredential = PublicKeyCredential & {\n  response: AuthenticatorAttestationResponse;\n};\n\nfunction decodeCreateOptions(value: string): CredentialCreationOptions {\n  const options = JSON.parse(value);\n  options.publicKey.challenge = decodeBase64Url(options.publicKey.challenge);\n  options.publicKey.user.id = decodeBase64Url(options.publicKey.user.id);\n  options.publicKey.excludeCredentials?.forEach((item: any) => {\n    item.id = decodeBase64Url(item.id);\n  });\n  return options;\n}\n\nfunction encodeCreateResponse(\n  credential: AttestationPublicKeyCredential,\n): string {\n  return JSON.stringify({\n    id: credential.id,\n    rawId: encodeBase64Url(credential.rawId),\n    type: credential.type,\n    response: {\n      attestationObject: encodeBase64Url(credential.response.attestationObject),\n      clientDataJSON: encodeBase64Url(credential.response.clientDataJSON),\n    },\n  });\n}\n\n// Conversion of data structures for Get/Assertion/Login ceremony\n\ntype AssertionPublicKeyCredential = PublicKeyCredential & {\n  response: AuthenticatorAssertionResponse;\n};\n\nfunction decodeGetOptions(value: string): CredentialRequestOptions {\n  const options = JSON.parse(value);\n  options.publicKey.challenge = decodeBase64Url(options.publicKey.challenge);\n  options.publicKey.allowCredentials?.forEach((item: any) => {\n    item.id = decodeBase64Url(item.id);\n  });\n  return options;\n}\n\nfunction encodeGetResponse(credential: AssertionPublicKeyCredential): string {\n  return JSON.stringify({\n    id: credential.id,\n    rawId: encodeBase64Url(credential.rawId),\n    type: credential.type,\n    response: {\n      authenticatorData: encodeBase64Url(credential.response.authenticatorData),\n      clientDataJSON: encodeBase64Url(credential.response.clientDataJSON),\n      signature: encodeBase64Url(credential.response.signature),\n      userHandle: credential.response.userHandle\n        ? encodeBase64Url(credential.response.userHandle)\n        : undefined,\n    },\n  });\n}\n\n// Conversion between ArrayBuffers and Base64Url strings\n\nfunction decodeBase64Url(value: string): ArrayBufferLike {\n  const base64 = value.replace(/_/g, '/').replace(/-/g, '+');\n  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;\n}\n\nfunction encodeBase64Url(value: ArrayBufferLike): string {\n  const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(value)));\n  return base64.replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '');\n}\n\n// Exports\nexport default withCoreFns(createWebAuthn);\n", "export const apiPaths = {\n  fedcm: {\n    config: '/fedcm/config',\n  },\n};\n", "import { JWTResponse, SdkResponse, LoginOptions } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport { IS_BROWSER } from '../constants';\nimport { apiPaths } from '../apiPaths';\n\n/**\n * Configuration for OneTap.\n */\ninterface OneTapConfig {\n  /** Whether to auto select. Optional. */\n  auto_select?: boolean;\n\n  /** Whether to cancel on tap outside. Optional. */\n  cancel_on_tap_outside?: boolean;\n\n  /** ID of the prompt parent. Optional. */\n  prompt_parent_id?: string;\n\n  /** Context. Optional. */\n  context?: 'signin' | 'signup' | 'use';\n\n  /** Callback function to handle the intermediate iframe close event. Optional. */\n  intermediate_iframe_close_callback?: () => void;\n\n  /** Whether to support ITP. Optional. */\n  itp_support?: boolean;\n\n  /** Login hint. Optional. */\n  login_hint?: string;\n\n  /** HD. Optional. */\n  hd?: string;\n\n  /** Whether to use FedCM for prompt. Optional. */\n  use_fedcm_for_prompt?: boolean;\n}\n\n/**\n * Response from the credential.\n */\ninterface CredentialResponse {\n  /** Credential. */\n  credential: string;\n\n  /** How the selection was made. */\n  select_by:\n    | 'auto'\n    | 'user'\n    | 'user_1tap'\n    | 'user_2tap'\n    | 'btn'\n    | 'btn_confirm'\n    | 'btn_add_session'\n    | 'btn_confirm_add_session';\n}\n\ninterface FedCMAssertionResponse {\n  token: string;\n  error: {\n    code: string;\n    url: string;\n  };\n}\n\ninterface IdentityProviderConfig {\n  configURL: string;\n  clientId: string;\n}\n\ntype IdentityCredentialRequestOptionsContext =\n  | 'signin'\n  | 'signup'\n  | 'use'\n  | 'continue';\n\ninterface IdentityProviderRequestOptions extends IdentityProviderConfig {\n  nonce?: string;\n  loginHint?: string;\n  domainHint?: string;\n}\n\ninterface IdentityCredentialRequestOptions {\n  providers: IdentityProviderRequestOptions[];\n  context?: IdentityCredentialRequestOptionsContext;\n}\n\ninterface FedCMCredentialRequestOptions {\n  identity?: IdentityCredentialRequestOptions;\n}\n\ntype OneTapInitialize = ({\n  client_id,\n  callback,\n  nonce,\n}: {\n  client_id: string;\n  callback: (res: CredentialResponse) => void;\n  nonce: string;\n} & OneTapConfig) => void;\n\ntype PromptNotification = {\n  isSkippedMoment: () => boolean;\n  isDismissedMoment: () => boolean;\n  getDismissedReason: () => string;\n  getSkippedReason: () => string;\n};\n\nconst generateNonce = () => {\n  if (window.crypto && window.crypto.getRandomValues) {\n    const array = new Uint8Array(16); // 16 bytes = 128 bits\n    window.crypto.getRandomValues(array);\n    return Array.from(array, (byte) => byte.toString(16).padStart(2, '0')).join(\n      '',\n    );\n  } else {\n    // Fallback (not cryptographically secure)\n    return Math.random().toString(36).substring(2);\n  }\n};\n\n/**\n * Constructs a higher level FedCM API that wraps the functions from code-js-sdk.\n * @param sdk The CoreSdk instance.\n * @returns The FedCM API.\n */\nconst createFedCM = (sdk: CoreSdk, projectId: string) => ({\n  onetap: {\n    requestExchangeCode(options: {\n      provider?: string;\n      oneTapConfig?: OneTapConfig;\n      loginOptions?: LoginOptions;\n      onSkipped?: (reason?: string) => void;\n      onDismissed?: (reason?: string) => void;\n      onFailed?: (error: Error) => void;\n      onCodeReceived: (code: string) => void;\n    }) {\n      performOneTap(sdk, options);\n    },\n\n    requestAuthentication(options?: {\n      provider?: string;\n      oneTapConfig?: OneTapConfig;\n      loginOptions?: LoginOptions;\n      onSkipped?: (reason?: string) => void;\n      onDismissed?: (reason?: string) => void;\n      onFailed?: (error: Error) => void;\n      onAuthenticated?: (response: JWTResponse) => void;\n    }) {\n      performOneTap(sdk, options);\n    },\n  },\n\n  /**\n   * @deprecated Call `onetap.requestAuthentication` instead.\n   */\n  async oneTap(\n    provider?: string,\n    oneTapConfig?: OneTapConfig,\n    loginOptions?: LoginOptions,\n    onSkipped?: (reason?: string) => void,\n    onDismissed?: (reason?: string) => void,\n  ) {\n    await performOneTapAsync(sdk, {\n      provider,\n      oneTapConfig,\n      loginOptions,\n      onSkipped,\n      onDismissed,\n    });\n  },\n\n  async launch(\n    context?: IdentityCredentialRequestOptionsContext,\n  ): Promise<SdkResponse<JWTResponse>> {\n    const configURL = sdk.httpClient.buildUrl(\n      projectId + apiPaths.fedcm.config,\n    );\n    const req: FedCMCredentialRequestOptions = {\n      identity: {\n        context: context || 'signin',\n        providers: [\n          {\n            configURL,\n            clientId: projectId,\n          },\n        ],\n      },\n    };\n    const res = await navigator.credentials?.get(req as any);\n    return sdk.refresh((res as any as FedCMAssertionResponse).token);\n  },\n\n  isSupported(): boolean {\n    return IS_BROWSER && 'IdentityCredential' in window;\n  },\n\n  async isLoggedIn(\n    context?: IdentityCredentialRequestOptionsContext,\n  ): Promise<boolean> {\n    const configURL = sdk.httpClient.buildUrl(\n      projectId + apiPaths.fedcm.config,\n    );\n    try {\n      const req: FedCMCredentialRequestOptions = {\n        identity: {\n          context: context || 'signin',\n          providers: [\n            {\n              configURL,\n              clientId: projectId,\n            },\n          ],\n        },\n      };\n      const res = await navigator.credentials?.get(req as any);\n      return !!res && !!(res as any as FedCMAssertionResponse).token;\n    } catch (e) {\n      // Any error likely indicates no active session.\n      return false;\n    }\n  },\n});\n\n// Helpers functions\nasync function getGoogleClient(): Promise<{\n  initialize: OneTapInitialize;\n  prompt: (cb: (notification: PromptNotification) => void) => void;\n}> {\n  return new Promise((resolve, reject) => {\n    if ((window as any).google) {\n      resolve((window as any).google.accounts.id);\n      return;\n    }\n\n    /* istanbul ignore next */\n    let googleScript = document.getElementById(\n      'google-gsi-client-script',\n    ) as HTMLScriptElement;\n\n    /* istanbul ignore next */\n    if (!googleScript) {\n      googleScript = document.createElement('script');\n      document.head.appendChild(googleScript);\n      googleScript.async = true;\n      googleScript.defer = true;\n      googleScript.id = 'google-gsi-client-script';\n      googleScript.src = 'https://accounts.google.com/gsi/client';\n    }\n\n    /* istanbul ignore next */\n    googleScript.onload = function () {\n      if ((window as any).google) {\n        resolve((window as any).google.accounts.id);\n      } else {\n        reject('Failed to load Google GSI client script - not loaded properly');\n      }\n    };\n    /* istanbul ignore next */\n    googleScript.onerror = function () {\n      reject('Failed to load Google GSI client script - failed to load');\n    };\n  });\n}\n\nasync function performOneTap(\n  sdk: CoreSdk,\n  options?: {\n    provider?: string;\n    oneTapConfig?: OneTapConfig;\n    loginOptions?: LoginOptions;\n    onSkipped?: (reason?: string) => void;\n    onDismissed?: (reason?: string) => void;\n    onFailed?: (error: Error) => void;\n    onCodeReceived?: (code: string) => void;\n    onAuthenticated?: (response: JWTResponse) => void;\n  },\n) {\n  try {\n    await performOneTapAsync(sdk, options);\n  } catch (e) {\n    options?.onFailed?.(e);\n  }\n}\n\nasync function performOneTapAsync(\n  sdk: CoreSdk,\n  options?: {\n    provider?: string;\n    oneTapConfig?: OneTapConfig;\n    loginOptions?: LoginOptions;\n    onSkipped?: (reason?: string) => void;\n    onDismissed?: (reason?: string) => void;\n    onCodeReceived?: (code: string) => void;\n    onAuthenticated?: (response: JWTResponse) => void;\n  },\n) {\n  const auth = await startOneTap(\n    sdk,\n    options.provider,\n    options.oneTapConfig,\n    options.onSkipped,\n    options.onDismissed,\n  );\n  if (!auth.credential) {\n    return null;\n  }\n  if (options?.onCodeReceived) {\n    const response = await sdk.oauth.verifyOneTapIDToken(\n      auth.provider,\n      auth.credential,\n      auth.nonce,\n      options?.loginOptions,\n    );\n    if (!response.ok || !response.data) {\n      throw new Error(\n        'Failed to verify OneTap client ID for provider ' + auth.provider,\n      );\n    }\n    options?.onCodeReceived?.(response.data.code);\n  } else {\n    const response = await sdk.oauth.exchangeOneTapIDToken(\n      auth.provider,\n      auth.credential,\n      auth.nonce,\n      options?.loginOptions,\n    );\n    if (!response.ok || !response.data) {\n      throw new Error(\n        'Failed to exchange OneTap client ID for provider ' + auth.provider,\n      );\n    }\n    options?.onAuthenticated?.(response.data);\n  }\n}\n\nasync function startOneTap(\n  sdk: CoreSdk,\n  provider: string = 'google',\n  oneTapConfig?: OneTapConfig,\n  onSkipped?: (reason?: string) => void,\n  onDismissed?: (reason?: string) => void,\n): Promise<{\n  provider: string;\n  nonce: string;\n  credential?: string;\n}> {\n  const nonce = generateNonce();\n  const googleClient = await getGoogleClient();\n\n  const clientIdRes = await sdk.oauth.getOneTapClientId(provider);\n  if (!clientIdRes.ok) {\n    throw new Error('Failed to get OneTap client ID for provider ' + provider);\n  }\n  const clientId = clientIdRes.data.clientId;\n\n  return new Promise((resolve) => {\n    const callback = (response?: CredentialResponse) => {\n      resolve({\n        provider,\n        nonce,\n        credential: response?.credential,\n      });\n    };\n\n    googleClient.initialize({\n      ...oneTapConfig,\n      itp_support: oneTapConfig?.itp_support ?? true,\n      use_fedcm_for_prompt: oneTapConfig?.use_fedcm_for_prompt ?? true,\n      client_id: clientId,\n      callback,\n      nonce,\n    });\n\n    googleClient.prompt((notification) => {\n      if (onDismissed && notification?.isDismissedMoment()) {\n        const reason = notification.getDismissedReason?.();\n        onDismissed?.(reason);\n        callback();\n        return;\n      }\n\n      if (onSkipped && notification?.isSkippedMoment()) {\n        const reason = notification.getSkippedReason?.();\n        onSkipped?.(reason);\n        callback();\n        return;\n      }\n    });\n  });\n}\n\nexport default createFedCM;\nexport type { OneTapConfig };\n", "import { CoreSdk, ReplaceParam } from '../types';\nimport { isSupported } from './webauthn';\n\ntype CoreSdkFlowStartArgs = Parameters<CoreSdk['flow']['start']>;\ntype Options = Pick<\n  CoreSdkFlowStartArgs[1],\n  | 'tenant'\n  | 'redirectUrl'\n  | 'redirectAuth'\n  | 'oidcIdpStateId'\n  | 'samlIdpStateId'\n  | 'samlIdpUsername'\n  | 'ssoAppId'\n  | 'thirdPartyAppId'\n  | 'oidcLoginHint'\n  | 'preview'\n  | 'abTestingKey'\n  | 'client'\n  | 'locale'\n  | 'oidcPrompt'\n  | 'oidcErrorRedirectUri'\n  | 'oidcResource'\n  | 'nativeOptions'\n  | 'thirdPartyAppStateId'\n  | 'applicationScopes'\n  | 'outboundAppId'\n  | 'outboundAppScopes'\n> & {\n  lastAuth?: Omit<CoreSdkFlowStartArgs[1]['lastAuth'], 'loginId' | 'name'>;\n};\n\nconst START_OPTIONS_VERSION_PREFER_START_REDIRECT_URL = 1;\n\nexport default (coreSdk: CoreSdk) => ({\n  ...coreSdk.flow,\n  // wrap start fn and adds more data to the start options\n  start: async (...args: ReplaceParam<CoreSdkFlowStartArgs, '1', Options>) => {\n    const webAuthnSupport = await isSupported();\n    const decoratedOptions = {\n      location: window.location.href,\n      ...args[1],\n      deviceInfo: {\n        webAuthnSupport,\n      },\n      startOptionsVersion: START_OPTIONS_VERSION_PREFER_START_REDIRECT_URL,\n    };\n\n    args[1] = decoratedOptions;\n\n    return coreSdk.flow.start(...args);\n  },\n});\n", "export const hasOidcParamsInUrl = () => {\n  return (\n    window.location.search.includes('code') &&\n    window.location.search.includes('state')\n  );\n};\n\nexport const removeOidcParamFromUrl = () => {\n  // Retrieve the current URL from the browser's address bar\n  const currentUrl = new URL(window.location.href);\n\n  // Remove the 'code' and 'state' query parameters if it exist\n  currentUrl.searchParams.delete('code');\n  currentUrl.searchParams.delete('state');\n\n  // Update the URL displayed in the browser without reloading the page\n  window.history.replaceState({}, document.title, currentUrl.toString());\n};\n", "import { RequestConfig, SdkResponse, URLResponse } from '@descope/core-js-sdk';\nimport type {\n  CreateSigninRequestArgs,\n  CreateSignoutRequestArgs,\n  OidcClient,\n  OidcClientSettings,\n  SigninResponse,\n  WebStorageStateStore,\n} from 'oidc-client-ts';\nimport {\n  OIDC_CLIENT_TS_DESCOPE_CDN_URL,\n  OIDC_CLIENT_TS_JSDELIVR_CDN_URL,\n} from '../../constants';\nimport { getIdToken } from '../../enhancers/withPersistTokens/helpers';\nimport { CoreSdk, OidcConfig, OidcConfigOptions } from '../../types';\nimport { hasOidcParamsInUrl, removeOidcParamFromUrl } from './helpers';\n\ntype OidcModule = {\n  OidcClient: typeof OidcClient;\n  WebStorageStateStore: typeof WebStorageStateStore;\n};\n\ntype SignInResponseStorage = Pick<\n  SigninResponse,\n  'id_token' | 'session_state' | 'profile'\n>;\n\nlet scriptLoadingPromise: Promise<OidcModule>;\n\n/* istanbul ignore next */\nconst simpleHash = (input: string): string => {\n  let hash = 0;\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n\n  return Math.abs(hash).toString(16); // Return hash as a positive hexadecimal string\n};\n\nconst loadScriptWithFallback = (\n  urls: string[],\n  getEntry: () => OidcModule,\n): Promise<OidcModule> => {\n  /* istanbul ignore next */\n  return new Promise((resolve, reject) => {\n    if (!urls.length)\n      return reject(new Error('No URLs provided to loadScriptWithFallback'));\n\n    const entry = getEntry();\n    if (entry) return resolve(entry);\n\n    const url = urls.shift();\n\n    const scriptEle = document.createElement('script');\n    scriptEle.src = url;\n    scriptEle.id = simpleHash(url);\n    scriptEle.onload = () => {\n      const entry = getEntry();\n      if (entry) return resolve(entry);\n      throw new Error('Could not get entry after loading script from URL');\n    };\n    /* istanbul ignore next */\n    scriptEle.addEventListener('error', () => {\n      loadScriptWithFallback(urls, getEntry);\n      scriptEle.setAttribute('data-error', 'true');\n    });\n    document.body.appendChild(scriptEle);\n  });\n};\n\nconst loadOIDCModule = async (): Promise<OidcModule> => {\n  /* istanbul ignore next */\n  try {\n    return require('oidc-client-ts');\n  } catch (e) {\n    return loadScriptWithFallback(\n      [OIDC_CLIENT_TS_DESCOPE_CDN_URL, OIDC_CLIENT_TS_JSDELIVR_CDN_URL],\n      () => window['oidc'],\n    );\n  }\n};\n\nfunction oidcSignInResToStorage(\n  signInRes: SigninResponse,\n): SignInResponseStorage {\n  return {\n    id_token: signInRes.id_token,\n    session_state: signInRes.session_state,\n    profile: signInRes.profile,\n  };\n}\n\nconst getUserFromStorage = (\n  stateUserKey: string,\n): SignInResponseStorage | null => {\n  const user = window.localStorage.getItem(stateUserKey);\n  return user ? JSON.parse(user) : null;\n};\n\nconst getOidcClient = async (\n  sdk: CoreSdk,\n  projectId: string,\n  oidcConfig?: OidcConfigOptions,\n) => {\n  if (!scriptLoadingPromise) {\n    scriptLoadingPromise = loadOIDCModule();\n  }\n  const { OidcClient, WebStorageStateStore } = await scriptLoadingPromise;\n\n  if (!OidcClient) {\n    throw new Error(\n      'oidc-client-ts is not installed. Please install it by running `npm install oidc-client-ts`',\n    );\n  }\n\n  const clientId = projectId;\n  const redirectUri = oidcConfig?.redirectUri || window.location.href;\n  const scope =\n    oidcConfig?.scope ||\n    'openid email roles descope.custom_claims offline_access';\n  const stateUserKey = `${clientId}_user`;\n\n  let authority = sdk.httpClient.buildUrl(projectId);\n  if (oidcConfig?.applicationId) {\n    // append the applicationId to the authority\n    authority = `${authority}/${oidcConfig.applicationId}`;\n  }\n\n  const settings: OidcClientSettings = {\n    authority,\n    client_id: projectId,\n    redirect_uri: redirectUri,\n    response_type: 'code',\n    scope,\n    stateStore: new WebStorageStateStore({\n      store: window.localStorage,\n      prefix: clientId,\n    }),\n    loadUserInfo: true,\n    fetchRequestCredentials: 'same-origin',\n  };\n\n  if (oidcConfig?.redirectUri) {\n    settings.redirect_uri = oidcConfig.redirectUri;\n  }\n  if (oidcConfig?.scope) {\n    settings.scope = oidcConfig.scope;\n  }\n  return {\n    client: new OidcClient(settings),\n    stateUserKey,\n  };\n};\n\nconst createOidc = (\n  sdk: CoreSdk,\n  projectId: string,\n  oidcConfig?: OidcConfig,\n) => {\n  const getCachedClient = async (): Promise<{\n    client: OidcClient;\n    stateUserKey: string;\n  }> => {\n    let client, stateUserKey;\n    if (!client || !stateUserKey) {\n      ({ client, stateUserKey } = await getOidcClient(\n        sdk,\n        projectId,\n        oidcConfig as OidcConfigOptions,\n      ));\n    }\n    return { client, stateUserKey };\n  };\n\n  // Start the login process by creating a signin request\n  // And redirecting the user to the returned URL\n  const loginWithRedirect = async (\n    arg: CreateSigninRequestArgs = {},\n    disableNavigation: boolean = false,\n  ): Promise<SdkResponse<URLResponse>> => {\n    const { client } = await getCachedClient();\n    const res = await client.createSigninRequest(arg);\n    const { url } = res;\n    if (!disableNavigation) {\n      window.location.href = url;\n    }\n    return { ok: true, data: res };\n  };\n\n  // Finish the login process by processing the signin response\n  // This function should be called after the user is redirected from the OIDC IdP\n  const finishLogin = async (url: string = ''): Promise<any> => {\n    const { client, stateUserKey } = await getCachedClient();\n    const res = await client.processSigninResponse(url || window.location.href);\n\n    // In order to make sure all the after-hooks are running with the success response\n    // we are generating a fake response with the success data and calling the http client after hook fn with it\n    await sdk.httpClient.hooks?.afterRequest(\n      {} as any,\n      new Response(JSON.stringify(res)),\n    );\n\n    window.localStorage.setItem(\n      stateUserKey,\n      JSON.stringify(oidcSignInResToStorage(res)),\n    );\n    // remove the code from the URL\n    removeOidcParamFromUrl();\n\n    return res;\n  };\n\n  // Finish the login process if the OIDC params are in the URL, if not, do nothing\n  // This function should be called after the user is redirected\n  // Note: high level SDKs may call this function to check if the user is in the middle of the login process\n  const finishLoginIfNeed = async (url: string = ''): Promise<any> => {\n    if (hasOidcParamsInUrl()) {\n      return await finishLogin(url);\n    }\n  };\n\n  // Start the logout process by creating a signout request\n  // And redirecting the user to the returned URL\n  const logout = async (\n    arg?: CreateSignoutRequestArgs,\n    disableNavigation: boolean = false,\n  ): Promise<any> => {\n    const { client, stateUserKey } = await getCachedClient();\n    if (!arg) {\n      arg = {};\n    }\n\n    // if id_token_hint is not provided, we will use the one from the storage\n    arg.id_token_hint = arg.id_token_hint || getIdToken();\n    arg.post_logout_redirect_uri =\n      arg.post_logout_redirect_uri || window.location.href;\n\n    const res = await client.createSignoutRequest(arg);\n    const { url } = res;\n    window.localStorage.removeItem(stateUserKey);\n    if (!disableNavigation) {\n      window.location.replace(url);\n    }\n    return res;\n  };\n\n  // Refresh the access token using the refresh token\n  const refreshToken = async (refreshToken: string) => {\n    const { client, stateUserKey } = await getCachedClient();\n\n    const user = getUserFromStorage(stateUserKey);\n    if (!user) {\n      throw new Error('User not found in storage to refresh token');\n    }\n\n    let refresh_token = refreshToken;\n    if (!refresh_token) {\n      // if refresh token is not provided, we will use the one from the hooks\n      const config = {} as RequestConfig;\n      sdk.httpClient.hooks.beforeRequest(config);\n      refresh_token = config.token;\n    }\n    const res = await client.useRefreshToken({\n      state: {\n        refresh_token,\n        session_state: user.session_state,\n        profile: user.profile,\n      },\n    });\n\n    // In order to make sure all the after-hooks are running with the success response\n    // we are generating a fake response with the success data and calling the http client after hook fn with it\n    await sdk.httpClient.hooks?.afterRequest(\n      {} as any,\n      new Response(JSON.stringify(res)),\n    );\n    return res;\n  };\n\n  return {\n    loginWithRedirect,\n    finishLogin,\n    finishLoginIfNeed,\n    refreshToken,\n    logout,\n  };\n};\n\nexport default createOidc;\nexport type { OidcConfig };\n", "import { compose } from './enhancers/helpers';\nimport { withAnalytics } from './enhancers/withAnalytics';\nimport { withAutoRefresh } from './enhancers/withAutoRefresh';\nimport { withFingerprint } from './enhancers/withFingerprint';\nimport { withFlowNonce } from './enhancers/withFlowNonce';\nimport { withLastLoggedInUser } from './enhancers/withLastLoggedInUser';\nimport { withNotifications } from './enhancers/withNotifications';\nimport withPersistTokens from './enhancers/withPersistTokens';\nimport createSdk from './sdk';\n\nconst decoratedCreateSdk = compose(\n  withFingerprint,\n  withAutoRefresh,\n  withAnalytics,\n  withNotifications,\n  withFlowNonce,\n  withLastLoggedInUser, // must be one before last due to TS types\n  withPersistTokens, // must be last due to TS known limitation https://github.com/microsoft/TypeScript/issues/30727\n)(createSdk);\n\nexport type { UserResponse, OidcConfig } from './types';\n\n// Note: make sure to update ./test/umd.test.ts when adding new constants\nexport {\n  REFRESH_TOKEN_KEY,\n  SESSION_TOKEN_KEY,\n} from './enhancers/withPersistTokens/constants';\n\nexport {\n  ensureFingerprintIds,\n  clearFingerprintData,\n} from './enhancers/withFingerprint/helpers';\n\nexport { hasOidcParamsInUrl } from './sdk/oidc/helpers';\n\nexport type { OneTapConfig } from './sdk/fedcm';\nexport type { CookieConfig } from './enhancers/withPersistTokens/types';\nexport type { FlowNonceOptions } from './enhancers/withFlowNonce/types';\nexport default decoratedCreateSdk;\n", "type Fn = (arg: any) => any;\n\nexport function compose<Input, A1>(\n  fn1: (input: Input) => A1,\n): (input: Input) => A1;\n\nexport function compose<Input, A1, A2>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n): (input: Input) => A2;\n\nexport function compose<Input, A1, A2, A3>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n): (input: Input) => A3;\n\nexport function compose<Input, A1, A2, A3, A4>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n): (input: Input) => A4;\n\nexport function compose<Input, A1, A2, A3, A4, A5>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n): (input: Input) => A5;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n): (input: Input) => A6;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n): (input: Input) => A7;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n): (input: Input) => A8;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8, A9>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n  fn9: (input: A8) => A9,\n): (input: Input) => A9;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n  fn9: (input: A8) => A9,\n  fn10: (input: A9) => A10,\n): (input: Input) => A10;\n\n/**\n * Currently there is no way to create a compose function in Typescript without using overloading\n * This function currently support up to 10 wrappers\n * If needed you can add more by duplicating the type and add more parameters\n */\n\nexport function compose(...args: Fn[]) {\n  return (data: any) => args.reduce((acc, elem) => elem(acc), data) as any;\n}\n", "import { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport { addHooks, getAuthInfoFromResponse, isDescopeBridge } from '../helpers';\nimport {\n  createTimerFunctions,\n  getTokenExpiration,\n  getAutoRefreshTimeout,\n} from './helpers';\nimport { AutoRefreshOptions } from './types';\nimport logger from '../helpers/logger';\nimport { IS_BROWSER, REFRESH_THRESHOLD } from '../../constants';\nimport { getRefreshToken } from '../withPersistTokens/helpers';\n\n/**\n * Automatically refresh the session token before it expires\n * It uses the the refresh token that is extracted from API response to do that\n */\nexport const withAutoRefresh =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({ autoRefresh, ...config }: Parameters<T>[0] & AutoRefreshOptions) => {\n    if (!autoRefresh || isDescopeBridge()) return createSdk(config);\n\n    // if we hold a single timer id, there might be a case where we override it before canceling the timer, this might cause many calls to refresh\n    // in order to prevent it, we hold a list of timers and cancel all of them when a new timer is set, which means we should have one active timer only at a time\n    const { clearAllTimers, setTimer } = createTimerFunctions();\n\n    // we need to hold the expiration time and the refresh token in order to refresh the session\n    // when the user comes back to the tab or from background/lock screen/etc.\n    let sessionExpirationDate: Date;\n    let refreshToken: string;\n    if (IS_BROWSER) {\n      document.addEventListener('visibilitychange', () => {\n        // tab becomes visible and the session is expired, do a refresh\n        if (\n          document.visibilityState === 'visible' &&\n          sessionExpirationDate &&\n          new Date() > sessionExpirationDate\n        ) {\n          logger.debug('Expiration time passed, refreshing session');\n          // We prefer the persisted refresh token over the one from the response\n          // for a case that the token was refreshed from another tab, this mostly relevant\n          // when the project uses token rotation\n          sdk.refresh(getRefreshToken() || refreshToken);\n        }\n      });\n    }\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      const { sessionJwt, refreshJwt, sessionExpiration } =\n        await getAuthInfoFromResponse(res);\n\n      // if we got 401 we want to cancel all timers\n      if (res?.status === 401) {\n        logger.debug('Received 401, canceling all timers');\n        clearAllTimers();\n      } else if (sessionJwt || sessionExpiration) {\n        sessionExpirationDate = getTokenExpiration(\n          sessionJwt,\n          sessionExpiration,\n        );\n        if (!sessionExpirationDate) {\n          logger.debug('Could not extract expiration time from session token');\n          return;\n        }\n        refreshToken = refreshJwt;\n        const timeout = getAutoRefreshTimeout(sessionExpirationDate);\n        clearAllTimers();\n\n        if (timeout <= REFRESH_THRESHOLD) {\n          /*\n            When receiving a session with very short expiration - it means that the refresh token is also close to expiration\n            This happens because session expiration cannot be more than the refresh expiration\n            In this case - the user is going to be logged out soon, so we don't want to set a refresh timer\n          */\n          logger.debug(\n            'Session is too close to expiration, not setting refresh timer',\n          );\n          return;\n        }\n\n        const refreshTimeStr = new Date(\n          Date.now() + timeout,\n        ).toLocaleTimeString('en-US', { hour12: false });\n        logger.debug(\n          `Setting refresh timer for ${refreshTimeStr}. (${timeout}ms)`,\n        );\n\n        setTimer(() => {\n          logger.debug('Refreshing session due to timer');\n          // We prefer the persisted refresh token over the one from the response\n          // for a case that the token was refreshed from another tab, this mostly relevant\n          // when the project uses token rotation\n          sdk.refresh(getRefreshToken() || refreshJwt);\n        }, timeout);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    const wrapper: SdkFnWrapper<{}> =\n      (fn) =>\n      async (...args) => {\n        const resp = await fn(...args);\n        logger.debug('Clearing all timers');\n        clearAllTimers();\n\n        return resp;\n      };\n\n    return wrapWith(sdk, ['logout', 'logoutAll', 'oidc.logout'], wrapper);\n  };\n", "import { CreateWebSdk } from '../sdk';\nimport { BeforeRequestHook } from '../types';\nimport { addHooks } from './helpers';\n\n// this is replaced in build time\ndeclare const BUILD_VERSION: string;\n/**\n * Adds analytics headers to requests\n */\nexport const withAnalytics =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0]) =>\n    createSdk({\n      ...config,\n      baseHeaders: {\n        'x-descope-sdk-name': 'web-js',\n        'x-descope-sdk-version': BUILD_VERSION,\n        ...config.baseHeaders,\n      },\n    });\n", "import { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook, BeforeRequestHook } from '../../types';\nimport { addHooks } from '../helpers';\nimport {\n  FLOW_NEXT_PATH,\n  FLOW_NONCE_HEADER,\n  FLOW_NONCE_PREFIX,\n  FLOW_START_PATH,\n} from './constants';\nimport {\n  cleanupExpiredNonces,\n  extractFlowNonce,\n  getExecutionIdFromRequest,\n  getFlowNonce,\n  setFlowNonce,\n} from './helpers';\nimport { FlowNonceOptions } from './types';\n\n/**\n * Adds flow nonce handling to the SDK\n */\nexport const withFlowNonce =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0] & FlowNonceOptions): ReturnType<T> => {\n    const {\n      enableFlowNonce = true,\n      nonceStoragePrefix = FLOW_NONCE_PREFIX,\n      ...sdkConfig\n    } = config;\n\n    if (!enableFlowNonce) {\n      return createSdk(sdkConfig) as ReturnType<T>;\n    }\n\n    cleanupExpiredNonces(nonceStoragePrefix);\n\n    const afterRequest: AfterRequestHook = async (req, res) => {\n      if (req.path !== FLOW_START_PATH && req.path !== FLOW_NEXT_PATH) {\n        return;\n      }\n      const { nonce, executionId } = await extractFlowNonce(req, res);\n\n      if (nonce && executionId) {\n        const isStart = req.path === FLOW_START_PATH;\n        setFlowNonce(executionId, nonce, isStart, nonceStoragePrefix);\n      }\n    };\n\n    const beforeRequest: BeforeRequestHook = (req) => {\n      if (req.path === FLOW_NEXT_PATH) {\n        const executionId = getExecutionIdFromRequest(req);\n\n        if (executionId) {\n          const nonce = getFlowNonce(executionId, nonceStoragePrefix);\n          if (nonce) {\n            req.headers = req.headers || {};\n            req.headers[FLOW_NONCE_HEADER] = nonce;\n          }\n        }\n      }\n      return req;\n    };\n\n    return createSdk(\n      addHooks(sdkConfig, { afterRequest, beforeRequest }),\n    ) as ReturnType<T>;\n  };\n\nexport * from './helpers';\nexport * from './types';\nexport * from './constants';\n", "import createCoreSdk, { SdkResponse } from '@descope/core-js-sdk';\nimport createWebAuthn from './webauthn';\nimport createFedCM from './fedcm';\nimport withFlow from './flow';\nimport {\n  getSessionToken,\n  getRefreshToken,\n} from '../enhancers/withPersistTokens/helpers';\nimport createOidc from './oidc';\nimport { CoreSdk, WebSdkConfig } from '../types';\nimport { OIDC_LOGOUT_ERROR_CODE, OIDC_REFRESH_ERROR_CODE } from '../constants';\nimport logger from '../enhancers/helpers/logger';\n\nconst createSdk = (config: WebSdkConfig) => {\n  const coreSdk = createCoreSdk(config);\n\n  const oidc = createOidc(coreSdk, config.projectId, config.oidcConfig);\n\n  return {\n    ...coreSdk,\n    refresh: async (\n      token?: string,\n      tryRefresh?: boolean,\n    ): ReturnType<CoreSdk['refresh']> => {\n      if (config.oidcConfig) {\n        try {\n          await oidc.refreshToken(token);\n          return Promise.resolve({ ok: true });\n        } catch (error) {\n          return Promise.resolve({\n            ok: false,\n            error: {\n              errorCode: OIDC_REFRESH_ERROR_CODE,\n              errorDescription: error.toString(),\n            },\n          });\n        }\n      }\n      // Descope use this query param to monitor if refresh is made\n      // When the user is already logged in in the past or not (We want to optimize that in the future)\n      const currentSessionToken = getSessionToken();\n      const currentRefreshToken = getRefreshToken();\n\n      let externalToken = '';\n      if (config.getExternalToken) {\n        try {\n          externalToken = await config.getExternalToken?.();\n        } catch (error) {\n          logger.debug('Error getting external token while refreshing', error);\n          // continue without external token\n        }\n      }\n\n      return coreSdk.refresh(\n        token,\n        {\n          dcs: currentSessionToken ? 't' : 'f',\n          dcr: currentRefreshToken ? 't' : 'f',\n        },\n        externalToken,\n        tryRefresh,\n      );\n    },\n    // Call the logout function according to the oidcConfig\n    // And return the response in the same format\n    logout: async (token?: string): Promise<SdkResponse<never>> => {\n      if (config.oidcConfig) {\n        // logout is made with id_token_hint\n        try {\n          await oidc.logout({ id_token_hint: token });\n          return Promise.resolve({ ok: true });\n        } catch (error) {\n          return Promise.resolve({\n            ok: false,\n            error: {\n              errorCode: OIDC_LOGOUT_ERROR_CODE,\n              errorDescription: error.toString(),\n            },\n          });\n        }\n      }\n      return coreSdk.logout(token);\n    },\n    flow: withFlow(coreSdk),\n    webauthn: createWebAuthn(coreSdk),\n    fedcm: createFedCM(coreSdk, config.projectId),\n    oidc,\n  };\n};\n\nexport default createSdk;\n\nexport type CreateWebSdk = typeof createSdk;\nexport type WebSdk = ReturnType<CreateWebSdk>;\n"],
  "mappings": "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",
  "names": ["m", "p", "apiPaths", "accessKey", "exchange", "otp", "verify", "signIn", "signUp", "update", "email", "phone", "signUpOrIn", "magicLink", "enchantedLink", "session", "oauth", "start", "startNative", "finishNative", "oneTap", "getOneTapClientId", "exchangeOneTapIDToken", "verifyOneTapIDToken", "outbound", "connect", "saml", "totp", "notp", "webauthn", "finish", "password", "sendReset", "replace", "policy", "refresh", "tryRefresh", "selectTenant", "logout", "logoutAll", "me", "myTenants", "history", "flow", "next", "BASE_URL_REGION_PLACEHOLDER", "DEFAULT_BASE_API_URL", "MIN_POLLING_INTERVAL_MS", "MAX_POLLING_TIMEOUT_MS", "DESCOPE_CURRENT_TENANT_CLAIM", "httpLogBuilder", "msg", "headers", "headersObj", "entries", "Object", "fromEntries", "Headers", "JSON", "stringify", "this", "body", "Body", "url", "Url", "toString", "method", "Method", "title", "Title", "status", "Status", "retries", "Retries", "build", "keys", "flatMap", "key", "join", "retryStatusCodes", "fetchWrapper", "fetch", "async", "args", "resp", "includes", "respText", "text", "Promise", "resolve", "json", "parse", "clone", "createFetchLogger", "logger", "receivedFetch", "baseFetch", "warn", "Error", "log", "ok", "respBody", "statusText", "sessionId", "getClientSessionId", "currentDate", "Date", "utcString", "getUTCFullYear", "getUTCMonth", "padStart", "getUTCDate", "getUTCHours", "getUTCMinutes", "getUTCSeconds", "getUTCMilliseconds", "randomSuffix", "Math", "floor", "random", "HTTPMethods", "urlBuilder", "path", "baseUrl", "queryParams", "projectId", "region", "slice", "forEach", "index", "encodeURIComponent", "length", "mergeHeaders", "sources", "reduce", "acc", "source", "Array", "isArray", "from", "value", "jsonHeaders", "createAuthorizationHeader", "token", "bearer", "Authorization", "createDescopeHeaders", "refreshCookieName", "res", "isJson", "e", "createHttpClient$1", "createHttpClient", "config", "assign", "hooks", "beforeRequest", "conf", "beforeRequestHooks", "concat", "_a", "fn", "afterRequest", "req", "afterRequestHooks", "allSettled", "map", "result", "error", "reason", "transformResponse", "recBaseUrl", "baseConfig", "cookiePolicy", "fetchWithLogger", "sendRequest", "requestConfig", "serializedBody", "requestInit", "baseHeaders", "credentials", "cookies", "o", "get", "split", "cookie", "trim", "mutableResponse", "post", "patch", "put", "delete", "buildUrl", "HttpStatusCodes", "TOO_MANY_REQUESTS", "getJwtAuthorizationItems", "tenant", "claim", "claims", "parseJwt", "tenants", "items", "jwtDecode", "isJwtExpired", "exp", "getTime", "getTenants", "getJwtPermissions", "getJwtRoles", "pathJoin", "response", "transform", "ret", "code", "data", "retryAfter", "Number", "parseInt", "n", "getCurrentTenant", "createValidator", "rule", "defaultMsg", "val", "createOrValidator", "validators", "errors", "filter", "validator", "createValidation", "validate", "errMsg", "regexMatch", "regex", "test", "validateEmail", "validatePhone", "validatePathValue", "rules", "object", "pathName", "defaultValue", "parts", "String", "m", "i", "v", "isEmail", "isPhone", "isNotEmpty", "min", "isString", "isBoolean", "isUndefined", "isStringOrUndefined", "isArrayOrBool", "withValidations", "argsRules", "rulesArr", "string", "fieldName", "isStringOrUndefinedValidator", "stringNonEmpty", "stringEmail", "stringPhone", "withExchangeValidations", "withAccessKeys", "httpClient", "loginOptions", "wrapWith", "obj", "paths", "wrapper", "sections", "section", "shift", "currentRef", "origFn", "normalizeWaitForSessionConfig", "pollingIntervalMs", "timeoutMs", "max", "DeliveryPhone", "DeliveryEmail", "DeliveryMethods", "FlowStatus", "loginIdValidations", "withVerifyValidations", "withSignValidations", "withWaitForSessionValidations", "withUpdateEmailValidations", "withEnchantedLink", "loginId", "URI", "signUpOptions", "user", "waitForSession", "pendingRef", "timeout", "interval", "setInterval", "clearInterval", "clearTimeout", "setTimeout", "errorDescription", "errorCode", "updateOptions", "withStartValidations", "withNextValidations", "withFlow", "flowId", "options", "conditionInteractionId", "interactionId", "componentsVersion", "flowVersions", "input", "executionId", "stepId", "version", "withUpdatePhoneValidations", "deliveryMethods", "d", "voice", "withMagicLink", "delivery", "OAuthProviders", "withOauth", "provider", "redirectUrl", "loginHint", "redirectURL", "implicit", "stateId", "idToken", "nonce", "appIdValidation", "withConnectValidations", "withOutbound", "appId", "tenantId", "tenantLevel", "withOtp", "withSaml", "tenantIdOrEmail", "ssoId", "forceAuthn", "withSignUpValidations", "withUpdateValidations", "withTotp", "loginIdValidation", "newPasswordValidation", "withSendResetValidations", "withUpdateValidation", "withReplaceValidation", "withPassword", "templateOptions", "newPassword", "oldPassword", "loginIdStringValidations", "loginIdNonEmptyValidations", "originValidations", "withSignUpStartValidations", "withSignUpOrInStartValidations", "withSignInStartValidations", "withUpdateStartValidations", "withFinishValidations", "withWebauthn", "origin", "name", "passkeyOptions", "transactionId", "withNotp", "withJwtValidations", "withOptionalTokenValidations", "createSdk", "t", "externalToken", "i", "converter", "r", "t", "e", "o", "n", "i", "a", "u", "R", "f", "l", "E", "t", "n", "r", "d", "p", "v", "_", "O", "h", "I", "U", "b", "C", "M", "t", "n", "r", "o", "i", "a", "u", "R", "c", "s", "E", "f", "l", "d", "p", "v", "e", "K", "B", "F", "I", "V", "k", "getExpirationFromToken", "token", "jwtDecode", "exp", "e", "oidcRefreshTokenExpiration", "response", "refresh_expire_in", "refresh_token", "Math", "floor", "Date", "now", "oidcAccessTokenExpiration", "expires_in", "expires_at", "access_token", "addHooks", "config", "hooks", "reduce", "acc", "key", "concat", "_a", "getAuthInfoFromResponse", "async", "res", "ok", "body", "clone", "json", "id_token", "rest", "__rest", "Object", "assign", "sessionJwt", "idToken", "refreshJwt", "sessionExpiration", "cookieExpiration", "authInfo", "getUserFromResponse", "user", "hasOwnProperty", "isLocalStorage", "localStorage", "setLocalStorage", "value", "setItem", "getLocalStorage", "getItem", "removeLocalStorage", "removeItem", "logger", "args", "console", "debug", "OIDC_CLIENT_TS_VERSION", "IS_BROWSER", "window", "MAX_TIMEOUT", "pow", "OIDC_CLIENT_TS_DESCOPE_CDN_URL", "OIDC_CLIENT_TS_JSDELIVR_CDN_URL", "getAutoRefreshTimeout", "timeout", "date", "getTime", "SESSION_TOKEN_KEY", "REFRESH_TOKEN_KEY", "ID_TOKEN_KEY", "setJwtTokenCookie", "name", "cookieDomain", "cookiePath", "cookieSameSite", "cookieSecure", "expires", "domainMatches", "currentDomainParts", "location", "hostname", "split", "cookieDomainParts", "slice", "length", "join", "Cookies", "set", "path", "domain", "sameSite", "secure", "getRefreshToken", "prefix", "getSessionToken", "get", "getIdToken", "clearTokens", "remove", "FP_EP_URL", "VISITOR_SESSION_ID_PARAM", "VISITOR_REQUEST_ID_PARAM", "FP_STORAGE_KEY", "getFPFromStorage", "returnExpired", "itemStr", "item", "JSON", "parse", "expiry", "ensureFingerprintIds", "fpKey", "baseUrl", "sessionId", "toString", "random", "substring", "endpointUrl", "URL", "pathname", "patterUrl", "scriptUrlPattern", "agentP", "load", "apiKey", "endpoint", "defaultEndpoint", "defaultScriptUrlPattern", "agent", "requestId", "linkedId", "fpData", "stringify", "ex", "warn", "clearFingerprintData", "beforeRequest", "data", "FLOW_NONCE_PREFIX", "FLOW_NONCE_HEADER", "FLOW_START_PATH", "FLOW_NEXT_PATH", "getNonceKeyForExecution", "executionId", "removeFlowNonce", "error", "extractExecId", "exec", "getExecutionIdFromRequest", "req", "LOCAL_STORAGE_LAST_USER_LOGIN_ID", "LOCAL_STORAGE_LAST_USER_DISPLAY_NAME", "getLastUserLoginId", "getLastUserDisplayName", "startWrapper", "fn", "options", "loginId", "displayName", "lastAuth", "logoutWrapper", "keepOnLogout", "resp", "createPubSub", "cbs", "pub", "forEach", "cb", "sub", "idx", "push", "splice", "wrapper", "create", "createOptions", "publicKey", "challenge", "decodeBase64Url", "id", "excludeCredentials", "createResponse", "navigator", "credentials", "credential", "rawId", "encodeBase64Url", "type", "attestationObject", "clientDataJSON", "getOptions", "decodeGetOptions", "encodeGetResponse", "conditional", "abort", "signal", "mediation", "isSupported", "requirePlatformAuthenticator", "Promise", "resolve", "supported", "PublicKeyCredential", "isUserVerifyingPlatformAuthenticatorAvailable", "allowCredentials", "authenticatorData", "signature", "userHandle", "undefined", "base64", "replace", "Uint8Array", "from", "atob", "c", "charCodeAt", "buffer", "btoa", "String", "fromCharCode", "apply", "creator", "createWebAuthn$1", "sdk", "identifier", "passkeyOptions", "startResponse", "webauthn", "signUp", "start", "origin", "finish", "transactionId", "signIn", "getResponse", "signUpOrIn", "o", "update", "helpers", "obj", "apiPaths", "generateNonce", "crypto", "getRandomValues", "array", "Array", "byte", "padStart", "performOneTap", "performOneTapAsync", "onFailed", "call", "auth", "provider", "oneTapConfig", "onSkipped", "onDismissed", "nonce", "googleClient", "reject", "google", "accounts", "googleScript", "document", "getElementById", "createElement", "head", "appendChild", "defer", "src", "onload", "onerror", "getGoogleClient", "clientIdRes", "oauth", "getOneTapClientId", "Error", "clientId", "callback", "initialize", "itp_support", "use_fedcm_for_prompt", "_b", "client_id", "prompt", "notification", "isDismissedMoment", "reason", "getDismissedReason", "isSkippedMoment", "getSkippedReason", "onCodeReceived", "verifyOneTapIDToken", "loginOptions", "code", "exchangeOneTapIDToken", "onAuthenticated", "withFlow", "coreSdk", "flow", "webAuthnSupport", "decoratedOptions", "href", "deviceInfo", "startOptionsVersion", "hasOidcParamsInUrl", "search", "includes", "scriptLoadingPromise", "loadScriptWithFallback", "urls", "getEntry", "entry", "url", "shift", "scriptEle", "input", "hash", "i", "abs", "addEventListener", "setAttribute", "getOidcClient", "projectId", "oidcConfig", "require", "loadOIDCModule", "OidcClient", "WebStorageStateStore", "redirectUri", "scope", "stateUserKey", "authority", "httpClient", "buildUrl", "applicationId", "settings", "redirect_uri", "response_type", "stateStore", "store", "loadUserInfo", "fetchRequestCredentials", "client", "createOidc", "getCachedClient", "finishLogin", "n", "processSigninResponse", "signInRes", "afterRequest", "Response", "session_state", "profile", "currentUrl", "searchParams", "delete", "history", "replaceState", "title", "removeOidcParamFromUrl", "loginWithRedirect", "arg", "disableNavigation", "createSigninRequest", "finishLoginIfNeed", "refreshToken", "useRefreshToken", "state", "logout", "id_token_hint", "post_logout_redirect_uri", "createSignoutRequest", "decoratedCreateSdk", "elem", "createSdk", "fpLoad", "catch", "autoRefresh", "clearAllTimers", "setTimer", "timerIds", "clearTimeout", "pop", "setTimeout", "createTimerFunctions", "sessionExpirationDate", "visibilityState", "refresh", "_req", "status", "claims", "refreshTimeStr", "toLocaleTimeString", "hour12", "wrapWith", "baseHeaders", "sessionExpirationPS", "sessionPS", "userPS", "userDetails", "wrappedSdk", "onSessionTokenChange", "onUserChange", "onIsAuthenticatedChange", "enableFlowNonce", "nonceStoragePrefix", "sdkConfig", "startsWith", "parseError", "headers", "then", "isStart", "ttlSeconds", "storeLastAuthenticatedUser", "keepLastAuthenticatedUserAfterLogout", "loginIds", "persistTokens", "isPersistTokens", "sessionTokenViaCookie", "storagePrefix", "isManagementApi", "test", "createCoreSdk", "oidc", "tryRefresh", "errorCode", "errorDescription", "currentSessionToken", "currentRefreshToken", "externalToken", "getExternalToken", "dcs", "dcr", "createWebAuthn", "fedcm", "onetap", "context", "identity", "providers", "configURL", "t"]
}
